using WindowAPI.minwinbase.Structures;
using WindowAPI.winsock2.Enums;
using WindowAPI.winsock2.Structures;
using WindowAPI.winuser.Structures;
using static WindowAPI.winsock2.CallBacks.CallBacks;
namespace WindowAPI.winsock2
{
    public static class Functions
    {

        /// <summary>
        ///The __WSAFDIsSet function returns a value indicating whether a socket is included in a set of socket descriptors.
        /// </summary>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int __WSAFDIsSet(short fd, fd_set unnamedParam2);

        /// <summary>
        ///The accept function permits an incoming connection attempt on a socket.
        /// </summary>
        /// <param name="s">A descriptor that identifies a socket that has been placed in a listening state with the listen function. The connection is actually made with the socket that is returned by accept.</param>
        /// <param name="addr"></param>
        /// <param name="addrlen">An optional pointer to an integer that contains the length of structure pointed to by the addr parameter.If no error occurs, accept returns a value of type SOCKET that is a descriptor for the new socket. This returned value is a handle for the socket on which the actual connection is made.Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling WSAGetLastError.The integer referred to by addrlen initially contains the amount of space pointed to by addr. On return it will contain the actual length in bytes of the address returned.The accept function extracts the first connection on the queue of pending connections on socket s. It then creates and returns a handle to the new socket. The newly created socket is the socket that will handle the actual connection; it has the same properties as socket s, including the asynchronous events registered with the WSAAsyncSelect or WSAEventSelect functions.The accept function can block the caller until a connection is present if no pending connections are present on the queue, and the socket is marked as blocking. If the socket is marked as nonblocking and no pending connections are present on the queue, accept returns an error as described in the following. After the successful completion of accept returns a new socket handle, the accepted socket cannot be used to accept more connections. The original socket remains open and listens for new connection requests.The parameter addr is a result parameter that is filled in with the address of the connecting entity, as known to the communications layer. The exact format of the addr parameter is determined by the address family in which the communication is occurring. The addrlen is a value-result parameter; it should initially contain the amount of space pointed to by addr; on return it will contain the actual length (in bytes) of the address returned.The accept function is used with connection-oriented socket types such as SOCK_STREAM. If addr and/or addrlen are equal to NULL, then no information about the remote address of the accepted socket is returned.For another example that uses the accept function, see Getting Started With Winsock.The following are important issues associated with connection setup, and must be considered when using Asynchronous Transfer Mode (ATM) with Windows Sockets 2:Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAAcceptWSAAsyncSelectWinsock FunctionsWinsock Referencebindconnectlistenselectsockaddrsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short accept(short s, out IN_ADDR addr, out int addrlen);

        /// <summary>
        ///The bind function associates a local address with a socket.
        /// </summary>
        /// <param name="s">A descriptor identifying an unbound socket.</param>
        /// <param name="name">A pointer to a sockaddr structure of the local address to assign to the bound socket .</param>
        /// <param name="namelen">The length, in bytes, of the value pointed to by the name parameter.If no error occurs, bind returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved by calling WSAGetLastError.The bind function is required on an unconnected socket before subsequent calls to the listen function. It is normally used to bind to either connection-oriented (stream) or connectionless (datagram) sockets. The bind function may also be used to bind to a raw socket (the socket was created by calling the socket function with the type parameter set to SOCK_RAW). The bind function may also be used on an unconnected socket before subsequent calls to the connect, ConnectEx, WSAConnect, WSAConnectByList, or WSAConnectByName functions before send operations.When a socket is created with a call to the socket function, it exists in a namespace (address family), but it has no name assigned to it. Use the bind function to establish the local association of the socket by assigning a local name to an unnamed socket.A name consists of three parts when using the Internet address family:In Windows Sockets 2, the name parameter is not strictly interpreted as a pointer to a sockaddr structure. It is cast this way for Windows Sockets 1.1 compatibility. Service providers are free to regard it as a pointer to a block of memory of size namelen. The first 2 bytes in this block (corresponding to the sa_family member of the sockaddr structure, the sin_family member of the sockaddr_in structure, or the sin6_family member of the sockaddr_in6 structure) must contain the address family that was used to create the socket. Otherwise, an error WSAEFAULT occurs.If an application does not care what local address is assigned, specify the constant value INADDR_ANY for an IPv4 local address or the constant value in6addr_any for an IPv6 local address in the sa_data member of the name parameter. This allows the underlying service provider to use any appropriate network address, potentially simplifying application programming in the presence of multihomed hosts (that is, hosts that have more than one network interface and address).For TCP/IP, if the port is specified as zero, the service provider assigns a unique port to the application from the dynamic client port range. On Windows Vista and later, the dynamic client port range is a value between 49152 and 65535. This is a change from Windows Server 2003 and earlier where the dynamic client port range was a value between 1025 and 5000. The maximum value for the client dynamic port range can be changed by setting a value under the following registry key:HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\ParametersThe MaxUserPort registry value sets the value to use for the maximum value of the dynamic client port range. You must restart the computer for this setting to take effect.On Windows Vista and later, the dynamic client port range can be viewed and changed using netsh commands. The dynamic client port range can be set differently for UDP and TCP and also for IPv4 and IPv6. For more information, see KB 929851.The application can use getsockname after calling bind to learn the address and the port that has been assigned to the socket. If the Internet address is equal to INADDR_ANY or in6addr_any, getsockname cannot necessarily supply the address until the socket is connected, since several addresses can be valid if the host is multihomed. Binding to a specific port number other than port 0 is discouraged for client applications, since there is a danger of conflicting with another socket already using that port number on the local computer.For multicast operations, the preferred method is to call the bind function to associate a socket with a local IP address and then join the multicast group. Although this order of operations is not mandatory, it is strongly recommended. So a multicast application would first select an IPv4 or IPv6 address on the local computer, the wildcard IPv4 address (INADDR_ANY), or the wildcard IPv6 address (in6addr_any). The multicast application would then call the bind function with this address in the in the sa_data member of the name parameter to associate the local IP address with the socket. If a wildcard address was specified, then Windows will select the local IP address to use. After the bind function completes, an application would then join the multicast group of interest. For more information on how to join a multicast group, see the section on Multicast Programming. This socket can then be used to receive multicast packets from the multicast group using the recv, recvfrom, WSARecv, WSARecvEx, WSARecvFrom, or LPFN_WSARECVMSG (WSARecvMsg) functions.The bind function is not normally required for send operations to a multicast group. The sendto,WSASendMsg, and WSASendTo functions implicitly bind the socket to the wildcard address if the socket is not already bound. The bind function is required before the use of the send or WSASend functions which do not perform an implicit bind and are allowed only on connected sockets, which means the socket must have already been bound for it to be connected. The bind function might be used before send operations using the sendto,WSASendMsg, or WSASendTo functions if an application wanted to select a specific local IP address on a local computer with multiple network interfaces and local IP addresses. Otherwise an implicit bind to the wildcard address using the sendto,WSASendMsg , or WSASendTo functions might result in a different local IP address being used for send operations.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.The following example demonstrates the use of the bind function. For another example that uses the bind function, see Getting Started With Winsock.Multicast ProgrammingSOL_SOCKET Socket OptionsSO_EXCLUSIVEADDRUSETCP/IP Raw SocketsUsing SO_REUSEADDR and SO_EXCLUSIVEADDRUSEWSACancelBlockingCallWinsock FunctionsWinsock Referenceconnectgetsocknamelistensetsockoptsockaddrsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int bind(short s, IN_ADDR name, int namelen);

        /// <summary>
        ///The closesocket function closes an existing socket.
        /// </summary>
        /// <param name="s">A descriptor identifying the socket to close.If no error occurs, closesocket returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.The closesocket function closes a socket. Use it to release the socket descriptor passed in the s parameter. Note that the socket descriptor passed in the s parameter may immediately be reused by the system as soon as closesocket function is issued. As a result, it is not reliable to expect further references to the socket descriptor passed in the s parameter to fail with the error WSAENOTSOCK. A Winsock client must never issue closesocket on s concurrently with another Winsock function call.Any pending overlapped send and receive operations ( WSASend/ WSASendTo/ WSARecv/ WSARecvFrom with an overlapped socket) issued by any thread in this process are also canceled. Any event, completion routine, or completion port action specified for these overlapped operations is performed. The pending overlapped operations fail with the error status WSA_OPERATION_ABORTED.An application should not assume that any outstanding I/O operations on a socket will all be guaranteed to completed when closesocket returns. The closesocket function will initiate cancellation on the outstanding I/O operations, but that does not mean that an application will receive I/O completion for these I/O operations by the time the closesocket function returns. Thus, an application should not cleanup any resources (WSAOVERLAPPED structures, for example) referenced by the outstanding I/O requests until the I/O requests are indeed completed.An application should always have a matching call to closesocket for each successful call to socket to return any socket resources to the system.The linger structure maintains information about a specific socket that specifies how that socket should behave when data is queued to be sent and the closesocket function is called on the socket.The l_onoff member of the linger structure determines whether a socket should remain open for a specified amount of time after a closesocket function call to enable queued data to be sent. This member can be modified in two ways:The l_linger member of the linger structure determines the amount of time, in seconds, a socket should remain open. This member is only applicable if the l_onoff member of the linger structure is nonzero.The default parameters for a socket are the l_onoff member of the linger structure is zero, indicating that the socket should not remain open. The default value for the l_linger member of the linger structure is zero, but this value is ignored when the l_onoff member is set to zero.To enable a socket to remain open, an application should set the l_onoff member to a nonzero value and set the l_linger member to the desired timeout in seconds. To disable a socket from remaining open, an application only needs to set the l_onoff member of the linger structure to zero.If an application calls the setsockopt function with the optname parameter set to SO_DONTLINGER to set the l_onoff member to a nonzero value, the value for the l_linger member is not specified. In this case, the timeout used is implementation dependent. If a previous timeout has been established for a socket (by previously calling the setsockopt function with the optname parameter set to SO_LINGER), this timeout value should be reinstated by the service provider.The semantics of the closesocket function are affected by the socket options that set members of linger structure.If the l_onoff member of the LINGER structure is zero on a stream socket, the closesocket call will return immediately and does not receive WSAEWOULDBLOCK whether the socket is blocking or nonblocking. However, any data queued for transmission will be sent, if possible, before the underlying socket is closed. This is also called a graceful disconnect or close. In this case, the Windows Sockets provider cannot release the socket and other resources for an arbitrary period, thus affecting applications that expect to use all available sockets. This is the default behavior for a socket.If the l_onoff member of the linger structure is nonzero and l_linger member is zero, closesocket is not blocked even if queued data has not yet been sent or acknowledged. This is called a hard or abortive close, because the socket's virtual circuit is reset immediately, and any unsent data is lost. On Windows, any recv call on the remote side of the circuit will fail with WSAECONNRESET.If the l_onoff member of the linger structure is set to nonzero and l_linger member is set to a nonzero timeout on a blocking socket, the closesocket call blocks until the remaining data has been sent or until the timeout expires. This is called a graceful disconnect or close if all of the data is sent within timeout value specified in the l_linger member. If the timeout expires before all data has been sent, the Windows Sockets implementation terminates the connection before closesocket returns and this is called a hard or abortive close.Setting the l_onoff member of the linger structure to nonzero and the l_linger member with a nonzero timeout interval on a nonblocking socket is not recommended. In this case, the call to closesocket will fail with an error of WSAEWOULDBLOCK if the close operation cannot be completed immediately. If closesocket fails with WSAEWOULDBLOCK the socket handle is still valid, and a disconnect is not initiated. The application must call closesocket again to close the socket.If the l_onoff member of the linger structure is nonzero and the l_linger member is a nonzero timeout interval on a blocking socket, the result of the closesocket function can't be used to determine whether all data has been sent to the peer. If the data is sent before the timeout specified in the l_linger member expires or if the connection was aborted, the closesocket function won't return an error code (the return value from the closesocket function is zero).The closesocket call will only block until all data has been delivered to the peer or the timeout expires. If the connection is reset because the timeout expires, then the socket will not go into TIME_WAIT state. If all data is sent within the timeout period, then the socket can go into TIME_WAIT state.If the l_onoff member of the linger structure is nonzero and the l_linger member is a zero timeout interval on a blocking socket, then a call to closesocket will reset the connection. The socket will not go to the TIME_WAIT state.The getsockopt function can be called with the optname parameter set to SO_LINGER to retrieve the current value of the linger structure associated with a socket.Here is a summary of closesocket behavior:For additional information please see Graceful Shutdown, Linger Options, and Socket Closure for more information.Keep the following in mind:The following are important issues associated with connection teardown when using Asynchronous Transfer Mode (ATM) and Windows Sockets 2:Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.Graceful Shutdown, Linger Options, and Socket ClosureWSAAsyncSelectWSADuplicateSocketWSAOVERLAPPEDWinsock FunctionsWinsock Referenceacceptgetsockoptioctlsocketlingersetsockoptsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int closesocket(short s);

        /// <summary>
        ///The connect function establishes a connection to a specified socket.
        /// </summary>
        /// <param name="s">A descriptor identifying an unconnected socket.</param>
        /// <param name="name">A pointer to the sockaddr structure to which the connection should be established.</param>
        /// <param name="namelen">The length, in bytes, of the sockaddr structure pointed to by the name parameter.If no error occurs, connect returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved by calling WSAGetLastError.On a blocking socket, the return value indicates success or failure of the connection attempt.With a nonblocking socket, the connection attempt cannot be completed immediately. In this case, connect will return SOCKET_ERROR, and WSAGetLastError will return WSAEWOULDBLOCK. In this case, there are three possible scenarios:Until the connection attempt completes on a nonblocking socket, all subsequent calls to connect on the same socket will fail with the error code WSAEALREADY, and WSAEISCONN when the connection completes successfully. Due to ambiguities in version 1.1 of the Windows Sockets specification, error codes returned from connect while a connection is already pending may vary among implementations. As a result, it is not recommended that applications use multiple calls to connect to detect connection completion. If they do, they must be prepared to handle WSAEINVAL and WSAEWOULDBLOCK error values the same way that they handle WSAEALREADY, to assure robust operation.If the error code returned indicates the connection attempt failed (that is, WSAECONNREFUSED, WSAENETUNREACH, WSAETIMEDOUT) the application can call connect again for the same socket.The connect function is used to create a connection to the specified destination. If socket s, is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound.For connection-oriented sockets (for example, type SOCK_STREAM), an active connection is initiated to the foreign host using name (an address in the namespace of the socket; for a detailed description, see bind and sockaddr).When the socket call completes successfully, the socket is ready to send and receive data. If the address member of the structure specified by the name parameter is filled with zeros, connect will return the error WSAEADDRNOTAVAIL. Any attempt to reconnect an active connection will fail with the error code WSAEISCONN.For connection-oriented, nonblocking sockets, it is often not possible to complete the connection immediately. In such a case, this function returns the error WSAEWOULDBLOCK. However, the operation proceeds.When the success or failure outcome becomes known, it may be reported in one of two ways, depending on how the client registers for notification.If the connection is not completed immediately, the client should wait for connection completion before attempting to set socket options using setsockopt. Calling setsockopt while a connection is in progress is not supported.For a connectionless socket (for example, type SOCK_DGRAM), the operation performed by connect is merely to establish a default destination address that can be used on subsequent send/ WSASend and recv/ WSARecv calls. Any datagrams received from an address other than the destination address specified will be discarded. If the address member of the structure specified by name is filled with zeros, the socket will be disconnected. Then, the default remote address will be indeterminate, so send/ WSASend and recv/ WSARecv calls will return the error code WSAENOTCONN. However, sendto/ WSASendTo and recvfrom/ WSARecvFrom can still be used. The default destination can be changed by simply calling connect again, even if the socket is already connected. Any datagrams queued for receipt are discarded if name is different from the previous connect.For connectionless sockets, name can indicate any valid address, including a broadcast address. However, to connect to a broadcast address, a socket must use setsockopt to enable the SO_BROADCAST option. Otherwise, connect will fail with the error code WSAEACCES.When a connection between sockets is broken, the socket that was connected should be discarded and new socket should be created. When a problem develops on a connected socket, the application must discard the socket and create the socket again in order to return to a stable point.For another example that uses the connect function, see Getting Started With Winsock.IrDA implements the connect function with addresses of the form sockaddr_irda. Typically, a client application will create a socket with the socket function, scan the immediate vicinity for IrDA devices with the IRLMP_ENUMDEVICES socket option, choose a device from the returned list, form an address, and then call connect. There is no difference between blocking and nonblocking semantics.WSAAsyncSelectWSAConnectConnectExWinsock FunctionsWinsock Referenceacceptbindgetsocknameselectsockaddrsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int connect(short s, IN_ADDR name, int namelen);

        /// <summary>
        ///The FD_SET macro adds a file descriptor to an fd_set. If the file descriptor already exist within the set, a duplicate will not be added.
        /// </summary>

        [DllImport("req.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void FD_SET(dynamic fd, dynamic set);

        /// <summary>
        ///[gethostbyaddr is no longer recommended for use as of Windows Sockets 2. Instead, use getnameinfo.]
        /// </summary>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern HOSTENT gethostbyaddr(char addr);

        /// <summary>
        ///The gethostbyname function retrieves host information corresponding to a host name from a host database.
        /// </summary>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern HOSTENT gethostbyname(char name);

        /// <summary>
        ///The gethostname function retrieves the standard host name for the local computer.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="namelen">The length, in bytes, of the buffer pointed to by the name parameter.If no error occurs, gethostname returns zero. Otherwise, it returns SOCKET_ERROR and a specific error code can be retrieved by calling WSAGetLastError.The gethostname function returns the name of the local host into the buffer specified by the name parameter. The host name is returned as a null-terminated string. The form of the host name is dependent on the Windows Sockets provider—it can be a simple host name, or it can be a fully qualified domain name. However, it is guaranteed that the name returned will be successfully parsed by gethostbyname and WSAAsyncGetHostByName.The maximum length of the name returned in the buffer pointed to by the name parameter is dependent on the namespace provider.If the gethostname function is used on a cluster resource on Windows Server 2008, Windows Server 2003, or Windows 2000 Server and the CLUSTER_NETWORK_NAME environment variable is defined, then the value in this environment variable overrides the actual hostname and is returned. On a cluster resource, the CLUSTER_NETWORK_NAME environment variable contains the name of the cluster.The gethostname function queries namespace providers to determine the local host name using the SVCID_HOSTNAME GUID defined in the Svgguid.h header file. If no namespace provider responds, then the gethostname function returns the NetBIOS name of the local computer.The maximum length, in bytes, of the string returned in the buffer pointed to by the name parameter is dependent on the namespace provider, but this string must be 256 bytes or less. So if a buffer of 256 bytes is passed in the name parameter and the namelen parameter is set to 256, the buffer size will always be adequate.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.GetAddrInfoWWSAAsyncGetHostByNameWinsock FunctionsWinsock Referencegethostbyname</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int gethostname(out char name, int namelen);

        /// <summary>
        ///The GetHostNameW function retrieves the standard host name for the local computer as a Unicode string.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="namelen">The length, in wide characters, of the buffer pointed to by the name parameter.If no error occurs, GetHostNameW returns zero. Otherwise, it returns SOCKET_ERROR and a specific error code can be retrieved by calling WSAGetLastError.The GetHostNameW function returns the name of the local host into the buffer specified by the name parameter in Unicode (UTF-16). The host name is returned as a null-terminated Unicode string. The form of the host name is dependent on the Windows Sockets provider—it can be a simple host name, or it can be a fully qualified domain name. However, it is guaranteed that the name returned will be successfully parsed by GetAddrInfoW.With the growth of the Internet, there is a growing need to identify Internet host names for other languages not represented by the ASCII character set. Identifiers which facilitate this need and allow non-ASCII characters (Unicode) to be represented as special ASCII character strings (Punycode) are known as Internationalized Domain Names (IDNs). A mechanism called Internationalizing Domain Names in Applications (IDNA) is used to handle IDNs in a standard fashion. The GetHostNameW function does not convert the local hostname between Punycode and Unicode. The GetAddrInfoW function provides support for Internationalized Domain Name (IDN) parsing and performs Punycode/IDN encoding and conversion.If the GetHostNameW function is used on a cluster resource on Windows Server 2012 and the CLUSTER_NETWORK_NAME environment variable is defined, then the value in this environment variable overrides the actual hostname and is returned. On a cluster resource, the CLUSTER_NETWORK_NAME environment variable contains the name of the cluster.The GetHostNameW function queries namespace providers to determine the local host name using the SVCID_HOSTNAME GUID defined in the Svgguid.h header file. If no namespace provider responds, then the GetHostNameW function returns the NetBIOS name of the local computer in Unicode.The maximum length, in wide characters, of the string returned in the buffer pointed to by the name parameter is dependent on the namespace provider, but this string must be 256 wide characters or less. So if a buffer of 256 wide characters is passed in the name parameter and the namelen parameter is set to 256, the buffer size will always be adequate.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.GetAddrInfoWWinsock FunctionsWinsock Referencegethostname</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetHostNameW(out string name, int namelen);

        /// <summary>
        ///The getpeername function retrieves the address of the peer to which a socket is connected.
        /// </summary>
        /// <param name="s">A descriptor identifying a connected socket.</param>
        /// <param name="name"></param>
        /// <param name="namelen">A pointer to the size, in bytes, of the name parameter.If no error occurs, getpeername returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.The getpeername function retrieves the address of the peer connected to the socket s and stores the address in the SOCKADDR structure identified by the name parameter. This function works with any address family and it simply returns the address to which the socket is connected. The getpeername function can be used only on a connected socket.For datagram sockets, only the address of a peer specified in a previous connect call will be returned. Any address specified by a previous sendto call will not be returned by getpeername.On call, the namelen parameter contains the size, in bytes, of the name buffer. On return, the namelen parameter contains the actual size, in bytes, of the name parameter returned.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.Winsock FunctionsWinsock Referencebindconnectgetsocknamesendtosocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int getpeername(short s, out IN_ADDR name, out int namelen);

        /// <summary>
        ///The getprotobyname function retrieves the protocol information corresponding to a protocol name.
        /// </summary>
        /// <param name="name">Pointer to a null-terminated protocol name.If no error occurs, getprotobyname returns a pointer to the protoent. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling WSAGetLastError.The getprotobyname function returns a pointer to the protoent structure containing the name(s) and protocol number that correspond to the protocol specified in the name parameter. All strings are null-terminated. The protoent structure is allocated by the Windows Sockets library. An application must never attempt to modify this structure or to free any of its components. Furthermore, like hostent, only one copy of this structure is allocated per thread, so the application should copy any information that it needs before issuing any other Windows Sockets function calls.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAAsyncGetProtoByNameWinsock FunctionsWinsock Referencegetprotobynumber</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern PROTOENT getprotobyname(char name);

        /// <summary>
        ///The getprotobynumber function retrieves protocol information corresponding to a protocol number.
        /// </summary>
        /// <param name="number">Protocol number, in host byte order.If no error occurs, getprotobynumber returns a pointer to the protoent structure. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling WSAGetLastError.This getprotobynumber function returns a pointer to the protoent structure as previously described in getprotobyname. The contents of the structure correspond to the given protocol number.The pointer that is returned points to the structure allocated by Windows Sockets. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information that it needs before issuing any other Windows Sockets function calls.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAAsyncGetProtoByNumberWinsock FunctionsWinsock Referencegetprotobyname</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern PROTOENT getprotobynumber(int number);

        /// <summary>
        ///The getservbyname function retrieves service information corresponding to a service name and protocol.
        /// </summary>
        /// <param name="name">A pointer to a null-terminated service name.</param>
        /// <param name="proto">A pointer to a null-terminated protocol name. If this pointer is NULL, the getservbyname function returns the first service entry where name matches the s_name member of the servent structure or the s_aliases member of the servent structure. Otherwise, getservbyname matches both the name and the proto.If no error occurs, getservbyname returns a pointer to the servent structure. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling WSAGetLastError.The getservbyname function returns a pointer to the servent structure containing the name(s) and service number that match the string in the name parameter. All strings are null-terminated.The pointer that is returned points to the servent structure allocated by the Windows Sockets library. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information it needs before issuing any other Windows Sockets function calls.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAAsyncGetServByNameWinsock FunctionsWinsock Referencegetservbyport</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern SERVENT getservbyname(char name, char proto);

        /// <summary>
        ///The getservbyport function retrieves service information corresponding to a port and protocol.
        /// </summary>
        /// <param name="port">Port for a service, in network byte order.</param>
        /// <param name="proto">Optional pointer to a protocol name. If this is null, getservbyport returns the first service entry for which the port matches the s_port of the servent structure. Otherwise, getservbyport matches both the port and the proto parameters.If no error occurs, getservbyport returns a pointer to the servent structure. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling WSAGetLastError.The getservbyport function returns a pointer to a servent structure as it does in the getservbyname function.The servent structure is allocated by Windows Sockets. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information it needs before issuing any other Windows Sockets function calls.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAAsyncGetServByPortWinsock FunctionsWinsock Referencegetservbyname</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern SERVENT getservbyport(int port, char proto);

        /// <summary>
        ///The getsockname function retrieves the local name for a socket.
        /// </summary>
        /// <param name="s">Descriptor identifying a socket.</param>
        /// <param name="name"></param>
        /// <param name="namelen">Size of the name buffer, in bytes.If no error occurs, getsockname returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.The getsockname function retrieves the current name for the specified socket descriptor in name. It is used on the bound or connected socket specified by the s parameter. The local association is returned. This call is especially useful when a connect call has been made without doing a bind first; the getsockname function provides the only way to determine the local association that has been set by the system.On call, the namelen parameter contains the size of the name buffer, in bytes. On return, the namelen parameter contains the actual size in bytes of the name parameter.The getsockname function does not always return information about the host address when the socket has been bound to an unspecified address, unless the socket has been connected with connect or accept (for example, using ADDR_ANY). A Windows Sockets application must not assume that the address will be specified unless the socket is connected. The address that will be used for the socket is unknown unless the socket is connected when used in a multihomed host. If the socket is using a connectionless protocol, the address may not be available until I/O occurs on the socket.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.SOCKADDRWinsock FunctionsWinsock Referencebindgetpeernamesocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int getsockname(short s, out IN_ADDR name, out int namelen);

        /// <summary>
        ///The getsockopt function retrieves a socket option.
        /// </summary>
        /// <param name="s">A descriptor identifying a socket.</param>
        /// <param name="level">The level at which the option is defined. Example: SOL_SOCKET.</param>
        /// <param name="optname">The socket option for which the value is to be retrieved. Example: SO_ACCEPTCONN. The optname value must be a socket option defined within the specified level, or behavior is undefined.</param>
        /// <param name="optval"></param>
        /// <param name="optlen">A pointer to the size, in bytes, of the optval buffer.If no error occurs, getsockopt returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.The getsockopt function retrieves the current value for a socket option associated with a socket of any type, in any state, and stores the result in optval. Options can exist at multiple protocol levels, but they are always present at the uppermost socket level. Options affect socket operations, such as the packet routing and OOB data transfer.The value associated with the selected option is returned in the buffer optval. The integer pointed to by optlen should originally contain the size of this buffer; on return, it will be set to the size of the value returned. For SO_LINGER, this will be the size of a LINGER structure. For most other options, it will be the size of an integer.The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specified.If the option was never set with setsockopt, then getsockopt returns the default value for the option.The following options are supported for getsockopt. The Type column identifies the type of data addressed by optval.For more information on socket options, see Socket Options.The following table of value for the optname parameter are valid when the level parameter is set to SOL_SOCKET.level = IPPROTO_TCPSee TCP_NODELAY in IPPROTO_TCP socket options. Also see that topic for more complete and detailed information about socket options for level = IPPROTO_TCP.  The following table of value for the optname parameter are valid when the level parameter is set to NSPROTO_IPX.The following table lists value for the optname that represent BSD socket options that are not supported by the getsockopt function.Calling getsockopt with an unsupported option will result in an error code of WSAENOPROTOOPT being returned from WSAGetLastError.More detailed information on some of the socket options for the optname parameter supported by the getsockopt function are listed below.Before an IrDA socket connection can be initiated, a device address must be obtained by performing a getsockopt(,,IRLMP_ENUMDEVICES,,) function call, which returns a list of all available IrDA devices. A device address returned from the function call is copied into a SOCKADDR_IRDA structure, which in turn is used by a subsequent call to the connect function call.Discovery can be performed in two ways:The IAS_QUERY structure shown in the Type column in the previous table is used to retrieve a single attribute of a single class from a peer device's IAS database. The application specifies the device and class to query and the attribute and attribute type. Note that the device would have been obtained previously by a call to getsockopt(IRLMP_ENUMDEVICES). It is expected that the application allocates a buffer, of the necessary size, for the returned parameters.Many level socket options are not meaningful to IrDA; only SO_LINGER and SO_DONTLINGER are specifically supported.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.IPPROTO_IP Socket OptionsIPPROTO_IPV6 Socket OptionsIPPROTO_RM Socket OptionsIPPROTO_TCP Socket OptionsIPPROTO_UDP Socket OptionsNSPROTO_IPX Socket OptionsSOL_APPLETALK Socket OptionsSOL_IRLMP Socket OptionsSOL_SOCKET Socket OptionsSocket OptionsWSAAsyncSelectWSAConnectWSAGetLastErrorWSAIoctlWSASetLastErrorWinsock Functionsioctlsocketrecvsetsockoptsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int getsockopt(short s, int level, int optname, out char optval, out int optlen);

        /// <summary>
        ///The htond inline function converts a double from host to TCP/IP network byte order (which is big-endian).
        /// </summary>

        [DllImport("req.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint htond(double Value);

        /// <summary>
        ///The htonf inline function converts a float from host to TCP/IP network byte order (which is big-endian).
        /// </summary>

        [DllImport("req.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint htonf(float Value);

        /// <summary>
        ///The htonl function converts a u_long from host to TCP/IP network byte order (which is big-endian).
        /// </summary>
        /// <param name="hostlong">A 32-bit number in host byte order.The htonl function returns the value in TCP/IP's network byte order.The htonl function takes a 32-bit number in host byte order and returns a 32-bit number in the network byte order used in TCP/IP networks (the AF_INET or AF_INET6 address family).The htonl function can be used to convert an IPv4 address in host byte order to the IPv4 address in network byte order. This function does not do any checking to determine if the hostlong parameter is a valid IPv4 address.The htonl function does not require that the Winsock DLL has previously been loaded with a successful call to the WSAStartup function.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.InetNtopInetPtonWSAHtonlWSAHtonsWSANtohlWSANtohshtondhtonfhtonllhtonsinet_addrinet_ntoantohdntohfntohllntohs</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint htonl(uint hostlong);

        /// <summary>
        ///The htonll inline function converts an unsigned __int64 from host to TCP/IP network byte order (which is big-endian).
        /// </summary>

        [DllImport("req.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint htonll();

        /// <summary>
        ///The htons function converts a u_short from host to TCP/IP network byte order (which is big-endian).
        /// </summary>
        /// <param name="hostshort">A 16-bit number in host byte order.The htons function returns the value in TCP/IP network byte order.The htons function takes a 16-bit number in host byte order and returns a 16-bit number in network byte order used in TCP/IP networks (the AF_INET or AF_INET6 address family).The htons function can be used to convert an IP port number in host byte order to the IP port number in network byte order.The htons function does not require that the Winsock DLL has previously been loaded with a successful call to the WSAStartup function.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.InetNtopInetPtonWSAHtonlWSAHtonsWSANtohlWSANtohshtondhtonfhtonlhtonllinet_addrinet_ntoantohdntohfntohlntohllntohs</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern ushort htons(ushort hostshort);

        /// <summary>
        ///The inet_addr function converts a string containing an IPv4 dotted-decimal address into a proper address for the IN_ADDR structure.
        /// </summary>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint inet_addr(char cp);

        /// <summary>
        ///The inet_ntoa function converts an (Ipv4) Internet network address into an ASCII string in Internet standard dotted-decimal format.
        /// </summary>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern char inet_ntoa();

        /// <summary>
        ///The ioctlsocket function controls the I/O mode of a socket.
        /// </summary>
        /// <param name="s">A descriptor identifying a socket.</param>
        /// <param name="cmd">A command to perform on the socket s.</param>
        /// <param name="argp">A pointer to a parameter for cmd.Upon successful completion, the ioctlsocket returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.The ioctlsocket function can be used on any socket in any state. It is used to set or retrieve some operating parameters associated with the socket, independent of the protocol and communications subsystem. Here are the supported commands to use in the cmd parameter and their semantics:The WSAIoctl function is used to set or retrieve operating parameters associated with the socket, the transport protocol, or the communications subsystem.The WSAIoctl function is more powerful than the ioctlsocket function and supports a large number of possible values for the operating parameters to set or retrieve.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAAsyncSelectWSAEventSelectWSAIoctlWinsock FunctionsWinsock Referencegetsockoptsetsockoptsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ioctlsocket(short s, int cmd, out uint argp);

        /// <summary>
        ///The listen function places a socket in a state in which it is listening for an incoming connection.
        /// </summary>
        /// <param name="s">A descriptor identifying a bound, unconnected socket.</param>
        /// <param name="backlog">The maximum length of the queue of pending connections. If set to SOMAXCONN, the underlying service provider responsible for socket s will set the backlog to a maximum reasonable value. If set to SOMAXCONN_HINT(N) (where N is a number), the backlog value will be N, adjusted to be within the range (200, 65535). Note that SOMAXCONN_HINT can be used to set the backlog to a larger value than possible with SOMAXCONN.SOMAXCONN_HINT is only supported by the Microsoft TCP/IP service provider. There is no standard provision to obtain the actual backlog value.If no error occurs, listen returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.To accept connections, a socket is first created with the socket function and bound to a local address with the bind function. A backlog for incoming connections is specified with listen, and then the connections are accepted with the accept function. Sockets that are connection oriented, those of type SOCK_STREAM for example, are used with listen. The socket s is put into passive mode where incoming connection requests are acknowledged and queued pending acceptance by the process.A value for the backlog of SOMAXCONN is a special constant that instructs the underlying service provider responsible for socket s to set the length of the queue of pending connections to a maximum reasonable value.On Windows Sockets 2, this maximum value defaults to a large value (typically several hundred or more).When calling the listen function in a Bluetooth application, it is strongly recommended that a much lower value be used for the backlog parameter (typically 2 to 4), since only a few client connections are accepted. This reduces the system resources that are allocated for use by the listening socket. This same recommendation applies to other network applications that expect only a few client connections.The listen function is typically used by servers that can have more than one connection request at a time. If a connection request arrives and the queue is full, the client will receive an error with an indication of WSAECONNREFUSED.If there are no available socket descriptors, listen attempts to continue to function. If descriptors become available, a later call to listen or accept will refill the queue to the current or most recent value specified for the backlog parameter, if possible, and resume listening for incoming connections.If the listen function is called on an already listening socket, it will return success without changing the value for the backlog parameter. Setting the backlog parameter to 0 in a subsequent call to listen on a listening socket is not considered a proper reset, especially if there are connections on the socket.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.Winsock FunctionsWinsock Referenceacceptconnectsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int listen(short s, int backlog);

        /// <summary>
        ///The ntohd inline function converts an unsigned __int64 from TCP/IP network order to host byte order (which is little-endian on Intel processors) and returns a double.
        /// </summary>

        [DllImport("req.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern double ntohd();

        /// <summary>
        ///The ntohf inline function converts an unsigned __int32 from TCP/IP network order to host byte order (which is little-endian on Intel processors) and returns a float.
        /// </summary>

        [DllImport("req.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern float ntohf();

        /// <summary>
        ///The ntohl function converts a u_long from TCP/IP network order to host byte order (which is little-endian on Intel processors).
        /// </summary>
        /// <param name="netlong">A 32-bit number in TCP/IP network byte order.The ntohl function returns the value supplied in the netlong parameter with the byte order reversed. If netlong is already in host byte order, then this function will reverse it. It is up to the application to determine if the byte order must be reversed.The ntohl function takes a 32-bit number in TCP/IP network byte order (the AF_INET or AF_INET6 address family) and returns a 32-bit number in host byte order.The ntohl function can be used to convert an IPv4 address in network byte order to the IPv4 address in host byte order. This function does not do any checking to determine if the netlong parameter is a valid IPv4 address.The ntohl function does not require that the Winsock DLL has previously been loaded with a successful call to the WSAStartup function.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.InetNtopInetPtonWSAHtonlWSAHtonsWSANtohlWSANtohshtondhtonfhtonlhtonllhtonsinet_addrinet_ntoantohdntohfntohs</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint ntohl(uint netlong);

        /// <summary>
        ///The ntohll inline function converts an unsigned __int64 from TCP/IP network order to host byte order (which is little-endian on Intel processors).
        /// </summary>

        [DllImport("req.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint ntohll();

        /// <summary>
        ///The ntohs function converts a u_short from TCP/IP network byte order to host byte order (which is little-endian on Intel processors).
        /// </summary>
        /// <param name="netshort">A 16-bit number in TCP/IP network byte order.The ntohs function returns the value in host byte order. If the netshort parameter is already in host byte order, then this function will reverse it. It is up to the application to determine if the byte order must be reversed.The ntohs function takes a 16-bit number in TCP/IP network byte order (the AF_INET or AF_INET6 address family) and returns a 16-bit number in host byte order.The ntohs function can be used to convert an IP port number in network byte order to the IP port number in host byte order.The ntohs function does not require that the Winsock DLL has previously been loaded with a successful call to the WSAStartup function.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.InetNtopInetPtonWSAHtonlWSAHtonsWSANtohlWSANtohshtondhtonfhtonlhtonllhtonsinet_addrinet_ntoantohdntohfntohlntohll</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern ushort ntohs(ushort netshort);

        /// <summary>
        ///Associates a set of sockets with a completion port, and retrieves any notifications that are already pending on that port. Once associated, the completion port receives the socket state notifications that were specified. Only Microsoft Winsock provider sockets are supported.
        /// </summary>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint ProcessSocketNotifications(nint completionPort, int registrationCount, SOCK_NOTIFY_REGISTRATION registrationInfos, int timeoutMs, uint completionCount, OVERLAPPED_ENTRY completionPortEntries, int receivedEntryCount);

        /// <summary>
        ///The recv function receives data from a connected socket or a bound connectionless socket.
        /// </summary>
        /// <param name="s">The descriptor that identifies a connected socket.</param>
        /// <param name="buf"></param>
        /// <param name="len">The length, in bytes, of the buffer pointed to by the buf parameter.</param>
        /// <param name="flags">A set of flags that influences the behavior of this function. See remarks below. See the Remarks section for details on the possible value for this parameter.If no error occurs, recv returns the number of bytes received and the buffer pointed to by the buf parameter will contain this data received. If the connection has been gracefully closed, the return value is zero.Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.The recv function is used to read incoming data on connection-oriented sockets, or connectionless sockets. When using a connection-oriented protocol, the sockets must be connected before calling recv. When using a connectionless protocol, the sockets must be bound before calling recv.The local address of the socket must be known. For server applications, use an explicit bind function or an implicit accept or WSAAccept function. Explicit binding is discouraged for client applications. For client applications, the socket can become bound implicitly to a local address using connect, WSAConnect, sendto, WSASendTo, or WSAJoinLeaf.For connected or connectionless sockets, the recv function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are (silently) discarded.For connection-oriented sockets (type SOCK_STREAM for example), calling recv will return as much data as is currently available—up to the size of the buffer specified. If the socket has been configured for in-line reception of OOB data (socket option SO_OOBINLINE) and OOB data is yet unread, only OOB data will be returned. The application can use the ioctlsocket or WSAIoctlSIOCATMARK command to determine whether any more OOB data remains to be read.For connectionless sockets (type SOCK_DGRAM or other message-oriented sockets), data is extracted from the first enqueued datagram (message) from the destination address specified by the connect function.If the datagram or message is larger than the buffer specified, the buffer is filled with the first part of the datagram, and recv generates the error WSAEMSGSIZE. For unreliable protocols (for example, UDP) the excess data is lost; for reliable protocols, the data is retained by the service provider until it is successfully read by calling recv with a large enough buffer.If no incoming data is available at the socket, the recv call blocks and waits for data to arrive according to the blocking rules defined for WSARecv with the MSG_PARTIAL flag not set unless the socket is nonblocking. In this case, a value of SOCKET_ERROR is returned with the error code set to WSAEWOULDBLOCK. The select, WSAAsyncSelect, or WSAEventSelect functions can be used to determine when more data arrives.If the socket is connection oriented and the remote side has shut down the connection gracefully, and all data has been received, a recv will complete immediately with zero bytes received. If the connection has been reset, a recv will fail with the error WSAECONNRESET.The flags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. The semantics of this function are determined by the socket options and the flags parameter. The possible value of flags parameter is constructed by using the bitwise OR operator with any of the following values.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAAsyncSelectWSARecvWSARecvExWinsock FunctionsWinsock Referencerecvfromselectsendsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int recv(short s, out char buf, int len, int flags);

        /// <summary>
        ///The recvfrom function receives a datagram, and stores the source address.
        /// </summary>
        /// <param name="s">A descriptor identifying a bound socket.</param>
        /// <param name="buf"></param>
        /// <param name="len">The length, in bytes, of the buffer pointed to by the buf parameter.</param>
        /// <param name="flags">A set of options that modify the behavior of the function call beyond the options specified for the associated socket. See the Remarks below for more details.</param>
        /// <param name="from"></param>
        /// <param name="fromlen"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int recvfrom(short s, out char buf, int len, int flags, out IN_ADDR from, out int fromlen);

        /// <summary>
        ///The select function determines the status of one or more sockets, waiting if necessary, to perform synchronous I/O.
        /// </summary>
        /// <param name="nfds">Ignored. The nfds parameter is included only for compatibility with Berkeley sockets.</param>
        /// <param name="readfds">An optional pointer to a set of sockets to be checked for readability.</param>
        /// <param name="writefds">An optional pointer to a set of sockets to be checked for writability.</param>
        /// <param name="exceptfds">An optional pointer to a set of sockets to be checked for errors.</param>
        /// <param name="timeout">The maximum time for select to wait, provided in the form of a TIMEVAL structure. Set the timeout parameter to null for blocking operations.The select function returns the total number of socket handles that are ready and contained in the fd_set structures, zero if the time limit expired, or SOCKET_ERROR if an error occurred. If the return value is SOCKET_ERROR, WSAGetLastError can be used to retrieve a specific error code.The select function is used to determine the status of one or more sockets. For each socket, the caller can request information on read, write, or error status. The set of sockets for which a given status is requested is indicated by an fd_set structure. The sockets contained within the fd_set structures must be associated with a single service provider. For the purpose of this restriction, sockets are considered to be from the same service provider if the WSAPROTOCOL_INFO structures describing their protocols have the same providerId value. Upon return, the structures are updated to reflect the subset of these sockets that meet the specified condition. The select function returns the number of sockets meeting the conditions. A set of macros is provided for manipulating an fd_set structure. These macros are compatible with those used in the Berkeley software, but the underlying representation is completely different.The parameter readfds identifies the sockets that are to be checked for readability. If the socket is currently in the listen state, it will be marked as readable if an incoming connection request has been received such that an accept is guaranteed to complete without blocking. For other sockets, readability means that queued data is available for reading such that a call to recv, WSARecv, WSARecvFrom, or recvfrom is guaranteed not to block.For connection-oriented sockets, readability can also indicate that a request to close the socket has been received from the peer. If the virtual circuit was closed gracefully, and all data was received, then a recv will return immediately with zero bytes read. If the virtual circuit was reset, then a recv will complete immediately with an error code such as WSAECONNRESET. The presence of OOB data will be checked if the socket option SO_OOBINLINE has been enabled (see setsockopt).The parameter writefds identifies the sockets that are to be checked for writability. If a socket is processing a connect call (nonblocking), a socket is writable if the connection establishment successfully completes. If the socket is not processing a connect call, writability means a send, sendto, or WSASendto are guaranteed to succeed. However, they can block on a blocking socket if the len parameter exceeds the amount of outgoing system buffer space available. It is not specified how long these guarantees can be assumed to be valid, particularly in a multithreaded environment.The parameter exceptfds identifies the sockets that are to be checked for the presence of OOB data or any exceptional error conditions.In summary, a socket will be identified in a particular set when select returns if:readfds:The parameter time-out controls how long the select can take to complete. If time-out is a null pointer, select will block indefinitely until at least one descriptor meets the specified criteria. Otherwise, time-out points to a TIMEVAL structure that specifies the maximum time that select should wait before returning. When select returns, the contents of the TIMEVAL structure are not altered. If TIMEVAL is initialized to {0, 0}, select will return immediately; this is used to poll the state of the selected sockets. If select returns immediately, then the select call is considered nonblocking and the standard assumptions for nonblocking calls apply. For example, the blocking hook will not be called, and Windows Sockets will not yield.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.TIMEVALWSAAsyncSelectWSAEventSelectWinsock FunctionsWinsock Referenceacceptconnectrecvrecvfromsend</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int select(int nfds, out fd_set readfds, out fd_set writefds, out fd_set exceptfds, TIMEVAL timeout);

        /// <summary>
        ///The send function sends data on a connected socket.
        /// </summary>
        /// <param name="s">A descriptor identifying a connected socket.</param>
        /// <param name="buf">A pointer to a buffer containing the data to be transmitted.</param>
        /// <param name="len">The length, in bytes, of the data in buffer pointed to by the buf parameter.</param>
        /// <param name="flags">A set of flags that specify the way in which the call is made. This parameter is constructed by using the bitwise OR operator with any of the following values.If no error occurs, send returns the total number of bytes sent, which can be less than the number requested to be sent in the len parameter. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.The send function is used to write outgoing data on a connected socket.For message-oriented sockets (address family of AF_INET or AF_INET6, type of SOCK_DGRAM, and protocol of IPPROTO_UDP, for example), care must be taken not to exceed the maximum packet size of the underlying provider. The maximum message packet size for a provider can be obtained by calling getsockopt with the optname parameter set to SO_MAX_MSG_SIZE to retrieve the value of socket option. If the data is too long to pass atomically through the underlying protocol, the error WSAEMSGSIZE is returned, and no data is transmitted.The successful completion of a send function does not indicate that the data was successfully delivered and received to the recipient. This function only indicates the data was successfully sent.If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode. On nonblocking stream oriented sockets, the number of bytes written can be between 1 and the requested length, depending on buffer availability on both the client and server computers. The select, WSAAsyncSelect or WSAEventSelect functions can be used to determine when it is possible to send more data.Calling send with a len parameter of zero is permissible and will be treated by implementations as successful. In such cases, send will return zero as a valid value. For message-oriented sockets, a zero-length transport datagram is sent.The flags parameter can be used to influence the behavior of the function beyond the options specified for the associated socket. The semantics of the send function are determined by any options previously set on the socket specified in the s parameter and the flags parameter passed to the send function.The order of calls made to send is also the order in which the buffers are transmitted to the transport layer. send should not be called on the same stream-oriented socket concurrently from different threads, because some Winsock providers may split a large send request into multiple transmissions, and this may lead to unintended data interleaving from multiple concurrent send requests on the same stream-oriented socket.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.Getting Started With WinsockWSAAsyncSelectWSAEventSelectWinsock FunctionsWinsock Referencerecvrecvfromselectsendtosocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int send(short s, char buf, int len, int flags);

        /// <summary>
        ///The sendto function sends data to a specific destination.
        /// </summary>
        /// <param name="s">A descriptor identifying a (possibly connected) socket.</param>
        /// <param name="buf">A pointer to a buffer containing the data to be transmitted.</param>
        /// <param name="len">The length, in bytes, of the data pointed to by the buf parameter.</param>
        /// <param name="flags">A set of flags that specify the way in which the call is made.</param>
        /// <param name="to">An optional pointer to a sockaddr structure that contains the address of the target socket.</param>
        /// <param name="tolen">The size, in bytes, of the address pointed to by the to parameter.If no error occurs, sendto returns the total number of bytes sent, which can be less than the number indicated by len. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.The sendto function is used to write outgoing data on a socket. For message-oriented sockets, care must be taken not to exceed the maximum packet size of the underlying subnets, which can be obtained by using getsockopt to retrieve the value of socket option SO_MAX_MSG_SIZE. If the data is too long to pass atomically through the underlying protocol, the error WSAEMSGSIZE is returned and no data is transmitted.The to parameter can be any valid address in the socket's address family, including a broadcast or any multicast address. To send to a broadcast address, an application must have used setsockopt with SO_BROADCAST enabled. Otherwise, sendto will fail with the error code WSAEACCES. For TCP/IP, an application can send to any multicast address (without becoming a group member).If the socket is not connected, the getsockname function can be used to determine the local port number associated with the socket but the IP address returned is set to the wildcard address for the given protocol (for example, INADDR_ANY or "0.0.0.0" for IPv4 and IN6ADDR_ANY_INIT or "::" for IPv6).The successful completion of a sendto does not indicate that the data was successfully delivered.The sendto function is normally used on a connectionless socket to send a datagram to a specific peer socket identified by the to parameter. Even if the connectionless socket has been previously connected to a specific address, the to parameter overrides the destination address for that particular datagram only. On a connection-oriented socket, the to and tolen parameters are ignored, making sendto equivalent to send.If the broadcast should be sent out only on a specific interface, then the address pointed to by the to parameter should contain the subnet broadcast address for the interface and the intended port. For example, an IPv4 network address of 192.168.1.0 with a subnet mask of 255.255.255.0 would use a subnet broadcast address of 192.168.1.255.It is generally inadvisable for a broadcast datagram to exceed the size at which fragmentation can occur, which implies that the data portion of the datagram (excluding headers) should not exceed 512 bytes.If no buffer space is available within the transport system to hold the data to be transmitted, sendto will block unless the socket has been placed in a nonblocking mode. On nonblocking, stream oriented sockets, the number of bytes written can be between 1 and the requested length, depending on buffer availability on both the client and server systems. The select, WSAAsyncSelect or WSAEventSelect function can be used to determine when it is possible to send more data.Calling sendto with a len of zero is permissible and will return zero as a valid value. For message-oriented sockets, a zero-length transport datagram is sent.The flags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. The semantics of this function are determined by the socket options and the flags parameter. The latter is constructed by using the bitwise OR operator with any of the following values.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAAsyncSelectWSAEventSelectWinsock FunctionsWinsock Referencerecvrecvfromselectsendsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int sendto(short s, char buf, int len, int flags, IN_ADDR to, int tolen);

        /// <summary>
        ///The setsockopt function sets a socket option.
        /// </summary>
        /// <param name="s">A descriptor that identifies a socket.</param>
        /// <param name="level">The level at which the option is defined (for example, SOL_SOCKET).</param>
        /// <param name="optname">The socket option for which the value is to be set (for example, SO_BROADCAST). The optname parameter must be a socket option defined within the specified level, or behavior is undefined.</param>
        /// <param name="optval">A pointer to the buffer in which the value for the requested option is specified.</param>
        /// <param name="optlen">The size, in bytes, of the buffer pointed to by the optval parameter.If no error occurs, setsockopt returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.The setsockopt function sets the current value for a socket option associated with a socket of any type, in any state. Although options can exist at multiple protocol levels, they are always present at the uppermost socket level. Options affect socket operations, such as whether expedited data (OOB data for example) is received in the normal data stream, and whether broadcast messages can be sent on the socket.The following tables list some of the common options supported by the setsockopt function. The Type column identifies the type of data addressed by optval parameter. The Description column provides some basic information about the socket option. For more complete lists of socket options and more detailed information (default values, for example), see the detailed topics under Socket Options.level = SOL_SOCKETFor more complete and detailed information about socket options for level = SOL_SOCKET, see SOL_SOCKET Socket Options.level = IPPROTO_TCPSee TCP_NODELAY in IPPROTO_TCP socket options. Also see that topic for more complete and detailed information about socket options for level = IPPROTO_TCP.level = NSPROTO_IPXFor more complete and detailed information about socket options for level = NSPROTO_IPX, see NSPROTO_IPX Socket Options.BSD options not supported for setsockopt are shown in the following table.When developing applications using Windows sockets for IrDA, note the following:The IRLMP_IAS_SET socket option enables the application to set a single attribute of a single class in the local IAS. The application specifies the class to set, the attribute, and attribute type. The application is expected to allocate a buffer of the necessary size for the passed parameters.IrDA provides an IAS database that stores IrDA-based information. Limited access to the IAS database is available through the Windows Sockets 2 interface, but such access is not normally used by applications, and exists primarily to support connections to non-Windows devices that are not compliant with the Windows Sockets 2 IrDA conventions.The following structure, IAS_SET, is used with the IRLMP_IAS_SET setsockopt option to manage the local IAS database:The following structure, IAS_QUERY, is used with the IRLMP_IAS_QUERY setsockopt option to query a peer's IAS database:Many SO_ level socket options are not meaningful to IrDA. Only SO_LINGER is specifically supported.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.IPPROTO_IP Socket OptionsIPPROTO_IPV6 Socket OptionsIPPROTO_RM Socket OptionsIPPROTO_TCP Socket OptionsIPPROTO_UDP Socket OptionsNSPROTO_IPX Socket OptionsSOL_APPLETALK Socket OptionsSOL_IRLMP Socket OptionsSOL_SOCKET Socket OptionsSocket OptionsWSAAsyncSelectWSAEventSelectWSAIoctlWinsock Functionsbindgetsockoptioctlsocketsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int setsockopt(short s, int level, int optname, char optval, int optlen);

        /// <summary>
        ///The shutdown function disables sends or receives on a socket.
        /// </summary>
        /// <param name="s">A descriptor identifying a socket.</param>
        /// <param name="how">A flag that describes what types of operation will no longer be allowed. Possible values for this flag are listed in the Winsock2.h header file.If no error occurs, shutdown returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.The shutdown function is used on all types of sockets to disable reception, transmission, or both.If the how parameter is SD_RECEIVE, subsequent calls to the recv function on the socket will be disallowed. This has no effect on the lower protocol layers. For TCP sockets, if there is still data queued on the socket waiting to be received, or data arrives subsequently, the connection is reset, since the data cannot be delivered to the user. For UDP sockets, incoming datagrams are accepted and queued. In no case will an ICMP error packet be generated.If the how parameter is SD_SEND, subsequent calls to the send function are disallowed. For TCP sockets, a FIN will be sent after all data is sent and acknowledged by the receiver.Setting how to SD_BOTH disables both sends and receives as described above.The shutdown function does not close the socket. Any resources attached to the socket will not be freed until closesocket is invoked.To assure that all data is sent and received on a connected socket before it is closed, an application should use shutdown to close connection before calling closesocket. One method to wait for notification that the remote end has sent all its data and initiated a graceful disconnect uses the WSAEventSelect function as follows :For more information, see the section on Graceful Shutdown, Linger Options, and Socket Closure.Once the shutdown function is called to disable send, receive, or both, there is no method to re-enable send or receive for the existing socket connection.An application should not rely on being able to reuse a socket after it has been shut down. In particular, a Windows Sockets provider is not required to support the use of connect on a socket that has been shut down.If an application wants to reuse a socket, then the DisconnectEx function should be called with the dwFlags parameter set to TF_REUSE_SOCKET to close a connection on a socket and prepare the socket handle to be reused. When the DisconnectEx request completes, the socket handle can be passed to the AcceptEx or ConnectEx function.If an application wants to reuse a socket, the TransmitFile or TransmitPackets functions can be called with the dwFlags parameter set with TF_DISCONNECT and TF_REUSE_SOCKET to disconnect after all the data has been queued for transmission and prepare the socket handle to be reused. When the TransmitFile request completes, the socket handle can be passed to the function call previously used to establish the connection, such as AcceptEx or ConnectEx. When the TransmitPackets function completes, the socket handle can be passed to the AcceptEx function.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.AcceptExConnectExDisconnectExTransmitFileTransmitPacketsWSAEventSelectWinsock FunctionsWinsock Referenceconnectsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int shutdown(short s, int how);

        /// <summary>
        ///The socket function creates a socket that is bound to a specific transport service provider.
        /// </summary>
        /// <param name="af">The address family specification. Possible values for the address family are defined in the Winsock2.h header file.On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly.The values currently supported are AF_INET or AF_INET6, which are the Internet address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants are identical (for example, AF_INET and PF_INET), so either constant can be used.The table below lists common values for address family although many other values are possible.</param>
        /// <param name="type">The type specification for the new socket.Possible values for the socket type are defined in the Winsock2.h header file.The following table lists the possible values for the type parameter supported for Windows Sockets 2:In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available transport protocol through the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for an address family and use this information when specifying this parameter. Socket type definitions in the Winsock2.h and Ws2def.h header files will be periodically updated as new socket types, address families, and protocols are defined.In Windows Sockets 1.1, the only possible socket types are SOCK_DGRAM and SOCK_STREAM.</param>
        /// <param name="protocol">The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type specified. Possible values for the protocol are defined in the Winsock2.h and Wsrm.h header files.On the Windows SDK released for Windows Vista and later, the organization of header files has changed and this parameter can be one of the values from the IPPROTO enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly.If a value of 0 is specified, the caller does not wish to specify a protocol and the service provider will choose the protocol to use.When the af parameter is AF_INET or AF_INET6 and the type is SOCK_RAW, the value specified for the protocol is set in the protocol field of the IPv6 or IPv4 packet header.The table below lists common values for the protocol although many other values are possible.If no error occurs, socket returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling WSAGetLastError.The socket function causes a socket descriptor and any related resources to be allocated and bound to a specific transport-service provider. Winsock will utilize the first available service provider that supports the requested combination of address family, socket type and protocol parameters. The socket that is created will have the overlapped attribute as a default. For Windows, the Microsoft-specific socket option, SO_OPENTYPE, defined in Mswsock.h can affect this default. See Microsoft-specific documentation for a detailed description of SO_OPENTYPE.Sockets without the overlapped attribute can be created by using WSASocket. All functions that allow overlapped operation (WSASend, WSARecv, WSASendTo, WSARecvFrom, and WSAIoctl) also support nonoverlapped usage on an overlapped socket if the values for parameters related to overlapped operation are NULL.When selecting a protocol and its supporting service provider this procedure will only choose a base protocol or a protocol chain, not a protocol layer by itself. Unchained protocol layers are not considered to have partial matches on type or af either. That is, they do not lead to an error code of WSAEAFNOSUPPORT or WSAEPROTONOSUPPORT if no suitable protocol is found.Connection-oriented sockets such as SOCK_STREAM provide full-duplex connections, and must be in a connected state before any data can be sent or received on it. A connection to another socket is created with a connect call. Once connected, data can be transferred using send and recv calls. When a session has been completed, a closesocket must be performed.The communications protocols used to implement a reliable, connection-oriented socket ensure that data is not lost or duplicated. If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, the connection is considered broken and subsequent calls will fail with the error code set to WSAETIMEDOUT.Connectionless, message-oriented sockets allow sending and receiving of datagrams to and from arbitrary peers using sendto and recvfrom. If such a socket is connected to a specific peer, datagrams can be sent to that peer using send and can be received only from this peer using recv.IPv6 and IPv4 operate differently when receiving a socket with a type of SOCK_RAW. The IPv4 receive packet includes the packet payload, the next upper-level header (for example, the IP header for a TCP or UDP packet), and the IPv4 packet header. The IPv6 receive packet includes the packet payload and the next upper-level header. The IPv6 receive packet never includes the IPv6 packet header.When the af parameter is AF_NETBIOS for NetBIOS over TCP/IP, the type parameter can be SOCK_DGRAM or SOCK_SEQPACKET. For the AF_NETBIOS address family, the protocol parameter is the LAN adapter number represented as a negative number.On Windows XP and later, the following command can be used to list the Windows Sockets catalog to determine the service providers installed and the address family, socket type, and protocols that are supported.netsh winsock show catalogSupport for sockets with type SOCK_RAW is not required, but service providers are encouraged to support raw sockets as practicable.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.IPPROTO_IP Socket OptionsIPPROTO_IPV6 Socket OptionsReliable Multicast ProgrammingWSASocketWinsock FunctionsWinsock Referenceacceptbindclosesocketconnectgetsocknamegetsockoptioctlsocketlistenrecvrecvfromselectsendsendtosetsockoptshutdown</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short socket(int af, int type, int protocol);

        /// <summary>
        ///This inline helper function is provided as a convenience to retrieve the events mask from an OVERLAPPED_ENTRY.
        /// </summary>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int SocketNotificationRetrieveEvents(OVERLAPPED_ENTRY notification);

        /// <summary>
        ///The WSAAccept function conditionally accepts a connection based on the return value of a condition function, provides quality of service flow specifications, and allows the transfer of connection data.
        /// </summary>
        /// <param name="s">A descriptor that identifies a socket that is listening for connections after a call to the listen function.</param>
        /// <param name="addr"></param>
        /// <param name="addrlen">An optional pointer to an integer that contains the length of the sockaddr structure pointed to by the addr parameter, in bytes.</param>
        /// <param name="lpfnCondition">The address of an optional, application-specified condition function that will make an accept/reject decision based on the caller information passed in as parameters, and optionally create or join a socket group by assigning an appropriate value to the result parameter g of this function. If this parameter is NULL, then no condition function is called.</param>
        /// <param name="dwCallbackData">Callback data passed back to the application-specified condition function as the value of the dwCallbackData parameter passed to the condition function. This parameter is only applicable if the lpfnCondition parameter is not NULL. This parameter is not interpreted by Windows Sockets.If no error occurs, WSAAccept returns a value of type SOCKET that is a descriptor for the accepted socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling WSAGetLastError.The integer referred to by addrlen initially contains the amount of space pointed to by addr. On return it will contain the actual length in bytes of the address returned.The WSAAccept function extracts the first connection on the queue of pending connections on socket s, and checks it against the condition function, provided the condition function is specified (that is, not NULL). If the condition function returns CF_ACCEPT, WSAAccept creates a new socket. The newly created socket has the same properties as socket s including asynchronous events registered with WSAAsyncSelect or with WSAEventSelect. If the condition function returns CF_REJECT, WSAAccept rejects the connection request. The condition function runs in the same thread as this function does, and should return as soon as possible. If the decision cannot be made immediately, the condition function should return CF_DEFER to indicate that no decision has been made, and no action about this connection request should be taken by the service provider. When the application is ready to take action on the connection request, it will invoke WSAAccept again and return either CF_ACCEPT or CF_REJECT as a return value from the condition function.A socket in default mode (blocking) will block until a connection is present when an application calls WSAAccept and no connections are pending on the queue.A socket in nonblocking mode (blocking) fails with the error WSAEWOULDBLOCK when an application calls WSAAccept and no connections are pending on the queue. After WSAAccept succeeds and returns a new socket handle, the accepted socket cannot be used to accept any more connections. The original socket remains open and listens for new connection requests.The addr parameter is a result parameter that is filled in with the address of the connecting entity, as known to the communications layer. The exact format of the addr parameter is determined by the address family in which the communication is occurring. The addrlen is a value-result parameter; it should initially contain the amount of space pointed to by addr. On return, it will contain the actual length (in bytes) of the address returned. This call is used with connection-oriented socket types such as SOCK_STREAM. If addr and/or addrlen are equal to NULL, then no information about the remote address of the accepted socket is returned. Otherwise, these two parameters will be filled in if the connection is successfully accepted.A prototype of the condition function is defined in the Winsock2.h header file as the LPCONDITIONPROC, as follows.The ConditionFunc is a placeholder for the application-specified callback function. The actual condition function must reside in a DLL or application module. It is exported in the module definition file.The lpCallerId parameter points to a WSABUF structure that contains the address of the connecting entity, where its len parameter is the length of the buffer in bytes, and its buf parameter is a pointer to the buffer. The lpCallerData is a value parameter that contains any user data. The information in these parameters is sent along with the connection request. If no caller identification or caller data is available, the corresponding parameters will be NULL. Many network protocols do not support connect-time caller data. Most conventional network protocols can be expected to support caller identifier information at connection-request time. The buf portion of the WSABUF pointed to by lpCallerId points to a sockaddr. The sockaddr structure is interpreted according to its address family (typically by casting the sockaddr to some type specific to the address family).The lpSQOS parameter references the FLOWSPEC structures for socket s specified by the caller, one for each direction, followed by any additional provider-specific parameters. The sending or receiving flow specification values will be ignored as appropriate for any unidirectional sockets. A NULL value indicates that there is no caller-supplied quality of service and that no negotiation is possible. A non-NULL lpSQOS pointer indicates that a quality of service negotiation is to occur or that the provider is prepared to accept the quality of service request without negotiation.The lpGQOS parameter is reserved, and should be NULL. (reserved for future use with socket groups) references the FLOWSPEC structure for the socket group the caller is to create, one for each direction, followed by any additional provider-specific parameters. A NULL value for lpGQOS indicates no caller-specified group quality of service. Quality of service information can be returned if negotiation is to occur.The lpCalleeId is a parameter that contains the local address of the connected entity. The buf portion of the WSABUF pointed to by lpCalleeId points to a sockaddr structure. The sockaddr structure is interpreted according to its address family (typically by casting the sockaddr to some type specific to the address family such as struct sockaddr_in).The lpCalleeData is a result parameter used by the condition function to supply user data back to the connecting entity. The lpCalleeData->len initially contains the length of the buffer allocated by the service provider and pointed to by lpCalleeData->buf. A value of zero means passing user data back to the caller is not supported. The condition function should copy up to lpCalleeData->len bytes of data into lpCalleeData->buf, and then update lpCalleeData->len to indicate the actual number of bytes transferred. If no user data is to be passed back to the caller, the condition function should set lpCalleeData->len to zero. The format of all address and user data is specific to the address family to which the socket belongs.The g parameter is assigned within the condition function to indicate any of the following actions:The dwCallbackData parameter value passed to the condition function is the value passed as the dwCallbackData parameter in the original WSAAccept call. This value is interpreted only by the Windows Socket version 2 client. This allows a client to pass some context information from the WSAAccept call site through to the condition function. This also provides the condition function with any additional information required to determine whether to accept the connection or not. A typical usage is to pass a (suitably cast) pointer to a data structure containing references to application-defined objects with which this socket is associated.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAAsyncSelectWSAConnectWSASocketWinsock FunctionsWinsock Referenceacceptbindconnectgetsockoptlistenselectsockaddrsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short WSAAccept(short s, out IN_ADDR addr, out int addrlen, ICONINFO lpfnCondition, uint dwCallbackData);

        /// <summary>
        ///The WSAAddressToString function converts all components of a sockaddr structure into a human-readable string representation of the address.
        /// </summary>
        /// <param name="lpsaAddress">A pointer to the sockaddr structure to translate into a string.</param>
        /// <param name="dwAddressLength">The length, in bytes, of the address in the sockaddr structure pointed to by the lpsaAddress parameter. The dwAddressLength parameter may vary in size with different protocols.</param>
        /// <param name="lpProtocolInfo"></param>
        /// <param name="lpszAddressString">A pointer to the buffer that receives the human-readable address string.</param>
        /// <param name="lpdwAddressStringLength">On input, this parameter specifies the length of the buffer pointed to by the lpszAddressString parameter. The length is represented in bytes for ANSI strings, and in WCHARs for Unicode strings. On output, this parameter returns the length of the string including the NULL terminator actually copied into the buffer pointed to by the lpszAddressString parameter. If the specified buffer is not large enough, the function fails with a specific error of WSAEFAULT and this parameter is updated with the required size.If no error occurs, WSAAddressToString returns a value of zero. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.The WSAAddressToString function provides a protocol-independent address-to-string translation. The WSAAddressToString function takes a socket address structure pointed to by the lpsaAddress parameter and returns a pointer to NULL-terminated string that represents the socket address in the lpszAddressString parameter. While the inet_ntoa function works only with IPv4 addresses, the WSAAddressToString function works with any socket address supported by a Winsock provider on the local computer including IPv6 addresses.If the lpsaAddress parameter points to an IPv4 socket address (the address family is AF_INET), then the address string returned in the buffer pointed to by the lpszAddressString parameter is in dotted-decimal notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.If the lpsaAddress parameter points to an IPv6 socket address (the address family is AF_INET6), then the address string returned in the buffer pointed to by the lpszAddressString parameter is in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers is replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address.If the length of the buffer pointed to by the lpszAddressString parameter is not large enough to receive the string representation of the socket address, WSAAddressToString returns WSAEFAULT.Support for IPv6 addresses using the WSAAddressToString function was added on Windows XP with Service Pack 1 (SP1)and later. IPv6 must also be installed on the local computer for the WSAAddressToString function to support IPv6 addresses.Windows Phone 8: The WSAAddressToStringW function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: The WSAAddressToStringW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.InetNtopInetPtonRtlIpv4AddressToStringRtlIpv4AddressToStringExRtlIpv4StringToAddressRtlIpv4StringToAddressExRtlIpv6AddressToStringRtlIpv6AddressToStringExRtlIpv6StringToAddressRtlIpv6StringToAddressExWSAPROTOCOL_INFOWSAStartupWSAStringToAddressinet_addrinet_ntoasockaddr</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAAddressToStringA(string lpsaAddress, uint dwAddressLength, WSAPROTOCOL_INFOA lpProtocolInfo, out string lpszAddressString, out uint lpdwAddressStringLength);

        /// <summary>
        ///The WSAAddressToString function converts all components of a sockaddr structure into a human-readable string representation of the address.
        /// </summary>
        /// <param name="lpsaAddress">A pointer to the sockaddr structure to translate into a string.</param>
        /// <param name="dwAddressLength">The length, in bytes, of the address in the sockaddr structure pointed to by the lpsaAddress parameter. The dwAddressLength parameter may vary in size with different protocols.</param>
        /// <param name="lpProtocolInfo"></param>
        /// <param name="lpszAddressString">A pointer to the buffer that receives the human-readable address string.</param>
        /// <param name="lpdwAddressStringLength">On input, this parameter specifies the length of the buffer pointed to by the lpszAddressString parameter. The length is represented in bytes for ANSI strings, and in WCHARs for Unicode strings. On output, this parameter returns the length of the string including the NULL terminator actually copied into the buffer pointed to by the lpszAddressString parameter. If the specified buffer is not large enough, the function fails with a specific error of WSAEFAULT and this parameter is updated with the required size.If no error occurs, WSAAddressToString returns a value of zero. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.The WSAAddressToString function provides a protocol-independent address-to-string translation. The WSAAddressToString function takes a socket address structure pointed to by the lpsaAddress parameter and returns a pointer to NULL-terminated string that represents the socket address in the lpszAddressString parameter. While the inet_ntoa function works only with IPv4 addresses, the WSAAddressToString function works with any socket address supported by a Winsock provider on the local computer including IPv6 addresses.If the lpsaAddress parameter points to an IPv4 socket address (the address family is AF_INET), then the address string returned in the buffer pointed to by the lpszAddressString parameter is in dotted-decimal notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.If the lpsaAddress parameter points to an IPv6 socket address (the address family is AF_INET6), then the address string returned in the buffer pointed to by the lpszAddressString parameter is in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers is replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address.If the length of the buffer pointed to by the lpszAddressString parameter is not large enough to receive the string representation of the socket address, WSAAddressToString returns WSAEFAULT.Support for IPv6 addresses using the WSAAddressToString function was added on Windows XP with Service Pack 1 (SP1)and later. IPv6 must also be installed on the local computer for the WSAAddressToString function to support IPv6 addresses.Windows Phone 8: The WSAAddressToStringW function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: The WSAAddressToStringW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.InetNtopInetPtonRtlIpv4AddressToStringRtlIpv4AddressToStringExRtlIpv4StringToAddressRtlIpv4StringToAddressExRtlIpv6AddressToStringRtlIpv6AddressToStringExRtlIpv6StringToAddressRtlIpv6StringToAddressExWSAPROTOCOL_INFOWSAStartupWSAStringToAddressinet_addrinet_ntoasockaddr</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAAddressToStringW(string lpsaAddress, uint dwAddressLength, WSAPROTOCOL_INFOW lpProtocolInfo, out string lpszAddressString, out uint lpdwAddressStringLength);

        /// <summary>
        ///The WSAAsyncGetHostByAddr function asynchronously retrieves host information that corresponds to an address.
        /// </summary>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint WSAAsyncGetHostByAddr(nint hWnd, char addr, char buf);

        /// <summary>
        ///The WSAAsyncGetHostByName function asynchronously retrieves host information that corresponds to a host name.
        /// </summary>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint WSAAsyncGetHostByName(nint hWnd, char name, char buf);

        /// <summary>
        ///The WSAAsyncGetProtoByName function asynchronously retrieves protocol information that corresponds to a protocol name.
        /// </summary>
        /// <param name="hWnd">Handle of the window that will receive a message when the asynchronous request completes.</param>
        /// <param name="wMsg">Message to be received when the asynchronous request completes.</param>
        /// <param name="name">Pointer to the null-terminated protocol name to be resolved.</param>
        /// <param name="buf"></param>
        /// <param name="buflen"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint WSAAsyncGetProtoByName(nint hWnd, uint wMsg, char name, out char buf, out int buflen);

        /// <summary>
        ///The WSAAsyncGetProtoByNumber function asynchronously retrieves protocol information that corresponds to a protocol number.
        /// </summary>
        /// <param name="hWnd">Handle of the window that will receive a message when the asynchronous request completes.</param>
        /// <param name="wMsg">Message to be received when the asynchronous request completes.</param>
        /// <param name="number">Protocol number to be resolved, in host byte order.</param>
        /// <param name="buf"></param>
        /// <param name="buflen">Size of data area for the buf parameter, in bytes.The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.If no error occurs, WSAAsyncGetProtoByNumber returns a nonzero value of type HANDLE that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by examining the wParam message parameter.If the asynchronous operation could not be initiated, WSAAsyncGetProtoByNumber returns a zero value, and a specific error number can be retrieved by calling WSAGetLastError.The following error codes can be set when an application window receives a message. As described above, they can be extracted from the lParam in the reply message using the WSAGETASYNCERROR macro.The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.The WSAAsyncGetProtoByNumber function is an asynchronous version of getprotobynumber, and is used to retrieve the protocol name and number corresponding to a protocol number. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation.On successful completion, the buffer specified to the original function call contains a protoent structure. To access the members of this structure, the original buffer address is cast to a protoent structure pointer and accessed as appropriate.If the error code is WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the WSAAsyncGetProtoByNumber function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of lParam).The buffer specified to this function is used by Windows Sockets to construct a protoent structure together with the contents of data areas referenced by members of the same protoent structure. To avoid the WSAENOBUFS error noted above, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).The error code and buffer length should be extracted from the lParam using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in Winsock2.h as:The use of these macros will maximize the portability of the source code for the application.WSACancelAsyncRequestWinsock FunctionsWinsock Referencegetprotobynumber</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint WSAAsyncGetProtoByNumber(nint hWnd, uint wMsg, int number, out char buf, int buflen);

        /// <summary>
        ///The WSAAsyncGetServByName function asynchronously retrieves service information that corresponds to a service name and port.
        /// </summary>
        /// <param name="hWnd">Handle of the window that should receive a message when the asynchronous request completes.</param>
        /// <param name="wMsg">Message to be received when the asynchronous request completes.</param>
        /// <param name="name">Pointer to a null-terminated service name.</param>
        /// <param name="proto">Pointer to a protocol name. This can be NULL, in which case WSAAsyncGetServByName will search for the first service entry for which s_name or one of the s_aliases matches the given name. Otherwise, WSAAsyncGetServByName matches both name and proto.</param>
        /// <param name="buf"></param>
        /// <param name="buflen">Size of data area for the buf parameter, in bytes.The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.If no error occurs, WSAAsyncGetServByName returns a nonzero value of type HANDLE that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by examining the wParam message parameter.If the asynchronous operation could not be initiated, WSAAsyncServByName returns a zero value, and a specific error number can be retrieved by calling WSAGetLastError.The following error codes can be set when an application window receives a message. As described above, they can be extracted from the lParam in the reply message using the WSAGETASYNCERROR macro.The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.The WSAAsyncGetServByName function is an asynchronous version of getservbyname and is used to retrieve service information corresponding to a service name. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation.On successful completion, the buffer specified to the original function call contains a servent structure. To access the members of this structure, the original buffer address should be cast to a servent structure pointer and accessed as appropriate.If the error code is WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the WSAAsyncGetServByName function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of lParam).The buffer specified to this function is used by Windows Sockets to construct a servent structure together with the contents of data areas referenced by members of the same servent structure. To avoid the WSAENOBUFS error, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).The error code and buffer length should be extracted from the lParam using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in Winsock2.h as:The use of these macros will maximize the portability of the source code for the application.WSACancelAsyncRequestWinsock FunctionsWinsock Referencegetservbyname</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint WSAAsyncGetServByName(nint hWnd, uint wMsg, char name, char proto, out char buf, int buflen);

        /// <summary>
        ///The WSAAsyncGetServByPort function asynchronously retrieves service information that corresponds to a port and protocol.
        /// </summary>
        /// <param name="hWnd">Handle of the window that should receive a message when the asynchronous request completes.</param>
        /// <param name="wMsg">Message to be received when the asynchronous request completes.</param>
        /// <param name="port">Port for the service, in network byte order.</param>
        /// <param name="proto">Pointer to a protocol name. This can be NULL, in which case WSAAsyncGetServByPort will search for the first service entry for which s_port match the given port. Otherwise, WSAAsyncGetServByPort matches both port and proto.</param>
        /// <param name="buf"></param>
        /// <param name="buflen">Size of data area for the buf parameter, in bytes.The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.If no error occurs, WSAAsyncGetServByPort returns a nonzero value of type HANDLE that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by examining the wParam message parameter.If the asynchronous operation could not be initiated, WSAAsyncGetServByPort returns a zero value, and a specific error number can be retrieved by calling WSAGetLastError.The following error codes can be set when an application window receives a message. As described above, they can be extracted from the lParam in the reply message using the WSAGETASYNCERROR macro.The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.The WSAAsyncGetServByPort function is an asynchronous version of getservbyport, and is used to retrieve service information corresponding to a port number. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation.On successful completion, the buffer specified to the original function call contains a servent structure. To access the members of this structure, the original buffer address should be cast to a servent structure pointer and accessed as appropriate.If the error code is WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the WSAAsyncGetServByPort function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of lParam).The buffer specified to this function is used by Windows Sockets to construct a servent structure together with the contents of data areas referenced by members of the same servent structure. To avoid the WSAENOBUFS error, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).The error code and buffer length should be extracted from the lParam using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in Winsock2.h as:The use of these macros will maximize the portability of the source code for the application.WSACancelAsyncRequestWinsock FunctionsWinsock Referencegetservbyport</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint WSAAsyncGetServByPort(nint hWnd, uint wMsg, int port, char proto, out char buf, int buflen);

        /// <summary>
        ///[The WSAAsyncSelect function is available for use in the operating systems specified in the Requirements section. It may be altered or unavailable in subsequent versions. Rather than use Select-style I/O, use Overlapped I/O and Event Objects with WinSock2.]
        /// </summary>
        /// <param name="s">A descriptor that identifies the socket for which event notification is required.</param>
        /// <param name="hWnd">A handle that identifies the window that will receive a message when a network event occurs.</param>
        /// <param name="wMsg">A message to be received when a network event occurs.</param>
        /// <param name="lEvent">A bitmask that specifies a combination of network events in which the application is interested.If the WSAAsyncSelect function succeeds, the return value is zero, provided that the application's declaration of interest in the network event set was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.Additional error codes can be set when an application window receives a message. This error code is extracted from the lParam in the reply message using the WSAGETSELECTERROR macro. Possible error codes for each network event are listed in the following table.Event: FD_CONNECTEvent: FD_CLOSEEvent: FD_ROUTING_INTERFACE_CHANGEThe WSAAsyncSelect function is used to request that WS2_32.DLL should send a message to the window hWnd when it detects any network event specified by the lEvent parameter. The message that should be sent is specified by the wMsg parameter. The socket for which notification is required is identified by the s parameter.The WSAAsyncSelect function automatically sets socket s to nonblocking mode, regardless of the value of lEvent. To set socket s back to blocking mode, it is first necessary to clear the event record associated with socket s via a call to WSAAsyncSelect with lEvent set to zero. You can then call ioctlsocket or WSAIoctl to set the socket back to blocking mode. For more information about how to set the nonblocking socket back to blocking mode, see the ioctlsocket and WSAIoctl functions.The lEvent parameter is constructed by using the bitwise OR operator with any value listed in the following table.Issuing a WSAAsyncSelect for a socket cancels any previous WSAAsyncSelect or WSAEventSelect for the same socket. For example, to receive notification for both reading and writing, the application must call WSAAsyncSelect with both FD_READ and FD_WRITE, as follows:It is not possible to specify different messages for different events. The following code will not work; the second call will cancel the effects of the first, and only FD_WRITE events will be reported with message wMsg2:To cancel all notification indicating that Windows Sockets should send no further messages related to network events on the socket, lEvent is set to zero.Although WSAAsyncSelect immediately disables event message posting for the socket in this instance, it is possible that messages could be waiting in the application message queue. Therefore, the application must be prepared to receive network event messages even after cancellation. Closing a socket with closesocket also cancels WSAAsyncSelect message sending, but the same caveat about messages in the queue still applies.The socket created by the accept function has the same properties as the listening socket used to accept it. Consequently, WSAAsyncSelect events set for the listening socket also apply to the accepted socket. For example, if a listening socket has WSAAsyncSelect events FD_ACCEPT, FD_READ, and FD_WRITE, then any socket accepted on that listening socket will also have FD_ACCEPT, FD_READ, and FD_WRITE events with the same wMsg value used for messages. If a different wMsg or events are desired, the application should call WSAAsyncSelect, passing the accepted socket and the desired new data.When one of the nominated network events occurs on the specified socket s, the application window hWnd receives message wMsg. The wParam parameter identifies the socket on which a network event has occurred. The low word of lParam specifies the network event that has occurred. The high word of lParam contains any error code. The error code be any error as defined in Winsock2.h.The use of these macros will maximize the portability of the source code for the application.The possible network event codes that can be returned are listed in the following table.Although WSAAsyncSelect can be called with interest in multiple events, the application window will receive a single message for each network event.As in the case of the select function, WSAAsyncSelect will frequently be used to determine when a data transfer operation (send or recv) can be issued with the expectation of immediate success. Nevertheless, a robust application must be prepared for the possibility that it can receive a message and issue a Windows Sockets 2 call that returns WSAEWOULDBLOCK immediately. For example, the following sequence of events is possible:The WS2_32.DLL will not continually flood an application with messages for a particular network event. Having successfully posted notification of a particular event to an application window, no further message(s) for that network event will be posted to the application window until the application makes the function call that implicitly reenables notification of that network event.Any call to the reenabling routine, even one that fails, results in reenabling of message posting for the relevant event.For FD_READ, FD_OOB, and FD_ACCEPT events, message posting is level-triggered. This means that if the reenabling routine is called and the relevant condition is still met after the call, a WSAAsyncSelect message is posted to the application. This allows an application to be event-driven and not be concerned with the amount of data that arrives at any one time. Consider the following sequence:The FD_QOS and FD_GROUP_QOS events are considered edge triggered. A message will be posted exactly once when a quality of service change occurs. Further messages will not be forthcoming until either the provider detects a further change in quality of service or the application renegotiates the quality of service for the socket.The FD_ROUTING_INTERFACE_CHANGE message is posted when the local interface that should be used to reach the destination specified in WSAIoctl with SIO_ROUTING_INTERFACE_CHANGE changes after such IOCTL has been issued.The FD_ADDRESS_LIST_CHANGE message is posted when the list of addresses to which the application can bind changes after WSAIoctl with SIO_ADDRESS_LIST_CHANGE has been issued.If any event has occurred when the application calls WSAAsyncSelect or when the reenabling function is called, then a message is posted as appropriate. For example, consider the following sequence:The FD_OOB event is used only when a socket is configured to receive OOB data separately. If the socket is configured to receive OOB data inline, the OOB (expedited) data is treated as normal data and the application should register an interest in, and will receive, FD_READ events, not FD_OOB events. An application can set or inspect the way in which OOB data is to be handled by using setsockopt or getsockopt for the SO_OOBINLINE option.The error code in an FD_CLOSE message indicates whether the socket close was graceful or abortive. If the error code is zero, then the close was graceful; if the error code is WSAECONNRESET, then the socket's virtual circuit was reset. This only applies to connection-oriented sockets such as SOCK_STREAM.The FD_CLOSE message is posted when a close indication is received for the virtual circuit corresponding to the socket. In TCP terms, this means that the FD_CLOSE is posted when the connection goes into the TIME WAIT or CLOSE WAIT states. This results from the remote end performing a shutdown on the send side or a closesocket. FD_CLOSE should only be posted after all data is read from a socket, but an application should check for remaining data upon receipt of FD_CLOSE to avoid any possibility of losing data.Be aware that the application will only receive an FD_CLOSE message to indicate closure of a virtual circuit, and only when all the received data has been read if this is a graceful close. It will not receive an FD_READ message to indicate this condition.The FD_QOS or FD_GROUP_QOS message is posted when any parameter in the flow specification associated with socket s or the socket group that s belongs to has changed, respectively. Applications should use WSAIoctl with command SIO_GET_QOS or SIO_GET_GROUP_QOS to get the current quality of service for socket s or for the socket group s belongs to, respectively.The FD_ROUTING_INTERFACE_CHANGE and FD_ADDRESS_LIST_CHANGE events are considered edge triggered as well. A message will be posted exactly once when a change occurs after the application has requested the notification by issuing WSAIoctl with SIO_ROUTING_INTERFACE_CHANGE or SIO_ADDRESS_LIST_CHANGE correspondingly. Further messages will not be forthcoming until the application reissues the IOCTL and another change is detected because the IOCTL has been issued.Here is a summary of events and conditions for each asynchronous notification message.WSAEventSelectWinsock FunctionsWinsock Referenceselect</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAAsyncSelect(short s, nint hWnd, uint wMsg, int lEvent);

        /// <summary>
        ///The WSACancelAsyncRequest function cancels an incomplete asynchronous operation.
        /// </summary>
        /// <param name="hAsyncTaskHandle">Handle that specifies the asynchronous operation to be canceled.The value returned by WSACancelAsyncRequest is zero if the operation was successfully canceled. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.The WSACancelAsyncRequest function is used to cancel an asynchronous operation that was initiated by one of the WSAAsyncGetXByY functions such as WSAAsyncGetHostByName. The operation to be canceled is identified by the hAsyncTaskHandle parameter, which should be set to the asynchronous task handle as returned by the initiating WSAAsyncGetXByY function.An attempt to cancel an existing asynchronous WSAAsyncGetXByY operation can fail with an error code of WSAEALREADY for two reasons. First, the original operation has already completed and the application has dealt with the resultant message. Second, the original operation has already completed but the resultant message is still waiting in the application window queue.WSAAsyncGetHostByAddrWSAAsyncGetHostByNameWSAAsyncGetProtoByNameWSAAsyncGetProtoByNumberWSAAsyncGetServByNameWSAAsyncGetServByPortWinsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSACancelAsyncRequest(nint hAsyncTaskHandle);

        /// <summary>
        ///The WSACancelBlockingCall function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0.
        /// </summary>

        [DllImport("req.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSACancelBlockingCall();

        /// <summary>
        ///The WSACleanup function terminates use of the Winsock 2 DLL (Ws2_32.dll).
        /// </summary>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSACleanup();

        /// <summary>
        ///The WSACloseEvent function closes an open event object handle.
        /// </summary>
        /// <param name="hEvent">Object handle identifying the open event.If the function succeeds, the return value is TRUE.If the function fails, the return value is FALSE. To get extended error information, call WSAGetLastError.The WSACloseEvent function closes the handle to an event object and frees resources associated with the event object. This function is used to close a handle created by the WSACreateEvent function. Once the handle to the event object is closed, further references to this handle will fail with the error WSA_INVALID_HANDLE.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSACreateEventWSAEnumNetworkEventsWSAEventSelectWSAGetOverlappedResultWSARecvWSARecvFromWSAResetEventWSASendWSASendToWSASetEventWSAWaitForMultipleEventsWinsock FunctionsWinsock Reference</param>
        /// <remarks>
        /// To get extended error information, call WSAGetLastError.
        /// </remarks>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool WSACloseEvent(SERVENT hEvent);

        /// <summary>
        ///The WSAConnect function establishes a connection to another socket application, exchanges connect data, and specifies required quality of service based on the specified FLOWSPEC structure.
        /// </summary>
        /// <param name="s">A descriptor identifying an unconnected socket.</param>
        /// <param name="name">A pointer to a sockaddr structure that specifies the address to which to connect. For IPv4, the sockaddr contains AF_INET for the address family, the destination IPv4 address, and the destination port. For IPv6, the sockaddr structure contains AF_INET6 for the address family, the destination IPv6 address, the destination port, and may contain additional flow and scope-id information.</param>
        /// <param name="namelen">The length, in bytes, of the sockaddr structure pointed to by the name parameter.</param>
        /// <param name="lpCallerData">A pointer to the user data that is to be transferred to the other socket during connection establishment. See Remarks.</param>
        /// <param name="lpCalleeData"></param>
        /// <param name="lpSQOS">A pointer to the FLOWSPEC structures for socket s, one for each direction.</param>
        /// <param name="lpGQOS">Reserved for future use with socket groups. A pointer to the FLOWSPEC structures for the socket group (if applicable). This parameter should be NULL.If no error occurs, WSAConnect returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved by calling WSAGetLastError. On a blocking socket, the return value indicates success or failure of the connection attempt.With a nonblocking socket, the connection attempt cannot be completed immediately. In this case, WSAConnect will return SOCKET_ERROR, and WSAGetLastError will return WSAEWOULDBLOCK; the application could therefore:If the return error code indicates the connection attempt failed (that is, WSAECONNREFUSED, WSAENETUNREACH, WSAETIMEDOUT) the application can call WSAConnect again for the same socket.The WSAConnect function is used to create a connection to the specified destination, and to perform a number of other ancillary operations that occur at connect time. If the socket, s, is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound.For applications targeted to Windows Vista and later, consider using the WSAConnectByList or WSAConnectByName function which greatly simplify client application design.For connection-oriented sockets (for example, type SOCK_STREAM), an active connection is initiated to the foreign host using name (an address in the namespace of the socket; for a detailed description, please see bind). When this call completes successfully, the socket is ready to send/receive data. If the address parameter of the name structure is all zeroes, WSAConnect will return the error WSAEADDRNOTAVAIL. Any attempt to reconnect an active connection will fail with the error code WSAEISCONN.For a connectionless socket (for example, type SOCK_DGRAM), the operation performed by WSAConnect is merely to establish a default destination address so that the socket can be used on subsequent connection-oriented send and receive operations (send, WSASend, recv, and WSARecv). Any datagrams received from an address other than the destination address specified will be discarded. If the entire name structure is all zeros (not just the address parameter of the name structure), then the socket will be disconnected. Then, the default remote address will be indeterminate, so send, WSASend, recv, and WSARecv calls will return the error code WSAENOTCONN. However, sendto, WSASendTo, recvfrom, and WSARecvFrom can still be used. The default destination can be changed by simply calling WSAConnect again, even if the socket is already connected. Any datagrams queued for receipt are discarded if name is different from the previous WSAConnect.For connectionless sockets, name can indicate any valid address, including a broadcast address. However, to connect to a broadcast address, a socket must have setsockopt SO_BROADCAST enabled. Otherwise, WSAConnect will fail with the error code WSAEACCES.On connectionless sockets, exchange of user-to-user data is not possible and the corresponding parameters will be silently ignored.The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specifies.The lpCallerData parameter contains a pointer to any user data that is to be sent along with the connection request (called connect data). This is additional data, not in the normal network data stream, that is sent with network requests to establish a connection. This option is used by legacy protocols such as DECNet, OSI TP4, and others.If lpCallerData is NULL, no user data will be passed to the peer. The lpCalleeData is a result parameter that will contain any user data passed back from the other socket as part of the connection establishment in a WSABUF structure. The len member of the WSABUF structure pointed to by the lpCalleeData parameter initially contains the length of the buffer allocated by the application for the buf member of the WSABUF structure. The len member of the WSABUF structure pointed to by the lpCalleeData parameter will be set to zero if no user data has been passed back. The lpCalleeData information will be valid when the connection operation is complete. For blocking sockets, the connection operation completes when the WSAConnect function returns. For nonblocking sockets, completion will be after the FD_CONNECT notification has occurred. If lpCalleeData is NULL, no user data will be passed back. The exact format of the user data is specific to the address family to which the socket belongs.At connect time, an application can use the lpSQOS and lpGQOS parameter to override any previous quality of service specification made for the socket through WSAIoctl with either the SIO_SET_QOS or SIO_SET_GROUP_QOS opcode.The lpSQOS parameter specifies the FLOWSPEC structures for socket s, one for each direction, followed by any additional provider-specific parameters. If either the associated transport provider in general or the specific type of socket in particular cannot honor the quality of service request, an error will be returned as indicated in the following. The sending or receiving flow specification values will be ignored, respectively, for any unidirectional sockets. If no provider-specific parameters are specified, the buf and len members of the WSABUF structure pointed to by the lpCalleeData parameter should be set to NULL and zero, respectively. A NULL value for lpSQOS parameter indicates no application-supplied quality of service.Reserved for future use with socket groups lpGQOS specifies the FLOWSPEC structures for the socket group (if applicable), one for each direction, followed by any additional provider-specific parameters. If no provider-specific parameters are specified, the buf and len members of the WSABUF structure pointed to by the lpCalleeData parameter should be set to NULL and zero, respectively. A NULL value for lpGQOS indicates no application-supplied group quality of service. This parameter will be ignored if s is not the creator of the socket group.When connected sockets become closed for whatever reason, they should be discarded and recreated. It is safest to assume that when things go awry for any reason on a connected socket, the application must discard and recreate the needed sockets in order to return to a stable point.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAAsyncSelectWSABUFWSAConnectConnectExWSAConnectByListWSAEventSelectWinsock FunctionsWinsock Referenceacceptbindconnectgetsocknamegetsockoptselectsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAConnect(short s, IN_ADDR name, int namelen, string lpCallerData, out string lpCalleeData, QOS lpSQOS, QOS lpGQOS);

        /// <summary>
        ///The WSAConnectByList function establishes a connection to one out of a collection of possible endpoints represented by a set of destination addresses (host names and ports). This function takes all the destination addresses passed to it and all of the local computer's source addresses, and tries connecting using all possible address combinations before giving up.
        /// </summary>
        /// <param name="s">A descriptor that identifies an unbound and unconnected socket. Note that unlike other Winsock calls to establish a connection (for example, WSAConnect), the WSAConnectByList function requires an unbound socket.</param>
        /// <param name="SocketAddress">A pointer to a SOCKET_ADDRESS_LIST structure that represents the possible destination address and port pairs to connect to a peer. It is the application's responsibility to fill in the port number in the each SOCKET_ADDRESS structure in the SOCKET_ADDRESS_LIST.</param>
        /// <param name="LocalAddressLength">On input, a pointer to the size, in bytes, of the LocalAddress buffer provided by the caller. On output, a pointer to the size, in bytes, of the SOCKADDR for the local address stored in the LocalAddress buffer filled in by the system upon successful completion of the call.</param>
        /// <param name="LocalAddress"></param>
        /// <param name="RemoteAddressLength">On input, a pointer to the size, in bytes, of the RemoteAddress buffer provided by the caller. On output, a pointer to the size, in bytes, of the SOCKADDR for the remote address stored in RemoteAddress buffer filled-in by the system upon successful completion of the call.</param>
        /// <param name="RemoteAddress"></param>
        /// <param name="timeout">The time, in milliseconds, to wait for a response from the remote application before aborting the call. This parameter can be NULL in which case WSAConnectByList will complete after either the connection is successfully established or after a connection was attempted and failed on all possible local-remote address pairs.</param>
        /// <param name="Reserved">Reserved for future implementation. This parameter must be set to NULL.If a connection is established, WSAConnectByList returns TRUE and LocalAddress and RemoteAddress parameters are filled in if these buffers were supplied by the caller.If the call fails, FALSE is returned. WSAGetLastError can then be called to get extended error information.WSAConnectByList is similar to the WSAConnectByName function. Instead of taking a single host name and service name (port), WSAConnectByList takes a list of addresses (host addresses and ports) and connects to one of the addresses. The WSAConnectByList function is designed to support peer-to-peer collaboration scenarios where an application needs to connect to any available node out of a list of potential nodes. WSAConnectByList is compatible with both IPv6 and IPv4 versions.The set of possible destinations, represented by a list of addresses, is provided by the caller. WSAConnectByList does more than simply attempt to connect to one of possibly many destination addresses. Specifically, the function takes all remote addresses passed in by the caller, all local addresses, and then attempts a connection first using address pairs with the highest chance of success. As such, WSAConnectByList not only ensures that connection will be established if a connection is at all possible, but also minimizes the time to establish the connection.The caller can specify the LocalAddress and RemoteAddress buffers and lengths to determine the local and remote addresses for which the connection was successfully established.The timeout parameter allows the caller to limit the time spent by the function in establishing a connection. Internally, WSAConnectByList performs multiple operations (connection attempts). In between each operation, the timeout parameter is checked to see if the timeout has been exceeded and, if so, the call is aborted. Note that an individual operation (connect) will not be interrupted once the timeout is exceeded, so the WSAConnectByList call can take longer to time out than the value specified in the timeout parameter.WSAConnectByList has limitations: It works only for connection-oriented sockets, such as those of type SOCK_STREAM. The function does not support overlapped I/O or non-blocking behavior. WSAConnectByList will block even if the socket is in non-blocking mode. WSAConnectByList will try connecting (one-by-one) to the various addresses provided by the caller. Potentially, each of these connection attempts may fail with a different error code. Since only a single error code can be returned, the value returned is the error code from the last connection attempt.To enable both IPv6 and IPv4 addresses to be passed in the single address list accepted by the function, the following steps must be performed prior to calling the function:The arrays of pointers passed in the SocketAddressList parameter point to an array of SOCKET_ADDRESS structures, which are a generic data type. The RemoteAddress and the LocalAddress parameters also point to SOCKADDR structures. When WSAConnectByList is called, it is expected that a socket address type specific to the network protocol or address family being used will actually be passed in these parameters. So for IPv4 addresses, a pointer to a sockaddr_in structure would be cast to a pointer to SOCKADDR when passed as a parameter. For IPv6 addresses, a pointer to a sockaddr_in6 structure would be cast to a pointer to SOCKADDR when passed as a parameter. The SocketAddressList parameter can contain pointers to a mixture of IPv4 and IPv6 addresses. So some SOCKET_ADDRESS pointers can be to sockaddr_in structures and others can be to sockaddr_in6 structures. If it is expected that IPv6 addresses can be used, then the RemoteAddress and LocalAddress parameters should point to sockaddr_in6 structures and be cast to SOCKADDR structures. The RemoteAddressLength and the LocalAddressLength parameters must represent the length of these larger structures.When the WSAConnectByList function returns TRUE, the socket s is in the default state for a connected socket. The socket s does not enable previously set properties or options until SO_UPDATE_CONNECT_CONTEXT is set on the socket. Use the setsockopt function to set the SO_UPDATE_CONNECT_CONTEXT option.For example:Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.Establish a connection using WSAConnectByList.IPPROTO_IPV6 Socket OptionsSOCKADDRSOCKET_ADDRESSSOCKET_ADDRESS_LISTWSAConnectWSAConnectByNameWSAGetLastErrorgetaddrinfogetpeernamegetsocknamesetsockopt</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool WSAConnectByList(short s, SOCKADDR_IRDA SocketAddress, out uint LocalAddressLength, out string LocalAddress, out uint RemoteAddressLength, out string RemoteAddress, TIMEVAL timeout, WSAOVERLAPPED Reserved);

        /// <summary>
        ///The WSAConnectByName function establishes a connection to a specified host and port. This function is provided to allow a quick connection to a network endpoint given a host name and port.
        /// </summary>
        /// <param name="s">A descriptor that identifies an unconnected socket.</param>
        /// <param name="nodename">A NULL-terminated string that contains the name of the host or the IP address of the host on which to connect for IPv4 or IPv6.</param>
        /// <param name="servicename">A NULL-terminated string that contains the service name or destination port of the host on which to connect for IPv4 or IPv6.A service name is a string alias for a port number. For example, “http” is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the servicename parameter when a port number is not specified are listed in the following file:%WINDIR%\system32\drivers\etc\services</param>
        /// <param name="LocalAddressLength">On input, a pointer to the size, in bytes, of the LocalAddress buffer provided by the caller. On output, a pointer to the size, in bytes, of the SOCKADDR for the local address stored in the LocalAddress buffer filled in by the system upon successful completion of the call.</param>
        /// <param name="LocalAddress"></param>
        /// <param name="RemoteAddressLength">On input, a pointer to the size, in bytes, of the RemoteAddress buffer provided by the caller. On output, a pointer to the size, in bytes, of the SOCKADDR for the remote address stored in RemoteAddress buffer filled-in by the system upon successful completion of the call.</param>
        /// <param name="RemoteAddress"></param>
        /// <param name="timeout">The time, in milliseconds, to wait for a response from the remote application before aborting the call.ReservedReserved for future implementation. This parameter must be set to NULL.If a connection is established, WSAConnectByName returns TRUE and LocalAddress and RemoteAddress parameters are filled in if these buffers were supplied by the caller.If the call fails, FALSE is returned. WSAGetLastError can then be called to get extended error information.WSAConnectByName is provided to enable quick and transparent connections to remote hosts on specific ports. It is compatible with both IPv6 and IPv4 versions.To enable both IPv6 and IPv4 communications, use the following method:WSAConnectByName has limitations: It works only for connection-oriented sockets, such as those of type SOCK_STREAM. The function does not support overlapped I/O or non-blocking behavior. WSAConnectByName will block even if the socket is in non-blocking mode.WSAConnectByName does not support user-provided data during the establishment of a connection. This call does not support FLOWSPEC structures, either. In cases where these features are required, WSAConnect must be used instead.In versions before Windows 10, if an application needs to bind to a specific local address or port, then WSAConnectByName cannot be used since the socket parameter to WSAConnectByName must be an unbound socket.This restriction was removed Windows 10.The RemoteAddress and the LocalAddress parameters point to a SOCKADDR structure, which is a generic data type. When WSAConnectByName is called, it is expected that a socket address type specific to the network protocol or address family being used will actually be passed in these parameters. So for IPv4 addresses, a pointer to a sockaddr_in structure would be cast to a pointer to SOCKADDR as the RemoteAddress and LocalAddress parameters. For IPv6 addresses, a pointer to a sockaddr_in6 structure would be cast to a pointer to SOCKADDR as the RemoteAddress and LocalAddress parameters.When the WSAConnectByName function returns TRUE, the socket s is in the default state for a connected socket. The socket s does not enable previously set properties or options until SO_UPDATE_CONNECT_CONTEXT is set on the socket. Use the setsockopt function to set the SO_UPDATE_CONNECT_CONTEXT option.For example:Windows 8.1 and Windows Server 2012 R2: The WSAConnectByNameW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.Establish a connection using WSAConnectByName.IPPROTO_IPV6 Socket OptionsSOCKADDRWSAConnectWSAConnectByListWSAGetLastErrorgetaddrinfogetpeernamegetsocknamesetsockopt</param>
        /// <param name="Reserved"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool WSAConnectByNameA(short s, string nodename, string servicename, out uint LocalAddressLength, out string LocalAddress, out uint RemoteAddressLength, out string RemoteAddress, TIMEVAL timeout, WSAOVERLAPPED Reserved);

        /// <summary>
        ///The WSAConnectByName function establishes a connection to a specified host and port. This function is provided to allow a quick connection to a network endpoint given a host name and port.
        /// </summary>
        /// <param name="s">A descriptor that identifies an unconnected socket.</param>
        /// <param name="nodename">A NULL-terminated string that contains the name of the host or the IP address of the host on which to connect for IPv4 or IPv6.</param>
        /// <param name="servicename">A NULL-terminated string that contains the service name or destination port of the host on which to connect for IPv4 or IPv6.A service name is a string alias for a port number. For example, “http” is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the servicename parameter when a port number is not specified are listed in the following file:%WINDIR%\system32\drivers\etc\services</param>
        /// <param name="LocalAddressLength">On input, a pointer to the size, in bytes, of the LocalAddress buffer provided by the caller. On output, a pointer to the size, in bytes, of the SOCKADDR for the local address stored in the LocalAddress buffer filled in by the system upon successful completion of the call.</param>
        /// <param name="LocalAddress"></param>
        /// <param name="RemoteAddressLength">On input, a pointer to the size, in bytes, of the RemoteAddress buffer provided by the caller. On output, a pointer to the size, in bytes, of the SOCKADDR for the remote address stored in RemoteAddress buffer filled-in by the system upon successful completion of the call.</param>
        /// <param name="RemoteAddress"></param>
        /// <param name="timeout">The time, in milliseconds, to wait for a response from the remote application before aborting the call.ReservedReserved for future implementation. This parameter must be set to NULL.If a connection is established, WSAConnectByName returns TRUE and LocalAddress and RemoteAddress parameters are filled in if these buffers were supplied by the caller.If the call fails, FALSE is returned. WSAGetLastError can then be called to get extended error information.WSAConnectByName is provided to enable quick and transparent connections to remote hosts on specific ports. It is compatible with both IPv6 and IPv4 versions.To enable both IPv6 and IPv4 communications, use the following method:WSAConnectByName has limitations: It works only for connection-oriented sockets, such as those of type SOCK_STREAM. The function does not support overlapped I/O or non-blocking behavior. WSAConnectByName will block even if the socket is in non-blocking mode.WSAConnectByName does not support user-provided data during the establishment of a connection. This call does not support FLOWSPEC structures, either. In cases where these features are required, WSAConnect must be used instead.In versions before Windows 10, if an application needs to bind to a specific local address or port, then WSAConnectByName cannot be used since the socket parameter to WSAConnectByName must be an unbound socket.This restriction was removed Windows 10.The RemoteAddress and the LocalAddress parameters point to a SOCKADDR structure, which is a generic data type. When WSAConnectByName is called, it is expected that a socket address type specific to the network protocol or address family being used will actually be passed in these parameters. So for IPv4 addresses, a pointer to a sockaddr_in structure would be cast to a pointer to SOCKADDR as the RemoteAddress and LocalAddress parameters. For IPv6 addresses, a pointer to a sockaddr_in6 structure would be cast to a pointer to SOCKADDR as the RemoteAddress and LocalAddress parameters.When the WSAConnectByName function returns TRUE, the socket s is in the default state for a connected socket. The socket s does not enable previously set properties or options until SO_UPDATE_CONNECT_CONTEXT is set on the socket. Use the setsockopt function to set the SO_UPDATE_CONNECT_CONTEXT option.For example:Windows 8.1 and Windows Server 2012 R2: The WSAConnectByNameW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.Establish a connection using WSAConnectByName.IPPROTO_IPV6 Socket OptionsSOCKADDRWSAConnectWSAConnectByListWSAGetLastErrorgetaddrinfogetpeernamegetsocknamesetsockopt</param>
        /// <param name="Reserved"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool WSAConnectByNameW(short s, string nodename, string servicename, out uint LocalAddressLength, out string LocalAddress, out uint RemoteAddressLength, out string RemoteAddress, TIMEVAL timeout, WSAOVERLAPPED Reserved);

        /// <summary>
        ///The WSACreateEvent function creates a new event object.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call WSAGetLastError.
        /// </remarks>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern SERVENT WSACreateEvent();

        /// <summary>
        ///The WSADuplicateSocket function returns a WSAPROTOCOL_INFO structure that can be used to create a new socket descriptor for a shared socket. The WSADuplicateSocket function cannot be used on a QOS-enabled socket.
        /// </summary>
        /// <param name="s">Descriptor identifying the local socket.</param>
        /// <param name="dwProcessId">Process identifier of the target process in which the duplicated socket will be used.</param>
        /// <param name="lpProtocolInfo"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSADuplicateSocketA(short s, uint dwProcessId, out WSAPROTOCOL_INFOA lpProtocolInfo);

        /// <summary>
        ///The WSADuplicateSocket function returns a WSAPROTOCOL_INFO structure that can be used to create a new socket descriptor for a shared socket. The WSADuplicateSocket function cannot be used on a QOS-enabled socket.
        /// </summary>
        /// <param name="s">Descriptor identifying the local socket.</param>
        /// <param name="dwProcessId">Process identifier of the target process in which the duplicated socket will be used.</param>
        /// <param name="lpProtocolInfo"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSADuplicateSocketW(short s, uint dwProcessId, out WSAPROTOCOL_INFOW lpProtocolInfo);

        /// <summary>
        ///The WSAEnumNameSpaceProviders function retrieves information on available namespace providers.
        /// </summary>
        /// <param name="lpdwBufferLength">On input, the number of bytes contained in the buffer pointed to by lpnspBuffer. On output (if the function fails, and the error is WSAEFAULT), the minimum number of bytes to pass for the lpnspBuffer to retrieve all the requested information. The buffer passed to WSAEnumNameSpaceProviders must be sufficient to hold all of the namespace information.</param>
        /// <param name="lpnspBuffer"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAEnumNameSpaceProvidersA(out uint lpdwBufferLength, out WSANAMESPACE_INFOA lpnspBuffer);

        /// <summary>
        ///The WSAEnumNameSpaceProvidersEx function retrieves information on available namespace providers.
        /// </summary>
        /// <param name="lpdwBufferLength">On input, the number of bytes contained in the buffer pointed to by lpnspBuffer. On output (if the function fails, and the error is WSAEFAULT), the minimum number of bytes to allocate for the lpnspBuffer buffer to allow it to retrieve all the requested information. The buffer passed to WSAEnumNameSpaceProvidersEx must be sufficient to hold all of the namespace information.</param>
        /// <param name="lpnspBuffer"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAEnumNameSpaceProvidersExA(out uint lpdwBufferLength, out WSANAMESPACE_INFOEXA lpnspBuffer);

        /// <summary>
        ///The WSAEnumNameSpaceProvidersEx function retrieves information on available namespace providers.
        /// </summary>
        /// <param name="lpdwBufferLength">On input, the number of bytes contained in the buffer pointed to by lpnspBuffer. On output (if the function fails, and the error is WSAEFAULT), the minimum number of bytes to allocate for the lpnspBuffer buffer to allow it to retrieve all the requested information. The buffer passed to WSAEnumNameSpaceProvidersEx must be sufficient to hold all of the namespace information.</param>
        /// <param name="lpnspBuffer"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAEnumNameSpaceProvidersExW(out uint lpdwBufferLength, out WSANAMESPACE_INFOEXW lpnspBuffer);

        /// <summary>
        ///The WSAEnumNameSpaceProviders function retrieves information on available namespace providers.
        /// </summary>
        /// <param name="lpdwBufferLength">On input, the number of bytes contained in the buffer pointed to by lpnspBuffer. On output (if the function fails, and the error is WSAEFAULT), the minimum number of bytes to pass for the lpnspBuffer to retrieve all the requested information. The buffer passed to WSAEnumNameSpaceProviders must be sufficient to hold all of the namespace information.</param>
        /// <param name="lpnspBuffer"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAEnumNameSpaceProvidersW(out uint lpdwBufferLength, out WSANAMESPACE_INFOW lpnspBuffer);

        /// <summary>
        ///The WSAEnumNetworkEvents function discovers occurrences of network events for the indicated socket, clear internal network event records, and reset event objects (optional).
        /// </summary>
        /// <param name="s">A descriptor identifying the socket.</param>
        /// <param name="hEventObject">An optional handle identifying an associated event object to be reset.</param>
        /// <param name="lpNetworkEvents"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAEnumNetworkEvents(short s, SERVENT hEventObject, out WSANETWORKEVENTS lpNetworkEvents);

        /// <summary>
        ///The WSAEnumProtocols function retrieves information about available transport protocols.
        /// </summary>
        /// <param name="lpiProtocols">A NULL-terminated array of iProtocol values. This parameter is optional; if lpiProtocols is NULL, information on all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.</param>
        /// <param name="lpProtocolBuffer"></param>
        /// <param name="lpdwBufferLength">On input, number of bytes in the lpProtocolBuffer buffer passed to WSAEnumProtocols. On output, the minimum buffer size that can be passed to WSAEnumProtocols to retrieve all the requested information. This routine has no ability to enumerate over multiple calls; the passed-in buffer must be large enough to hold all entries in order for the routine to succeed. This reduces the complexity of the API and should not pose a problem because the number of protocols loaded on a computer is typically small.If no error occurs, WSAEnumProtocols returns the number of protocols to be reported. Otherwise, a value of SOCKET_ERROR is returned and a specific error code can be retrieved by calling WSAGetLastError.The WSAEnumProtocols function is used to discover information about the collection of transport protocols installed on the local computer. Layered protocols are only usable by applications when installed in protocol chains. Information on layered protocols is not returned except for any dummy layered service providers (LSPs) installed with a chain length of zero in the lpProtocolBuffer.The WSAEnumProtocols function differs from the WSCEnumProtocols and WSCEnumProtocols32 functions in that the WSAEnumProtocols function doesn't return WSAPROTOCOL_INFO structures for all installed protocols. The WSAEnumProtocols function excludes protocols that the service provider has set with the PFL_HIDDEN flag in the dwProviderFlags member of the WSAPROTOCOL_INFO structure to indicate to the Ws2_32.dll that this protocol should not be returned in the result buffer generated by WSAEnumProtocols function. In addition, the WSAEnumProtocols function does not return data for WSAPROTOCOL_INFO structures that have a chain length of one or greater (an LSP provider). The WSAEnumProtocols only returns information on base protocols and protocol chains that lack the PFL_HIDDEN flag and don't have a protocol chain length of zero.A WSAPROTOCOL_INFO structure is provided in the buffer pointed to by lpProtocolBuffer for each requested protocol. If the specified buffer is not large enough (as indicated by the input value of lpdwBufferLength ), the value pointed to by lpdwBufferLength will be updated to indicate the required buffer size. The application should then obtain a large enough buffer and call WSAEnumProtocols again.The order in which the WSAPROTOCOL_INFO structures appear in the buffer coincides with the order in which the protocol entries were registered by the service provider using the WS2_32.DLL, or with any subsequent reordering that occurred through the Windows Sockets application or DLL supplied for establishing default TCP/IP providers.Windows Phone 8: The WSAEnumProtocolsW function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: The WSAEnumProtocolsW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.The following example demonstrates the use of the WSAEnumProtocols function to retrieve an array of WSAPROTOCOL_INFO structures for available transport protocols.WSAPROTOCOL_INFOWSCEnumProtocolsWSCEnumProtocols32Winsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAEnumProtocolsA(int lpiProtocols, out WSAPROTOCOL_INFOA lpProtocolBuffer, out uint lpdwBufferLength);

        /// <summary>
        ///The WSAEnumProtocols function retrieves information about available transport protocols.
        /// </summary>
        /// <param name="lpiProtocols">A NULL-terminated array of iProtocol values. This parameter is optional; if lpiProtocols is NULL, information on all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.</param>
        /// <param name="lpProtocolBuffer"></param>
        /// <param name="lpdwBufferLength">On input, number of bytes in the lpProtocolBuffer buffer passed to WSAEnumProtocols. On output, the minimum buffer size that can be passed to WSAEnumProtocols to retrieve all the requested information. This routine has no ability to enumerate over multiple calls; the passed-in buffer must be large enough to hold all entries in order for the routine to succeed. This reduces the complexity of the API and should not pose a problem because the number of protocols loaded on a computer is typically small.If no error occurs, WSAEnumProtocols returns the number of protocols to be reported. Otherwise, a value of SOCKET_ERROR is returned and a specific error code can be retrieved by calling WSAGetLastError.The WSAEnumProtocols function is used to discover information about the collection of transport protocols installed on the local computer. Layered protocols are only usable by applications when installed in protocol chains. Information on layered protocols is not returned except for any dummy layered service providers (LSPs) installed with a chain length of zero in the lpProtocolBuffer.The WSAEnumProtocols function differs from the WSCEnumProtocols and WSCEnumProtocols32 functions in that the WSAEnumProtocols function doesn't return WSAPROTOCOL_INFO structures for all installed protocols. The WSAEnumProtocols function excludes protocols that the service provider has set with the PFL_HIDDEN flag in the dwProviderFlags member of the WSAPROTOCOL_INFO structure to indicate to the Ws2_32.dll that this protocol should not be returned in the result buffer generated by WSAEnumProtocols function. In addition, the WSAEnumProtocols function does not return data for WSAPROTOCOL_INFO structures that have a chain length of one or greater (an LSP provider). The WSAEnumProtocols only returns information on base protocols and protocol chains that lack the PFL_HIDDEN flag and don't have a protocol chain length of zero.A WSAPROTOCOL_INFO structure is provided in the buffer pointed to by lpProtocolBuffer for each requested protocol. If the specified buffer is not large enough (as indicated by the input value of lpdwBufferLength ), the value pointed to by lpdwBufferLength will be updated to indicate the required buffer size. The application should then obtain a large enough buffer and call WSAEnumProtocols again.The order in which the WSAPROTOCOL_INFO structures appear in the buffer coincides with the order in which the protocol entries were registered by the service provider using the WS2_32.DLL, or with any subsequent reordering that occurred through the Windows Sockets application or DLL supplied for establishing default TCP/IP providers.Windows Phone 8: The WSAEnumProtocolsW function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: The WSAEnumProtocolsW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.The following example demonstrates the use of the WSAEnumProtocols function to retrieve an array of WSAPROTOCOL_INFO structures for available transport protocols.WSAPROTOCOL_INFOWSCEnumProtocolsWSCEnumProtocols32Winsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAEnumProtocolsW(int lpiProtocols, out WSAPROTOCOL_INFOW lpProtocolBuffer, out uint lpdwBufferLength);

        /// <summary>
        ///The WSAEventSelect function specifies an event object to be associated with the specified set of FD_XXX network events.
        /// </summary>
        /// <param name="s">A descriptor identifying the socket.</param>
        /// <param name="hEventObject">A handle identifying the event object to be associated with the specified set of FD_XXX network events.</param>
        /// <param name="lNetworkEvents">A bitmask that specifies the combination of FD_XXX network events in which the application has interest.The return value is zero if the application's specification of the network events and the associated event object was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.As in the case of the select and WSAAsyncSelect functions, WSAEventSelect will frequently be used to determine when a data transfer operation (send or recv) can be issued with the expectation of immediate success. Nevertheless, a robust application must be prepared for the possibility that the event object is set and it issues a Windows Sockets call that returns WSAEWOULDBLOCK immediately. For example, the following sequence of operations is possible:Any call to the reenabling routine, even one that fails, results in reenabling of recording and signaling for the relevant network event and event object.For FD_READ, FD_OOB, and FD_ACCEPT network events, network event recording and event object signaling are level-triggered. This means that if the reenabling routine is called and the relevant network condition is still valid after the call, the network event is recorded and the associated event object is set. This allows an application to be event-driven and not be concerned with the amount of data that arrives at any one time. Consider the following sequence:The FD_QOS event is considered edge triggered. A message will be posted exactly once when a quality of service change occurs. Further messages will not be forthcoming until either the provider detects a further change in quality of service or the application renegotiates the quality of service for the socket.The FD_ROUTING_INTERFACE_CHANGE and FD_ADDRESS_LIST_CHANGE events are considered edge triggered as well. A message will be posted exactly once when a change occurs after the application has requested the notification by issuing WSAIoctl with SIO_ROUTING_INTERFACE_CHANGE or SIO_ADDRESS_LIST_CHANGE correspondingly. Other messages will not be forthcoming until the application reissues the IOCTL and another change is detected since the IOCTL has been issued.If a network event has already happened when the application calls WSAEventSelect or when the reenabling function is called, then a network event is recorded and the associated event object is set as appropriate. For example, consider the following sequence:The FD_OOB network event is used only when a socket is configured to receive OOB data separately. If the socket is configured to receive OOB data inline, the OOB (expedited) data is treated as normal data and the application should register an interest in, and will get FD_READ network event, not FD_OOB network event. An application can set or inspect the way in which OOB data is to be handled by using setsockopt or getsockopt for the SO_OOBINLINE option.The error code in an FD_CLOSE network event indicates whether the socket close was graceful or abortive. If the error code is zero, then the close was graceful; if the error code is WSAECONNRESET, then the socket's virtual circuit was reset. This only applies to connection-oriented sockets such as SOCK_STREAM.The FD_CLOSE network event is recorded when a close indication is received for the virtual circuit corresponding to the socket. In TCP terms, this means that the FD_CLOSE is recorded when the connection goes into the TIME WAIT or CLOSE WAIT states. This results from the remote end performing a shutdown on the send side or a closesocket. FD_CLOSE being posted after all data is read from a socket. An application should check for remaining data upon receipt of FD_CLOSE to avoid any possibility of losing data. For more information, see the section on Graceful Shutdown, Linger Options, and Socket Closure and the shutdown function.Note that Windows Sockets will record only an FD_CLOSE network event to indicate closure of a virtual circuit. It will not record an FD_READ network event to indicate this condition.The FD_QOS or FD_GROUP_QOS network event is recorded when any parameter in the flow specification associated with socket s. Applications should use WSAIoctl with command SIO_GET_QOS to get the current quality of service for socket s.The FD_ROUTING_INTERFACE_CHANGE network event is recorded when the local interface that should be used to reach the destination specified in WSAIoctl with SIO_ROUTING_INTERFACE_CHANGE changes after such IOCTL has been issued.The FD_ADDRESS_LIST_CHANGE network event is recorded when the list of addresses of protocol family for the socket to which the application can bind changes after WSAIoctl with SIO_ADDRESS_LIST_CHANGE has been issued.The WSAEventSelect function is used to specify an event object, hEventObject, to be associated with the selected FD_XXX network events, lNetworkEvents. The socket for which an event object is specified is identified by the s parameter. The event object is set when any of the nominated network events occur.The WSAEventSelect function operates very similarly to WSAAsyncSelect, the difference being the actions taken when a nominated network event occurs. The WSAAsyncSelect function causes an application-specified Windows message to be posted. The WSAEventSelect sets the associated event object and records the occurrence of this event in an internal network event record. An application can use WSAWaitForMultipleEvents to wait or poll on the event object, and use WSAEnumNetworkEvents to retrieve the contents of the internal network event record and thus determine which of the nominated network events have occurred.The proper way to reset the state of an event object used with the WSAEventSelect function is to pass the handle of the event object to the WSAEnumNetworkEvents function in the hEventObject parameter. This will reset the event object and adjust the status of active FD events on the socket in an atomic fashion.WSAEventSelect is the only function that causes network activity and errors to be recorded and retrievable through WSAEnumNetworkEvents. See the descriptions of select and WSAAsyncSelect to find out how those functions report network activity and errors.The WSAEventSelect function automatically sets socket s to nonblocking mode, regardless of the value of lNetworkEvents. To set socket s back to blocking mode, it is first necessary to clear the event record associated with socket s via a call to WSAEventSelect with lNetworkEvents set to zero and the hEventObject parameter set to NULL. You can then call ioctlsocket or WSAIoctl to set the socket back to blocking mode.The lNetworkEvents parameter is constructed by using the bitwise OR operator with any of the values specified in the following list.Issuing a WSAEventSelect for a socket cancels any previous WSAAsyncSelect or WSAEventSelect for the same socket and clears the internal network event record. For example, to associate an event object with both reading and writing network events, the application must call WSAEventSelect with both FD_READ and FD_WRITE, as follows:It is not possible to specify different event objects for different network events. The following code will not work; the second call will cancel the effects of the first, and only the FD_WRITE network event will be associated with hEventObject2:To cancel the association and selection of network events on a socket, lNetworkEvents should be set to zero, in which case the hEventObject parameter will be ignored.Closing a socket with closesocket also cancels the association and selection of network events specified in WSAEventSelect for the socket. The application, however, still must call WSACloseEvent to explicitly close the event object and free any resources.The socket created when the accept function is called has the same properties as the listening socket used to accept it. Any WSAEventSelect association and network events selection set for the listening socket apply to the accepted socket. For example, if a listening socket has WSAEventSelect association of hEventObject with FD_ACCEPT, FD_READ, and FD_WRITE, then any socket accepted on that listening socket will also have FD_ACCEPT, FD_READ, and FD_WRITE network events associated with the same hEventObject. If a different hEventObject or network events are desired, the application should call WSAEventSelect, passing the accepted socket and the desired new information.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAAsyncSelectWSACloseEventWSACreateEventWSAEnumNetworkEventsWSAWaitForMultipleEventsWinsock FunctionsWinsock Referenceshutdown</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAEventSelect(short s, SERVENT hEventObject, int lNetworkEvents);

        /// <summary>
        ///The WSAGetLastError function returns the error status for the last Windows Sockets operation that failed.
        /// </summary>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAGetLastError();

        /// <summary>
        ///The WSAGetOverlappedResult function retrieves the results of an overlapped operation on the specified socket.
        /// </summary>
        /// <param name="s">A descriptor identifying the socket.This is the same socket that was specified when the overlapped operation was started by a call to any of the Winsock functions that supports overlapped operations. These functions include AcceptEx, ConnectEx, DisconnectEx, TransmitFile, TransmitPackets, WSARecv, WSARecvFrom, LPFN_WSARECVMSG (WSARecvMsg), WSASend, WSASendMsg, WSASendTo, and WSAIoctl.</param>
        /// <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure that was specified when the overlapped operation was started. This parameter must not be a NULL pointer.</param>
        /// <param name="lpcbTransfer"></param>
        /// <param name="fWait">A flag that specifies whether the function should wait for the pending overlapped operation to complete. If TRUE, the function does not return until the operation has been completed. If FALSE and the operation is still pending, the function returns FALSE and the WSAGetLastError function returns WSA_IO_INCOMPLETE. The fWait parameter may be set to TRUE only if the overlapped operation selected the event-based completion notification.</param>
        /// <param name="lpdwFlags"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool WSAGetOverlappedResult(short s, WSAOVERLAPPED lpOverlapped, out uint lpcbTransfer, bool fWait, out uint lpdwFlags);

        /// <summary>
        ///The WSAGetQOSByName function initializes a QOS structure based on a named template, or it supplies a buffer to retrieve an enumeration of the available template names.
        /// </summary>
        /// <param name="s">A descriptor identifying a socket.</param>
        /// <param name="lpQOSName">A pointer to a specific quality of service template.</param>
        /// <param name="lpQOS"></param>
        /// <remarks>
        /// To get extended error information, call WSAGetLastError.
        /// </remarks>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool WSAGetQOSByName(short s, out string lpQOSName, out QOS lpQOS);

        /// <summary>
        ///The WSAGetServiceClassInfo function retrieves the class information (schema) pertaining to a specified service class from a specified namespace provider.
        /// </summary>
        /// <param name="lpProviderId">A pointer to a GUID that identifies a specific namespace provider.</param>
        /// <param name="lpServiceClassId">A pointer to a GUID identifying the service class.</param>
        /// <param name="lpdwBufSize">On input, the number of bytes contained in the buffer pointed to by the lpServiceClassInfo parameter.On output, if the function fails and the error is WSAEFAULT, this parameter specifies the minimum size, in bytes, of the buffer pointed to lpServiceClassInfo needed to retrieve the record.</param>
        /// <param name="lpServiceClassInfo"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAGetServiceClassInfoA(nint lpProviderId, nint lpServiceClassId, out uint lpdwBufSize, out WSASERVICECLASSINFOA lpServiceClassInfo);

        /// <summary>
        ///The WSAGetServiceClassInfo function retrieves the class information (schema) pertaining to a specified service class from a specified namespace provider.
        /// </summary>
        /// <param name="lpProviderId">A pointer to a GUID that identifies a specific namespace provider.</param>
        /// <param name="lpServiceClassId">A pointer to a GUID identifying the service class.</param>
        /// <param name="lpdwBufSize">On input, the number of bytes contained in the buffer pointed to by the lpServiceClassInfo parameter.On output, if the function fails and the error is WSAEFAULT, this parameter specifies the minimum size, in bytes, of the buffer pointed to lpServiceClassInfo needed to retrieve the record.</param>
        /// <param name="lpServiceClassInfo"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAGetServiceClassInfoW(nint lpProviderId, nint lpServiceClassId, out uint lpdwBufSize, out WSASERVICECLASSINFOW lpServiceClassInfo);

        /// <summary>
        ///The WSAGetServiceClassNameByClassId function retrieves the name of the service associated with the specified type. This name is the generic service name, like FTP or SNA, and not the name of a specific instance of that service.
        /// </summary>
        /// <param name="lpServiceClassId">A pointer to the GUID for the service class.</param>
        /// <param name="lpszServiceClassName"></param>
        /// <param name="lpdwBufferLength">On input, the length of the buffer returned by lpszServiceClassName, in characters. On output, the length of the service name copied into lpszServiceClassName, in characters.The WSAGetServiceClassNameByClassId function returns a value of zero if successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.WSAStartupWinsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAGetServiceClassNameByClassIdA(nint lpServiceClassId, out string lpszServiceClassName, out uint lpdwBufferLength);

        /// <summary>
        ///The WSAGetServiceClassNameByClassId function retrieves the name of the service associated with the specified type. This name is the generic service name, like FTP or SNA, and not the name of a specific instance of that service.
        /// </summary>
        /// <param name="lpServiceClassId">A pointer to the GUID for the service class.</param>
        /// <param name="lpszServiceClassName"></param>
        /// <param name="lpdwBufferLength">On input, the length of the buffer returned by lpszServiceClassName, in characters. On output, the length of the service name copied into lpszServiceClassName, in characters.The WSAGetServiceClassNameByClassId function returns a value of zero if successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.WSAStartupWinsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAGetServiceClassNameByClassIdW(nint lpServiceClassId, out string lpszServiceClassName, out uint lpdwBufferLength);

        /// <summary>
        ///The WSAHtonl function converts a u_long from host byte order to network byte order.
        /// </summary>
        /// <param name="s">A descriptor identifying a socket.</param>
        /// <param name="hostlong">A 32-bit number in host byte order.</param>
        /// <param name="lpnetlong"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAHtonl(short s, uint hostlong, out uint lpnetlong);

        /// <summary>
        ///The WSAHtons function converts a u_short from host byte order to network byte order.
        /// </summary>
        /// <param name="s">A descriptor identifying a socket.</param>
        /// <param name="hostshort">A 16-bit number in host byte order.</param>
        /// <param name="lpnetshort"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAHtons(short s, ushort hostshort, out ushort lpnetshort);

        /// <summary>
        ///The WSAInstallServiceClass function registers a service class schema within a namespace. This schema includes the class name, class identifier, and any namespace-specific information that is common to all instances of the service, such as the SAP identifier or object identifier.
        /// </summary>
        /// <param name="lpServiceClassInfo">Service class to namespace specific–type mapping information. Multiple mappings can be handled at one time.See the section Service Class Data Structures for a description of pertinent data structures.The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.WSAGetLastErrorWSAGetServiceClassInfoWSASERVICECLASSINFOWinsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAInstallServiceClassA(WSASERVICECLASSINFOA lpServiceClassInfo);

        /// <summary>
        ///The WSAInstallServiceClass function registers a service class schema within a namespace. This schema includes the class name, class identifier, and any namespace-specific information that is common to all instances of the service, such as the SAP identifier or object identifier.
        /// </summary>
        /// <param name="lpServiceClassInfo">Service class to namespace specific–type mapping information. Multiple mappings can be handled at one time.See the section Service Class Data Structures for a description of pertinent data structures.The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.WSAGetLastErrorWSAGetServiceClassInfoWSASERVICECLASSINFOWinsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAInstallServiceClassW(WSASERVICECLASSINFOW lpServiceClassInfo);

        /// <summary>
        ///The WSAIoctl function controls the mode of a socket.
        /// </summary>
        /// <param name="s">A descriptor identifying a socket.</param>
        /// <param name="dwIoControlCode">The control code of operation to perform. See Winsock IOCTLs.</param>
        /// <param name="lpvInBuffer">A pointer to the input buffer.</param>
        /// <param name="cbInBuffer">The size, in bytes, of the input buffer.</param>
        /// <param name="lpvOutBuffer"></param>
        /// <param name="cbOutBuffer">The size, in bytes, of the output buffer.</param>
        /// <param name="lpcbBytesReturned"></param>
        /// <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure (ignored for non-overlapped sockets).</param>
        /// <param name="lpCompletionRoutine">Type: _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINEUpon successful completion, the WSAIoctl returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.The WSAIoctl function is used to set or retrieve operating parameters associated with the socket, the transport protocol, or the communications subsystem.If both lpOverlapped and lpCompletionRoutine are NULL, the socket in this function will be treated as a non-overlapped socket. For a non-overlapped socket, lpOverlapped and lpCompletionRoutine parameters are ignored, which causes the function to behave like the standard ioctlsocket function except that the function can block if socket s is in blocking mode. If socket s is in non-blocking mode, this function can return WSAEWOULDBLOCK when the specified operation cannot be finished immediately. In this case, the application may change the socket to blocking mode and reissue the request or wait for the corresponding network event (such as FD_ROUTING_INTERFACE_CHANGE or FD_ADDRESS_LIST_CHANGE in the case of SIO_ROUTING_INTERFACE_CHANGE or SIO_ADDRESS_LIST_CHANGE) using a Windows message (using WSAAsyncSelect)-based or event (using WSAEventSelect)-based notification mechanism.For overlapped sockets, operations that cannot be completed immediately will be initiated, and completion will be indicated at a later time. The DWORD value pointed to by the lpcbBytesReturned parameter that is returned may be ignored. The final completion status and bytes returned can be retrieved when the appropriate completion method is signaled when the operation has completed.Any IOCTL may block indefinitely, depending on the service provider's implementation. If the application cannot tolerate blocking in a WSAIoctl call, overlapped I/O would be advised for IOCTLs that are especially likely to block including:SIO_ADDRESS_LIST_CHANGESIO_FINDROUTESIO_FLUSHSIO_GET_QOSSIO_GET_GROUP_QOSSIO_ROUTING_INTERFACE_CHANGESIO_SET_QOSSIO_SET_GROUP_QOSSome protocol-specific IOCTLs may also be especially likely to block. Check the relevant protocol-specific annex for any available information.The prototype for the completion routine pointed to by the lpCompletionRoutine parameter is as follows:The CompletionRoutine is a placeholder for an application-supplied function name. The dwError parameter specifies the completion status for the overlapped operation as indicated by lpOverlapped parameter. The cbTransferred parameter specifies the number of bytes received. The dwFlags parameter is not used for this IOCTL. The completion routine does not return a value.It is possible to adopt an encoding scheme that preserves the currently defined ioctlsocket opcodes while providing a convenient way to partition the opcode identifier space in as much as the dwIoControlCode parameter is now a 32-bit entity. The dwIoControlCode parameter is built to allow for protocol and vendor independence when adding new control codes while retaining backward compatibility with the Windows Sockets 1.1 and Unix control codes. The dwIoControlCode parameter has the following form.O is set if the output buffer is valid for the code, as with IOC_OUT. Control codes using both input and output buffers set both I and O.V is set if there are no parameters for the code, as with IOC_VOID.T is a 2-bit quantity that defines the type of the IOCTL. The following values are defined:0 The IOCTL is a standard Unix IOCTL code, as with FIONREAD and FIONBIO.1 The IOCTL is a generic Windows Sockets 2 IOCTL code. New IOCTL codes defined for Windows Sockets 2 will have T == 1.2 The IOCTL applies only to a specific address family.3 The IOCTL applies only to a specific vendor's provider, as with IOC_VENDOR. This type allows companies to be assigned a vendor number that appears in the Vendor/Address family parameter. Then, the vendor can define new IOCTLs specific to that vendor without having to register the IOCTL with a clearinghouse, thereby providing vendor flexibility and privacy.Vendor/Address family An 11-bit quantity that defines the vendor who owns the code (if T == 3) or that contains the address family to which the code applies (if T == 2). If this is a Unix IOCTL code (T == 0) then this parameter has the same value as the code on Unix. If this is a generic Windows Sockets 2 IOCTL (T == 1) then this parameter can be used as an extension of the code parameter to provide additional code values.Code The 16-bit quantity that contains the specific IOCTL code for the operation.The following Unix IOCTL codes (commands) are supported.The following Windows Sockets 2 commands are supported.If an overlapped operation completes immediately, WSAIoctl returns a value of zero and the lpcbBytesReturned parameter is updated with the number of bytes in the output buffer. If the overlapped operation is successfully initiated and will complete later, this function returns SOCKET_ERROR and indicates error code WSA_IO_PENDING. In this case, lpcbBytesReturned is not updated. When the overlapped operation completes the amount of data in the output buffer is indicated either through the cbTransferred parameter in the completion routine (if specified), or through the lpcbTransfer parameter in WSAGetOverlappedResult.When called with an overlapped socket, the lpOverlapped parameter must be valid for the duration of the overlapped operation. The lpOverlapped parameter contains the address of a WSAOVERLAPPED structure.If the lpCompletionRoutine parameter is NULL, the hEvent parameter of lpOverlapped is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use WSAWaitForMultipleEvents or WSAGetOverlappedResult to wait or poll on the event object.The prototype of the completion routine is as follows:This CompletionRoutine is a placeholder for an application-defined or library-defined function. The completion routine is invoked only if the thread is in an alertable state. To put a thread into an alertable state, use the WSAWaitForMultipleEvents, WaitForSingleObjectEx, or WaitForMultipleObjectsEx function with the fAlertable or bAlertable parameter set to TRUE.The dwError parameter of CompletionRoutine specifies the completion status for the overlapped operation as indicated by lpOverlapped. The cbTransferred parameter specifies the number of bytes returned. Currently, no flag values are defined and dwFlags will be zero. The CompletionRoutine function does not return a value.Returning from this function allows invocation of another pending completion routine for this socket. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.SOL_SOCKET Socket OptionsWSASocketWinsock FunctionsWinsock Referencegetsockoptioctlsocketsetsockoptsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAIoctl(short s, uint dwIoControlCode, nint lpvInBuffer, uint cbInBuffer, out nint lpvOutBuffer, uint cbOutBuffer, out uint lpcbBytesReturned, WSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPEDCOMPLETIONROUTINE lpCompletionRoutine);

        /// <summary>
        ///This function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0.
        /// </summary>

        [DllImport("req.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool WSAIsBlocking();

        /// <summary>
        ///The WSAJoinLeaf function joins a leaf node into a multipoint session, exchanges connect data, and specifies needed quality of service based on the specified FLOWSPEC structures.
        /// </summary>
        /// <param name="s">Descriptor identifying a multipoint socket.</param>
        /// <param name="name">Name of the peer to which the socket is to be joined.</param>
        /// <param name="namelen">Length of name, in bytes.</param>
        /// <param name="lpCallerData">Pointer to the user data that is to be transferred to the peer during multipoint session establishment.</param>
        /// <param name="lpCalleeData"></param>
        /// <param name="lpSQOS">Pointer to the FLOWSPEC structures for socket s, one for each direction.</param>
        /// <param name="lpGQOS">Reserved for future use with socket groups. A pointer to the FLOWSPEC structures for the socket group (if applicable).</param>
        /// <param name="dwFlags">Flags to indicate that the socket is acting as a sender (JL_SENDER_ONLY), receiver (JL_RECEIVER_ONLY), or both (JL_BOTH).If no error occurs, WSAJoinLeaf returns a value of type SOCKET that is a descriptor for the newly created multipoint socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling WSAGetLastError.On a blocking socket, the return value indicates success or failure of the join operation.With a nonblocking socket, successful initiation of a join operation is indicated by a return of a valid socket descriptor. Subsequently, an FD_CONNECT indication will be given on the original socket s when the join operation completes, either successfully or otherwise. The application must use either WSAAsyncSelect or WSAEventSelect with interest registered for the FD_CONNECT event in order to determine when the join operation has completed and checks the associated error code to determine the success or failure of the operation. The select function cannot be used to determine when the join operation completes.Also, until the multipoint session join attempt completes all subsequent calls to WSAJoinLeaf on the same socket will fail with the error code WSAEALREADY. After the WSAJoinLeaf operation completes successfully, a subsequent attempt will usually fail with the error code WSAEISCONN. An exception to the WSAEISCONN rule occurs for a c_root socket that allows root-initiated joins. In such a case, another join may be initiated after a prior WSAJoinLeaf operation completes.If the return error code indicates the multipoint session join attempt failed (that is, WSAECONNREFUSED, WSAENETUNREACH, WSAETIMEDOUT) the application can call WSAJoinLeaf again for the same socket.The WSAJoinLeaf function is used to join a leaf node to a multipoint session, and to perform a number of other ancillary operations that occur at session join time as well. If the socket s is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound.The WSAJoinLeaf function has the same parameters and semantics as WSAConnect except that it returns a socket descriptor (as in WSAAccept), and it has an additional dwFlags parameter. Only multipoint sockets created using WSASocket with appropriate multipoint flags set can be used for input parameter s in this function. The returned socket descriptor will not be usable until after the join operation completes. For example, if the socket is in nonblocking mode after a corresponding FD_CONNECT indication has been received from WSAAsyncSelect or WSAEventSelect on the original socket s, except that closesocket may be invoked on this new socket descriptor to cancel a pending join operation. A root application in a multipoint session may call WSAJoinLeaf one or more times in order to add a number of leaf nodes, however at most one multipoint connection request may be outstanding at a time. Refer to Multipoint and Multicast Semantics for additional information.For nonblocking sockets it is often not possible to complete the connection immediately. In such a case, this function returns an as-yet unusable socket descriptor and the operation proceeds. There is no error code such as WSAEWOULDBLOCK in this case, since the function has effectively returned a successful start indication. When the final outcome success or failure becomes known, it may be reported through WSAAsyncSelect or WSAEventSelect depending on how the client registers for notification on the original socket s. In either case, the notification is announced with FD_CONNECT and the error code associated with the FD_CONNECT indicates either success or a specific reason for failure. The select function cannot be used to detect completion notification for WSAJoinLeaf.The socket descriptor returned by WSAJoinLeaf is different depending on whether the input socket descriptor, s, is a c_root or a c_leaf. When used with a c_root socket, the name parameter designates a particular leaf node to be added and the returned socket descriptor is a c_leaf socket corresponding to the newly added leaf node. The newly created socket has the same properties as s, including asynchronous events registered with WSAAsyncSelect or with WSAEventSelect. It is not intended to be used for exchange of multipoint data, but rather is used to receive network event indications (for example, FD_CLOSE) for the connection that exists to the particular c_leaf. Some multipoint implementations can also allow this socket to be used for side chats between the root and an individual leaf node. An FD_CLOSE indication will be received for this socket if the corresponding leaf node calls closesocket to drop out of the multipoint session. Symmetrically, invoking closesocket on the c_leaf socket returned from WSAJoinLeaf will cause the socket in the corresponding leaf node to get an FD_CLOSE notification.When WSAJoinLeaf is invoked with a c_leaf socket, the name parameter contains the address of the root application (for a rooted control scheme) or an existing multipoint session (nonrooted control scheme), and the returned socket descriptor is the same as the input socket descriptor. In other words, a new socket descriptor is not allocated. In a rooted control scheme, the root application would put its c_root socket in listening mode by calling listen. The standard FD_ACCEPT notification will be delivered when the leaf node requests to join itself to the multipoint session. The root application uses the usual accept or WSAAccept functions to admit the new leaf node. The value returned from either accept or WSAAccept is also a c_leaf socket descriptor just like those returned from WSAJoinLeaf. To accommodate multipoint schemes that allow both root-initiated and leaf-initiated joins, it is acceptable for a c_root socket that is already in listening mode to be used as an input to WSAJoinLeaf.The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specifies.The lpCallerData is a value parameter that contains any user data that is to be sent along with the multipoint session join request. If lpCallerData is NULL, no user data will be passed to the peer. The lpCalleeData is a result parameter that will contain any user data passed back from the peer as part of the multipoint session establishment. The len member of the WSABUF structure pointed to by the lpCalleeData parameter initially contains the length of the buffer allocated by the application and pointed to by the buf member of the WSABUF structure. The len member of the WSABUF structure pointed to by the lpCalleeData parameter will be set to zero if no user data has been passed back. The lpCalleeData information will be valid when the multipoint join operation is complete.For blocking sockets, this will be when the WSAJoinLeaf function returns. For nonblocking sockets, this will be after the join operation has completed. For example, this could occur after FD_CONNECT notification on the original socket s). If lpCalleeData is NULL, no user data will be passed back. The exact format of the user data is specific to the address family to which the socket belongs.At multipoint session establishment time, an application can use the lpSQOS and/or lpGQOS parameters to override any previous quality of service specification made for the socket through WSAIoctl with the SIO_SET_QOS or SIO_SET_GROUP_QOS opcodes.The lpSQOS parameter specifies the FLOWSPEC structures for socket s, one for each direction, followed by any additional provider-specific parameters. If either the associated transport provider in general or the specific type of socket in particular cannot honor the quality of service request, an error will be returned as indicated in the following. The respective sending or receiving flow specification values will be ignored for any unidirectional sockets. If no provider-specific parameters are specified, the buf and len members of the WSABUF structure pointed to by the lpCalleeData parameter should be set to NULL and zero, respectively. A NULL value for lpSQOS indicates no application-supplied quality of service.Reserved for future socket groups. The lpGQOS parameter specifies the FLOWSPEC structures for the socket group (if applicable), one for each direction, followed by any additional provider-specific parameters. If no provider-specific parameters are specified, the buf and len members of the WSABUF structure pointed to by the lpCalleeData parameter should be set to should be set to NULL and zero, respectively. A NULL value for lpGQOS indicates no application-supplied group quality of service. This parameter will be ignored if s is not the creator of the socket group.When connected sockets break (that is, become closed for whatever reason), they should be discarded and recreated. It is safest to assume that when things go awry for any reason on a connected socket, the application must discard and recreate the needed sockets in order to return to a stable point.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAAcceptWSAAsyncSelectWSABUFWSAEventSelectWSASocketWinsock FunctionsWinsock Referenceacceptbindselect</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short WSAJoinLeaf(short s, IN_ADDR name, int namelen, string lpCallerData, out string lpCalleeData, QOS lpSQOS, QOS lpGQOS, uint dwFlags);

        /// <summary>
        ///The WSALookupServiceBegin function initiates a client query that is constrained by the information contained within a WSAQUERYSET structure. WSALookupServiceBegin only returns a handle, which should be used by subsequent calls to WSALookupServiceNext to get the actual results.
        /// </summary>
        /// <param name="lpqsRestrictions">A pointer to the search criteria. See the Remarks for details.</param>
        /// <param name="dwControlFlags">A set of flags that controls the depth of the search.Supported values for the dwControlFlags parameter are defined in the Winsock2.h header file and can be a combination of the following options.</param>
        /// <param name="lphLookup"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSALookupServiceBeginA(WSAQUERYSETA lpqsRestrictions, uint dwControlFlags, out nint lphLookup);

        /// <summary>
        ///The WSALookupServiceBegin function initiates a client query that is constrained by the information contained within a WSAQUERYSET structure. WSALookupServiceBegin only returns a handle, which should be used by subsequent calls to WSALookupServiceNext to get the actual results.
        /// </summary>
        /// <param name="lpqsRestrictions">A pointer to the search criteria. See the Remarks for details.</param>
        /// <param name="dwControlFlags">A set of flags that controls the depth of the search.Supported values for the dwControlFlags parameter are defined in the Winsock2.h header file and can be a combination of the following options.</param>
        /// <param name="lphLookup"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSALookupServiceBeginW(WSAQUERYSETW lpqsRestrictions, uint dwControlFlags, out nint lphLookup);

        /// <summary>
        ///The WSALookupServiceEnd function is called to free the handle after previous calls to WSALookupServiceBegin and WSALookupServiceNext.
        /// </summary>
        /// <param name="hLookup">Handle previously obtained by calling WSALookupServiceBegin.The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.Bluetooth and WSALookupServiceEndWSALookupServiceBeginWSALookupServiceNextWinsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSALookupServiceEnd(nint hLookup);

        /// <summary>
        ///The WSALookupServiceNext function is called after obtaining a handle from a previous call to WSALookupServiceBegin in order to retrieve the requested service information.
        /// </summary>
        /// <param name="hLookup">A handle returned from the previous call to WSALookupServiceBegin.</param>
        /// <param name="dwControlFlags">A set of flags that controls the operation. The values passed in the dwControlFlags parameter to the WSALookupServiceBegin function determine the possible criteria. Any values passed in the dwControlFlags parameter to the WSALookupServiceNext function further restrict the criteria for the service lookup.Currently, LUP_FLUSHPREVIOUS is defined as a means to cope with a result set that is too large. If an application does not (or cannot) supply a large enough buffer, setting LUP_FLUSHPREVIOUS instructs the provider to discard the last result set—which was too large—and move on to the next set for this call.Supported values for the dwControlFlags parameter are defined in the Winsock2.h header file and can be a combination of the following options.</param>
        /// <param name="lpdwBufferLength">On input, the number of bytes contained in the buffer pointed to by lpqsResults. On output, if the function fails and the error is WSAEFAULT, then it contains the minimum number of bytes to pass for the lpqsResults to retrieve the record.</param>
        /// <param name="lpqsResults"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSALookupServiceNextA(nint hLookup, uint dwControlFlags, out uint lpdwBufferLength, out WSAQUERYSETA lpqsResults);

        /// <summary>
        ///The WSALookupServiceNext function is called after obtaining a handle from a previous call to WSALookupServiceBegin in order to retrieve the requested service information.
        /// </summary>
        /// <param name="hLookup">A handle returned from the previous call to WSALookupServiceBegin.</param>
        /// <param name="dwControlFlags">A set of flags that controls the operation. The values passed in the dwControlFlags parameter to the WSALookupServiceBegin function determine the possible criteria. Any values passed in the dwControlFlags parameter to the WSALookupServiceNext function further restrict the criteria for the service lookup.Currently, LUP_FLUSHPREVIOUS is defined as a means to cope with a result set that is too large. If an application does not (or cannot) supply a large enough buffer, setting LUP_FLUSHPREVIOUS instructs the provider to discard the last result set—which was too large—and move on to the next set for this call.Supported values for the dwControlFlags parameter are defined in the Winsock2.h header file and can be a combination of the following options.</param>
        /// <param name="lpdwBufferLength">On input, the number of bytes contained in the buffer pointed to by lpqsResults. On output, if the function fails and the error is WSAEFAULT, then it contains the minimum number of bytes to pass for the lpqsResults to retrieve the record.</param>
        /// <param name="lpqsResults"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSALookupServiceNextW(nint hLookup, uint dwControlFlags, out uint lpdwBufferLength, out WSAQUERYSETW lpqsResults);

        /// <summary>
        ///The Windows Sockets WSANSPIoctl function enables developers to make I/O control calls to a registered namespace.
        /// </summary>
        /// <param name="hLookup">The lookup handle returned from a previous call to the WSALookupServiceBegin function.</param>
        /// <param name="dwControlCode">The control code of the operation to perform.The values that may be used for the dwControlCode parameter are determined by the namespace provider.The following value is supported by several Microsoft namespace providers including the Network Location Awareness (NS_NLA) namespace provider. This IOCTL is defined in the Winsock2.h header file.</param>
        /// <param name="lpvInBuffer">A pointer to the input buffer.</param>
        /// <param name="cbInBuffer">The size, in bytes, of the input buffer.</param>
        /// <param name="lpvOutBuffer"></param>
        /// <param name="cbOutBuffer">The size, in bytes, of the output buffer.</param>
        /// <param name="lpcbBytesReturned"></param>
        /// <param name="lpCompletion">A pointer to a WSACOMPLETION structure, used for asynchronous processing. Set lpCompletion to NULL to force blocking (synchronous) execution.Success returns NO_ERROR. Failure returns SOCKET_ERROR, and a specific error code can be retrieved by calling the WSAGetLastError function. The following table describes the error codes.The WSANSPIoctl function is used to set or retrieve operating parameters associated with a query handle to a namespace provider. The hLookup parameter is a handle to the namespace provider query previously returned by the WSALookupServiceBegin function (not a socket handle).Any IOCTL sent to a namespace provider may block indefinitely, depending upon the implementation of the namespace. If an application cannot tolerate blocking in a WSANSPIoctl function call, overlapped I/O should be used and the lpCompletion parameter should point to a WSACOMPLETION structure. To make a WSANSPIoctl function call nonblocking and return immediately, set the Type member of the WSACOMPLETION structure to NSP_NOTIFY_IMMEDIATELY.If lpCompletion is NULL, the WSANSPIoctl function executes as a blocking call. The namespace provider should return immediately and should not block. But each namespace is responsible for enforcing this behavior.The following IOCTL code is supported by several Microsoft name space provider:Immediate poll operations are usually much less expensive since they do not require a notification object. In most cases, this is implemented as a simple Boolean variable check. Asynchronous notification, however, may necessitate the creation of dedicated worker threads and/or inter-process communication channels, depending on the implementation of the namespace provider service, and will incur processing overhead related to the notification object involved with signaling the change event.To cancel an asynchronous notification request, end the original query with a WSALookupServiceEnd function call on the affected query handle. Canceling the asynchronous notification for LUP_NOTIFY_HWND will not post any message, however, an overlapped operation will be completed and notification will be delivered with the error WSA_OPERATION_ABORTED.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.ExitThreadWSACOMPLETIONWSAGetLastErrorWSALookupServiceBeginWSALookupServiceEndWSALookupServiceNextWinsock Functions</param>

        [DllImport("req.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSANSPIoctl(nint hLookup, uint dwControlCode, nint lpvInBuffer, out uint cbInBuffer, out nint lpvOutBuffer, uint cbOutBuffer, out uint lpcbBytesReturned, _WSAEcomparator lpCompletion);

        /// <summary>
        ///The WSANtohl function converts a u_long from network byte order to host byte order.
        /// </summary>
        /// <param name="s">A descriptor identifying a socket.</param>
        /// <param name="netlong">A 32-bit number in network byte order.</param>
        /// <param name="lphostlong"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSANtohl(short s, uint netlong, out uint lphostlong);

        /// <summary>
        ///The WSANtohs function converts a u_short from network byte order to host byte order.
        /// </summary>
        /// <param name="s">A descriptor identifying a socket.</param>
        /// <param name="netshort">A 16-bit number in network byte order.</param>
        /// <param name="lphostshort"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSANtohs(short s, ushort netshort, out ushort lphostshort);

        /// <summary>
        ///The WSAPoll function determines status of one or more sockets.
        /// </summary>
        /// <param name="fdArray">An array of one or more POLLFD structures specifying the set of sockets for which status is requested. The array must contain at least one structure with a valid socket. Upon return, this parameter receives the updated sockets with the revents status flags member set on each one that matches the status query criteria.</param>
        /// <param name="fds">The number of WSAPOLLFD structures in fdarray. This is not necessarily the number of sockets for which status is requested.</param>
        /// <param name="timeout">A value that specifies the wait behavior, based on the following values.</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAPoll(out WSAPOLLFD fdArray, uint fds, int timeout);

        /// <summary>
        ///The WSAProviderConfigChange function notifies the application when the provider configuration is changed.
        /// </summary>
        /// <param name="lpNotificationHandle">Pointer to notification handle. If the notification handle is set to NULL (the handle value not the pointer itself), this function returns a notification handle in the location pointed to by lpNotificationHandle.</param>
        /// <param name="lpOverlapped">Pointer to a WSAOVERLAPPED structure.</param>
        /// <param name="lpCompletionRoutine">Type: _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINEPointer to the completion routine called when the provider change notification is received.If no error occurs the WSAProviderConfigChange returns 0. Otherwise, a value of SOCKET_ERROR is returned and a specific error code may be retrieved by calling WSAGetLastError. The error code WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion (and thus change event) will be indicated at a later time.The WSAProviderConfigChange function notifies the application of provider (both transport and namespace) installation or removal in Windows operating environments that support such configuration change without requiring a restart. When called for the first time (lpNotificationHandle parameter points to NULL handle), this function completes immediately and returns notification handle in the location pointed by lpNotificationHandle that can be used in subsequent calls to receive notifications of provider installation and removal. The second and any subsequent calls only complete when provider information changes since the time the call was made It is expected (but not required) that the application uses overlapped I/O on second and subsequent calls to WSAProviderConfigChange, in which case the call will return immediately and application will be notified of provider configuration changes using the completion mechanism chosen through specified overlapped completion parameters.Notification handle returned by WSAProviderConfigChange is like any regular operating system handle that should be closed (when no longer needed) using Windows CloseHandle call.The following sequence of actions can be used to guarantee that application always has current protocol configuration information:CloseHandleWSAEnumNameSpaceProvidersWSAEnumProtocolsWinsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAProviderConfigChange(out nint lpNotificationHandle, WSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPEDCOMPLETIONROUTINE lpCompletionRoutine);

        /// <summary>
        ///The WSARecv function receives data from a connected socket or a bound connectionless socket.
        /// </summary>
        /// <param name="s">A descriptor identifying a connected socket.</param>
        /// <param name="lpBuffers">A pointer to an array of WSABUF structures. Each WSABUF structure contains a pointer to a buffer and the length, in bytes, of the buffer.</param>
        /// <param name="dwBufferCount">The number of WSABUF structures in the lpBuffers array.</param>
        /// <param name="lpNumberOfBytesRecvd"></param>
        /// <param name="lpFlags">A pointer to flags used to modify the behavior of the WSARecv function call. For more information, see the Remarks section.</param>
        /// <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure (ignored for nonoverlapped sockets).</param>
        /// <param name="lpCompletionRoutine">Type: _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINEA pointer to the completion routine called when the receive operation has been completed (ignored for nonoverlapped sockets).If no error occurs and the receive operation has completed immediately, WSARecv returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError. The error code WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.The WSARecv function provides some additional features compared with the standard recv function in three important areas:For connected, connectionless sockets, this function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are (silently) discarded.For overlapped sockets, WSARecv is used to post one or more buffers into which incoming data will be placed as it becomes available, after which the application-specified completion indication (invocation of the completion routine or setting of an event object) occurs. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or WSAGetOverlappedResult.For nonoverlapped sockets, the blocking semantics are identical to that of the standard recv function and the lpOverlapped and lpCompletionRoutine parameters are ignored. Any data that has already been received and buffered by the transport will be copied into the specified user buffers. In the case of a blocking socket with no data currently having been received and buffered by the transport, the call will block until data is received. Windows Sockets 2 does not define any standard blocking time-out mechanism for this function. For protocols acting as byte-stream protocols the stack tries to return as much data as possible subject to the available buffer space and amount of received data available. However, receipt of a single byte is sufficient to unblock the caller. There is no guarantee that more than a single byte will be returned. For protocols acting as message-oriented, a full message is required to unblock the caller.The buffers are filled in the order in which they appear in the array pointed to by lpBuffers, and the buffers are packed so that no holes are created.If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the WSABUF structures before returning from this call. This enables applications to build stack-based WSABUF arrays pointed to by the lpBuffers parameter.For byte stream-style sockets (for example, type SOCK_STREAM), incoming data is placed into the buffers until the buffers are filled, the connection is closed, or the internally buffered data is exhausted. Regardless of whether or not the incoming data fills all the buffers, the completion indication occurs for overlapped sockets.For message-oriented sockets (for example, type SOCK_DGRAM), an incoming message is placed into the buffers up to the total size of the buffers, and the completion indication occurs for overlapped sockets. If the message is larger than the buffers, the buffers are filled with the first part of the message. If the MSG_PARTIAL feature is supported by the underlying service provider, the MSG_PARTIAL flag is set in lpFlags and subsequent receive operations will retrieve the rest of the message. If MSG_PARTIAL is not supported but the protocol is reliable, WSARecv generates the error WSAEMSGSIZE and a subsequent receive operation with a larger buffer can be used to retrieve the entire message. Otherwise, (that is, the protocol is unreliable and does not support MSG_PARTIAL), the excess data is lost, and WSARecv generates the error WSAEMSGSIZE.For connection-oriented sockets, WSARecv can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented. For byte streams, zero bytes having been read (as indicated by a zero return value to indicate success, and lpNumberOfBytesRecvd value of zero) indicates graceful closure and that no more bytes will ever be read. For message-oriented sockets, where a zero byte message is often allowable, a failure with an error code of WSAEDISCON is used to indicate graceful closure. In any case a return error code of WSAECONNRESET indicates an abortive close has occurred.The lpFlags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the lpFlags parameter. The latter is constructed by using the bitwise OR operator with any of the values listed in the following table.For message-oriented sockets, the MSG_PARTIAL bit is set in the lpFlags parameter if a partial message is received. If a complete message is received, MSG_PARTIAL is cleared in lpFlags. In the case of delayed completion, the value pointed to by lpFlags is not updated. When completion has been indicated, the application should call WSAGetOverlappedResult and examine the flags indicated by the lpdwFlags parameter.The WSARecv function using overlapped I/O can be called from within the completion routine of a previous WSARecv, WSARecvFrom, WSASend or WSASendTo function. For a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate WSAOVERLAPPED structure.If the lpCompletionRoutine parameter is NULL, the hEvent parameter of lpOverlapped is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use WSAWaitForMultipleEvents or WSAGetOverlappedResult to wait or poll on the event object.If lpCompletionRoutine is not NULL, the hEvent parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULL lpCompletionRoutine and later calls WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of WSAGetOverlappedResult to TRUE. In this case the usage of the hEvent parameter is undefined, and attempting to wait on the hEvent parameter would produce unpredictable results.The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function WSAWaitForMultipleEvents with the fAlertable parameter set to TRUE is invoked.The prototype of the completion routine is as follows:CompletionRoutine is a placeholder for an application-defined or library-defined function name. The dwError specifies the completion status for the overlapped operation as indicated by lpOverlapped. The cbTransferred parameter specifies the number of bytes received. The dwFlags parameter contains information that would have appeared in lpFlags if the receive operation had completed immediately. This function does not return a value.Returning from this function allows invocation of another pending completion routine for this socket. When using WSAWaitForMultipleEvents, all waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be filled in the same order in which they are specified.If you are using I/O completion ports, be aware that the order of calls made to WSARecv is also the order in which the buffers are populated. WSARecv should not be called on the same socket simultaneously from different threads, because it can result in an unpredictable buffer order.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSABUFWSACloseEventWSACreateEventWSAGetOverlappedResultWSAOVERLAPPEDWSASocketWSAWaitForMultipleEventsWinsock FunctionsWinsock Referencerecv</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSARecv(short s, out string lpBuffers, uint dwBufferCount, out uint lpNumberOfBytesRecvd, out uint lpFlags, WSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPEDCOMPLETIONROUTINE lpCompletionRoutine);

        /// <summary>
        ///The WSARecvDisconnect function terminates reception on a socket, and retrieves the disconnect data if the socket is connection oriented.
        /// </summary>
        /// <param name="s">A descriptor identifying a socket.</param>
        /// <param name="lpInboundDisconnectData"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSARecvDisconnect(short s, out string lpInboundDisconnectData);

        /// <summary>
        ///The WSARecvFrom function receives a datagram and stores the source address.
        /// </summary>
        /// <param name="s">A descriptor identifying a socket.</param>
        /// <param name="lpBuffers">A pointer to an array of WSABUF structures. Each WSABUF structure contains a pointer to a buffer and the length of the buffer.</param>
        /// <param name="dwBufferCount">The number of WSABUF structures in the lpBuffers array.</param>
        /// <param name="lpNumberOfBytesRecvd"></param>
        /// <param name="lpFlags">A pointer to flags used to modify the behavior of the WSARecvFrom function call. See remarks below.</param>
        /// <param name="lpFrom"></param>
        /// <param name="lpFromlen">A pointer to the size, in bytes, of the "from" buffer required only if lpFrom is specified.</param>
        /// <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure (ignored for nonoverlapped sockets).</param>
        /// <param name="lpCompletionRoutine">Type: _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINEA pointer to the completion routine called when the WSARecvFrom operation has been completed (ignored for nonoverlapped sockets).If no error occurs and the receive operation has completed immediately, WSARecvFrom returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError. The error code WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.The WSARecvFrom function provides functionality over and above the standard recvfrom function in three important areas:For overlapped sockets, this function is used to post one or more buffers into which incoming data will be placed as it becomes available on a (possibly connected) socket, after which the application-specified completion indication (invocation of the completion routine or setting of an event object) occurs. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or WSAGetOverlappedResult. Also, the values indicated by lpFrom and lpFromlen are not updated until completion is itself indicated. Applications must not use or disturb these values until they have been updated; therefore the application must not use automatic (that is, stack-based) variables for these parameters.For nonoverlapped sockets, the blocking semantics are identical to that of the standard WSARecv function and the lpOverlapped and lpCompletionRoutine parameters are ignored. Any data that has already been received and buffered by the transport will be copied into the user buffers. For the case of a blocking socket with no data currently having been received and buffered by the transport, the call will block until data is received.The buffers are filled in the order in which they appear in the array indicated by lpBuffers, and the buffers are packed so that no holes are created.If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the WSABUF structures before returning from this call. This enables applications to build stack-based WSABUF arrays pointed to by the lpBuffers parameter.For connectionless socket types, the address from which the data originated is copied to the buffer indicated by lpFrom. The value pointed to by lpFromlen is initialized to the size of this buffer, and is modified on completion to indicate the actual size of the address stored there. As stated previously for overlapped sockets, the lpFrom and lpFromlen parameters are not updated until after the overlapped I/O has completed. The memory pointed to by these parameters must, therefore, remain available to the service provider and cannot be allocated on the application stack frame. The lpFrom and lpFromlen parameters are ignored for connection-oriented sockets.For byte stream–style sockets (for example, type SOCK_STREAM), incoming data is placed into the buffers until:The lpFlags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the lpFlags parameter. The latter is constructed by using the bitwise OR operator with any of any of the values listed in the following table.For message-oriented sockets, the MSG_PARTIAL bit is set in the lpFlags parameter if a partial message is received. If a complete message is received, MSG_PARTIAL is cleared in lpFlags. In the case of delayed completion, the value pointed to by lpFlags is not updated. When completion has been indicated the application should call WSAGetOverlappedResult and examine the flags pointed to by the lpdwFlags parameter.The WSARecvFrom function can be called from within the completion routine of a previous WSARecv, WSARecvFrom, WSASend, or WSASendTo function. For a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate WSAOVERLAPPED structure.If the lpCompletionRoutine parameter is NULL, the hEvent parameter of lpOverlapped is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use WSAWaitForMultipleEvents or WSAGetOverlappedResult to wait or poll on the event object.If lpCompletionRoutine is not NULL, the hEvent parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULL lpCompletionRoutine and later calls WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of WSAGetOverlappedResult to TRUE. In this case the usage of the hEvent parameter is undefined, and attempting to wait on the hEvent parameter would produce unpredictable results.The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function WSAWaitForMultipleEvents with the fAlertable parameter set to TRUE is invoked.If an IO completion port is used and the lpCompletionRoutine parameter and the hEvent parameter are NULL, the result of the operation is schedule on the IO completion port. This happens for all successful operations, whether the operations complete immediately or not.The transport providers allow an application to invoke send and receive operations from within the context of the socket I/O completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.The prototype of the completion routine is as follows.The CompletionRoutine is a placeholder for an application-defined or library-defined function name. The dwError specifies the completion status for the overlapped operation as indicated by lpOverlapped. The cbTransferred specifies the number of bytes received. The dwFlags parameter contains information that would have appeared in lpFlags if the receive operation had completed immediately. This function does not return a value.Returning from this function allows invocation of another pending completion routine for this socket. When using WSAWaitForMultipleEvents, all waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be filled in the same order they are specified.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSABUFWSACloseEventWSACreateEventWSAGetOverlappedResultWSAOVERLAPPEDWSASendWSASendToWSASocketWSAWaitForMultipleEventsWinsock FunctionsWinsock Referencesendto</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSARecvFrom(short s, out string lpBuffers, uint dwBufferCount, out uint lpNumberOfBytesRecvd, out uint lpFlags, out IN_ADDR lpFrom, out int lpFromlen, WSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPEDCOMPLETIONROUTINE lpCompletionRoutine);

        /// <summary>
        ///The WSARemoveServiceClass function permanently removes the service class schema from the registry.
        /// </summary>
        /// <param name="lpServiceClassId">Pointer to the GUID for the service class you want to remove.The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.WSAGetLastErrorWSAStartupWinsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSARemoveServiceClass(nint lpServiceClassId);

        /// <summary>
        ///The WSAResetEvent function resets the state of the specified event object to nonsignaled.
        /// </summary>
        /// <param name="hEvent">A handle that identifies an open event object handle.If the WSAResetEvent function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. To get extended error information, call WSAGetLastError.The WSAResetEvent function is used to set the state of the event object to nonsignaled.The proper way to reset the state of an event object used with the WSAEventSelect function is to pass the handle of the event object to the WSAEnumNetworkEvents function in the hEventObject parameter. This will reset the event object and adjust the status of active FD events on the socket in an atomic fashion.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSACloseEventWSACreateEventWSAEnumNetworkEventsWSAEventSelectWSASetEventWinsock FunctionsWinsock Reference</param>
        /// <remarks>
        /// To get extended error information, call WSAGetLastError.
        /// </remarks>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool WSAResetEvent(SERVENT hEvent);

        /// <summary>
        ///The WSASend function sends data on a connected socket.
        /// </summary>
        /// <param name="s">A descriptor that identifies a connected socket.</param>
        /// <param name="lpBuffers">A pointer to an array of WSABUF structures. Each WSABUF structure contains a pointer to a buffer and the length, in bytes, of the buffer. For a Winsock application, once the WSASend function is called, the system owns these buffers and the application may not access them. This array must remain valid for the duration of the send operation.</param>
        /// <param name="dwBufferCount">The number of WSABUF structures in the lpBuffers array.</param>
        /// <param name="lpNumberOfBytesSent"></param>
        /// <param name="dwFlags">The flags used to modify the behavior of the WSASend function call. For more information, see Using dwFlags in the Remarks section.</param>
        /// <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure. This parameter is ignored for nonoverlapped sockets.</param>
        /// <param name="lpCompletionRoutine">Type: _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINEA pointer to the completion routine called when the send operation has been completed. This parameter is ignored for nonoverlapped sockets.If no error occurs and the send operation has completed immediately, WSASend returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError. The error code WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.The WSASend function provides functionality over and above the standard send function in two important areas:A socket created by the socket function will have the overlapped attribute as the default. A socket created by the WSASocket function with the dwFlags parameter passed to WSASocket with the WSA_FLAG_OVERLAPPED bit set will have the overlapped attribute. For sockets with the overlapped attribute, WSASend uses overlapped I/O unless both the lpOverlapped and lpCompletionRoutine parameters are NULL. In that case, the socket is treated as a non-overlapped socket. A completion indication will occur, invoking the completion of a routine or setting of an event object, when the buffer(s) have been consumed by the transport. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or WSAGetOverlappedResult.If both lpOverlapped and lpCompletionRoutine are NULL, the socket in this function will be treated as a non-overlapped socket.For non-overlapped sockets, the last two parameters (lpOverlapped, lpCompletionRoutine) are ignored and WSASend adopts the same blocking semantics as send. Data is copied from the buffer(s) into the transport's buffer. If the socket is non-blocking and stream-oriented, and there is not sufficient space in the transport's buffer, WSASend will return with only part of the application's buffers having been consumed. Given the same buffer situation and a blocking socket, WSASend will block until all of the application buffer contents have been consumed.For message-oriented sockets, do not exceed the maximum message size of the underlying provider, which can be obtained by getting the value of socket option SO_MAX_MSG_SIZE. If the data is too long to pass atomically through the underlying protocol the error WSAEMSGSIZE is returned, and no data is transmitted.Windows Me/98/95:  The WSASend function does not support more than 16 buffers.The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate WSAOVERLAPPED structure.If the lpCompletionRoutine parameter is NULL, the hEvent parameter of lpOverlapped is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use WSAWaitForMultipleEvents or WSAGetOverlappedResult to wait or poll on the event object.If lpCompletionRoutine is not NULL, the hEvent parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULL lpCompletionRoutine and later calls WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of WSAGetOverlappedResult to TRUE. In this case the usage of the hEvent parameter is undefined, and attempting to wait on the hEvent parameter would produce unpredictable results.The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function WSAWaitForMultipleEvents with the fAlertable parameter set to TRUE is invoked.The transport providers allow an application to invoke send and receive operations from within the context of the socket I/O completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.The following C++ code example is a prototype of the completion routine.The CompletionRoutine function is a placeholder for an application-defined or library-defined function name. The dwError parameter specifies the completion status for the overlapped operation as indicated by lpOverlapped. cbTransferred specifies the number of bytes sent. Currently there are no flag values defined and dwFlags will be zero. This function does not return a value.Returning from this function allows invocation of another pending completion routine for this socket. All waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be sent in the same order they are specified.The order of calls made to WSASend is also the order in which the buffers are transmitted to the transport layer. WSASend should not be called on the same stream-oriented socket concurrently from different threads, because some Winsock providers may split a large send request into multiple transmissions, and this may lead to unintended data interleaving from multiple concurrent send requests on the same stream-oriented socket.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSABUFWSACloseEventWSAConnectWSACreateEventWSAGetOverlappedResultWSAOVERLAPPEDWSASocketWSAWaitForMultipleEventsWinsock FunctionsWinsock Referenceconnectsendsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSASend(short s, string lpBuffers, uint dwBufferCount, out uint lpNumberOfBytesSent, uint dwFlags, WSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPEDCOMPLETIONROUTINE lpCompletionRoutine);

        /// <summary>
        ///The WSASendDisconnect function initiates termination of the connection for the socket and sends disconnect data.
        /// </summary>
        /// <param name="s">Descriptor identifying a socket.</param>
        /// <param name="lpOutboundDisconnectData">A pointer to the outgoing disconnect data.If no error occurs, WSASendDisconnect returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.The WSASendDisconnect function is used on connection-oriented sockets to disable transmission and to initiate termination of the connection along with the transmission of disconnect data, if any. This is equivalent to a shutdown (SD_SEND), except that WSASendDisconnect also allows sending disconnect data (in protocols that support it).After this function has been successfully issued, subsequent sends are disallowed.The lpOutboundDisconnectData parameter, if not NULL, points to a buffer containing the outgoing disconnect data to be sent to the remote party for retrieval by using WSARecvDisconnect.The WSASendDisconnect function does not block regardless of the SO_LINGER setting on the socket.An application should not rely on being able to reuse a socket after calling WSASendDisconnect. In particular, a Windows Sockets provider is not required to support the use of connect/WSAConnect on such a socket.Winsock FunctionsWinsock Referenceconnectsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSASendDisconnect(short s, string lpOutboundDisconnectData);

        /// <summary>
        ///The WSASendMsg function sends data and optional control information from connected and unconnected sockets.
        /// </summary>
        /// <param name="Handle">A descriptor identifying the socket.</param>
        /// <param name="lpMsg">A WSAMSG structure storing the Posix.1g msghdr structure.</param>
        /// <param name="dwFlags">The flags used to modify the behavior of the WSASendMsg function call. For more information, see Using dwFlags in the Remarks section.</param>
        /// <param name="lpNumberOfBytesSent"></param>
        /// <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure. Ignored for non-overlapped sockets.</param>
        /// <param name="lpCompletionRoutine">Type: _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINEA pointer to the completion routine called when the send operation completes. Ignored for non-overlapped sockets.</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSASendMsg(short Handle, nint lpMsg, uint dwFlags, out uint lpNumberOfBytesSent, WSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPEDCOMPLETIONROUTINE lpCompletionRoutine);

        /// <summary>
        ///The WSASendTo function sends data to a specific destination, using overlapped I/O where applicable.
        /// </summary>
        /// <param name="s">A descriptor identifying a (possibly connected) socket.</param>
        /// <param name="lpBuffers">A pointer to an array of WSABUF structures. Each WSABUF structure contains a pointer to a buffer and the length of the buffer, in bytes. For a Winsock application, once the WSASendTo function is called, the system owns these buffers and the application may not access them. This array must remain valid for the duration of the send operation.</param>
        /// <param name="dwBufferCount">The number of WSABUF structures in the lpBuffers array.</param>
        /// <param name="lpNumberOfBytesSent"></param>
        /// <param name="dwFlags">The flags used to modify the behavior of the WSASendTo function call.</param>
        /// <param name="lpTo">An optional pointer to the address of the target socket in the SOCKADDR structure.</param>
        /// <param name="iTolen">The size, in bytes, of the address in the lpTo parameter.</param>
        /// <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure (ignored for nonoverlapped sockets).</param>
        /// <param name="lpCompletionRoutine">Type: _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINEA pointer to the completion routine called when the send operation has been completed (ignored for nonoverlapped sockets).If no error occurs and the send operation has completed immediately, WSASendTo returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError. The error code WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.The WSASendTo function provides enhanced features over the standard sendto function in two important areas:For overlapped sockets (created using WSASocket with flag WSA_FLAG_OVERLAPPED) sending data uses overlapped I/O, unless both lpOverlapped and lpCompletionRoutine are NULL in which case the socket is treated as a nonoverlapped socket. A completion indication will occur (invoking the completion routine or setting of an event object) when the buffer(s) have been consumed by the transport. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or WSAGetOverlappedResult.For nonoverlapped sockets, the last two parameters (lpOverlapped, lpCompletionRoutine) are ignored and WSASendTo adopts the same blocking semantics as send. Data is copied from the buffer(s) into the transport buffer. If the socket is nonblocking and stream oriented, and there is not sufficient space in the transport's buffer, WSASendTo returns with only part of the application's buffers having been consumed. Given the same buffer situation and a blocking socket, WSASendTo will block until all of the application's buffer contents have been consumed.If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the WSABUF structures before returning from this call. This enables applications to build stack-based WSABUF arrays pointed to by the lpBuffers parameter.For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport, which can be obtained by getting the value of socket option SO_MAX_MSG_SIZE. If the data is too long to pass atomically through the underlying protocol the error WSAEMSGSIZE is returned, and no data is transmitted.If the socket is unbound, unique values are assigned to the local association by the system, and the socket is then marked as bound.If the socket is connected, the getsockname function can be used to determine the local IP address and port associated with the socket.If the socket is not connected, the getsockname function can be used to determine the local port number associated with the socket but the IP address returned is set to the wildcard address for the given protocol (for example, INADDR_ANY or "0.0.0.0" for IPv4 and IN6ADDR_ANY_INIT or "::" for IPv6).The successful completion of a WSASendTo does not indicate that the data was successfully delivered.The dwFlags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the dwFlags parameter. The latter is constructed by using the bitwise OR operator with any of any of the values listed in the following table.The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate WSAOVERLAPPED structure.If the lpCompletionRoutine parameter is NULL, the hEvent parameter of lpOverlapped is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use WSAWaitForMultipleEvents or WSAGetOverlappedResult to wait or poll on the event object.If lpCompletionRoutine is not NULL, the hEvent parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULLlpCompletionRoutine and later calls WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of WSAGetOverlappedResult to TRUE. In this case the usage of the hEvent parameter is undefined, and attempting to wait on the hEvent parameter would produce unpredictable results.The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function WSAWaitForMultipleEvents with the fAlertable parameter set to TRUE is invoked.Transport providers allow an application to invoke send and receive operations from within the context of the socket I/O completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.The prototype of the completion routine is as follows.The CompletionRoutine function is a placeholder for an application-defined or library-defined function name. The dwError parameter specifies the completion status for the overlapped operation as indicated by lpOverlapped. The cbTransferred parameter specifies the number of bytes sent. Currently there are no flag values defined and dwFlags will be zero. This function does not return a value.Returning from this function allows invocation of another pending completion routine for this socket. All waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order in which the overlapped operations are completed. However, the posted buffers are guaranteed to be sent in the same order they are specified.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSACloseEventWSACreateEventWSAGetOverlappedResultWSASocketWSAWaitForMultipleEventsWinsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSASendTo(short s, string lpBuffers, uint dwBufferCount, out uint lpNumberOfBytesSent, uint dwFlags, IN_ADDR lpTo, int iTolen, WSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPEDCOMPLETIONROUTINE lpCompletionRoutine);

        /// <summary>
        ///This function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0.
        /// </summary>

        [DllImport("req.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern DLGPROC WSASetBlockingHook(DLGPROC lpBlockFunc);

        /// <summary>
        ///The WSASetEvent function sets the state of the specified event object to signaled.
        /// </summary>
        /// <param name="hEvent">Handle that identifies an open event object.If the function succeeds, the return value is TRUE.If the function fails, the return value is FALSE. To get extended error information, call WSAGetLastError.The WSASetEvent function sets the state of the event object to be signaled.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSACloseEventWSACreateEventWSAResetEventWinsock FunctionsWinsock Reference</param>
        /// <remarks>
        /// To get extended error information, call WSAGetLastError.
        /// </remarks>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool WSASetEvent(SERVENT hEvent);

        /// <summary>
        ///The WSASetLastError function sets the error code that can be retrieved through the WSAGetLastError function.
        /// </summary>
        /// <param name="iError">Integer that specifies the error code to be returned by a subsequent WSAGetLastError call.This function generates no return values.The WSASetLastError function allows an application to set the error code to be returned by a subsequent WSAGetLastError call for the current thread. Note that any subsequent Windows Sockets routine called by the application will override the error code as set by this routine.The error code set by WSASetLastError is different from the error code reset by calling the function getsockopt with SO_ERROR.The Windows Sockets error codes used by this function are listed under Windows Sockets Error Codes.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAGetLastErrorWindows Sockets Error CodesWinsock FunctionsWinsock Referencegetsockopt</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void WSASetLastError(int iError);

        /// <summary>
        ///The WSASetService function registers or removes from the registry a service instance within one or more namespaces.
        /// </summary>
        /// <param name="lpqsRegInfo">A pointer to the service information for registration or deregistration.</param>
        /// <param name="essoperation">A value that determines that operation requested. This parameter can be one of the values from the WSAESETSERVICEOP enumeration type defined in the Winsock2.h header file.</param>
        /// <param name="dwControlFlags">Service install flags value that further controls the operation performed of the WSASetService function. The possible values for this parameter are defined in the Winsock2.h header file.The return value for WSASetService is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.The WSASetService function can be used to affect a specific namespace provider, all providers associated with a specific namespace, or all providers across all namespaces.The available values for essOperation and dwControlFlags combine to control operation of the WSASetService function as shown in the following table.Publishing services to directories, such as Active Directory Services, is restricted based on access control lists (ACLs). For more information, see Security Issues for Service Publication.When the dwControlFlags parameter is set to SERVICE_MULTIPLE, an application can manage its addresses independently. This is useful when the application wants to manage its protocols individually or when the service resides on more than one computer. For instance, when a service uses more than one protocol, it may find that one listening socket aborts but the other sockets remain operational. In this case, the service could remove the aborted address from the registry without affecting the other addresses.When the dwControlFlags parameter is set to SERVICE_MULTIPLE, an application must not let stale addresses remain in the object. This can happen if the application aborts without issuing a DEREGISTER request. When a service registers, it should store its addresses. On its next invocation, the service should explicitly remove these old stale addresses from the registry before registering new addresses.As illustrated in the following, the combination of the dwNameSpace and lpNSProviderId members determine that namespace providers are affected by this function.Windows Phone 8: The WSASetServiceW function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: The WSASetServiceW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.Bluetooth and WSASetServiceWSAGetLastErrorWSAStartupWinsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSASetServiceA(WSAQUERYSETA lpqsRegInfo, WSAVERSION essoperation, uint dwControlFlags);

        /// <summary>
        ///The WSASetService function registers or removes from the registry a service instance within one or more namespaces.
        /// </summary>
        /// <param name="lpqsRegInfo">A pointer to the service information for registration or deregistration.</param>
        /// <param name="essoperation">A value that determines that operation requested. This parameter can be one of the values from the WSAESETSERVICEOP enumeration type defined in the Winsock2.h header file.</param>
        /// <param name="dwControlFlags">Service install flags value that further controls the operation performed of the WSASetService function. The possible values for this parameter are defined in the Winsock2.h header file.The return value for WSASetService is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.The WSASetService function can be used to affect a specific namespace provider, all providers associated with a specific namespace, or all providers across all namespaces.The available values for essOperation and dwControlFlags combine to control operation of the WSASetService function as shown in the following table.Publishing services to directories, such as Active Directory Services, is restricted based on access control lists (ACLs). For more information, see Security Issues for Service Publication.When the dwControlFlags parameter is set to SERVICE_MULTIPLE, an application can manage its addresses independently. This is useful when the application wants to manage its protocols individually or when the service resides on more than one computer. For instance, when a service uses more than one protocol, it may find that one listening socket aborts but the other sockets remain operational. In this case, the service could remove the aborted address from the registry without affecting the other addresses.When the dwControlFlags parameter is set to SERVICE_MULTIPLE, an application must not let stale addresses remain in the object. This can happen if the application aborts without issuing a DEREGISTER request. When a service registers, it should store its addresses. On its next invocation, the service should explicitly remove these old stale addresses from the registry before registering new addresses.As illustrated in the following, the combination of the dwNameSpace and lpNSProviderId members determine that namespace providers are affected by this function.Windows Phone 8: The WSASetServiceW function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: The WSASetServiceW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.Bluetooth and WSASetServiceWSAGetLastErrorWSAStartupWinsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSASetServiceW(WSAQUERYSETW lpqsRegInfo, WSAVERSION essoperation, uint dwControlFlags);

        /// <summary>
        ///The WSASocket function creates a socket that is bound to a specific transport-service provider.
        /// </summary>
        /// <param name="af">The address family specification. Possible values for the address family are defined in the Winsock2.h header file.On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly.The values currently supported are AF_INET or AF_INET6, which are the Internet address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants are identical (for example, AF_INET and PF_INET), so either constant can be used.The table below lists common values for address family although many other values are possible.</param>
        /// <param name="type">The type specification for the new socket.Possible values for the socket type are defined in the Winsock2.h header file.The following table lists the possible values for the type parameter supported for Windows Sockets 2:In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available transport protocol through the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for an address family and use this information when specifying this parameter. Socket type definitions in the Winsock2.h and Ws2def.h header files will be periodically updated as new socket types, address families, and protocols are defined.In Windows Sockets 1.1, the only possible socket types are SOCK_DGRAM and SOCK_STREAM.</param>
        /// <param name="protocol">The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type specified. Possible values for the protocol are defined in the Winsock2.h and Wsrm.h header files.On the Windows SDK released for Windows Vista and later, the organization of header files has changed and this parameter can be one of the values from the IPPROTO enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly.If a value of 0 is specified, the caller does not wish to specify a protocol and the service provider will choose the protocol to use.When the af parameter is AF_INET or AF_INET6 and the type is SOCK_RAW, the value specified for the protocol is set in the protocol field of the IPv6 or IPv4 packet header.The table below lists common values for the protocol although many other values are possible.</param>
        /// <param name="lpProtocolInfo">A pointer to a WSAPROTOCOL_INFO structure that defines the characteristics of the socket to be created. If this parameter is not NULL, the socket will be bound to the provider associated with the indicated WSAPROTOCOL_INFO structure.</param>
        /// <param name="g">An existing socket group ID or an appropriate action to take when creating a new socket and a new socket group.If g is an existing socket group ID, join the new socket to this socket group, provided all the requirements set by this group are met.If g is not an existing socket group ID, then the following values are possible.</param>
        /// <param name="dwFlags">A set of flags used to specify additional socket attributes.A combination of these flags may be set, although some combinations are not allowed.If no error occurs, WSASocket returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling WSAGetLastError.The WSASocket function causes a socket descriptor and any related resources to be allocated and associated with a transport-service provider. Most sockets should be created with the WSA_FLAG_OVERLAPPED attribute set in the dwFlags parameter. A socket created with this attribute supports the use of overlapped I/O operations which provide higher performance. By default, a socket created with the WSASocket function will not have this overlapped attribute set. In contrast, the socket function creates a socket that supports overlapped I/O operations as the default behavior.If the lpProtocolInfo parameter is NULL, Winsock will utilize the first available transport-service provider that supports the requested combination of address family, socket type and protocol specified in the af, type, and protocol parameters.If the lpProtocolInfo parameter is not NULL, the socket will be bound to the provider associated with the indicated WSAPROTOCOL_INFO structure. In this instance, the application can supply the manifest constant FROM_PROTOCOL_INFO as the value for any of af, type, or protocol parameters. This indicates that the corresponding values from the indicated WSAPROTOCOL_INFO structure (iAddressFamily, iSocketType, iProtocol) are to be assumed. In any case, the values specified for af, type, and protocol are passed unmodified to the transport-service provider.When selecting a protocol and its supporting service provider based on af, type, and protocol, this procedure will only choose a base protocol or a protocol chain, not a protocol layer by itself. Unchained protocol layers are not considered to have partial matches on type or af, either. That is, they do not lead to an error code of WSAEAFNOSUPPORT or WSAEPROTONOSUPPORT, if no suitable protocol is found.If a socket is created using the WSASocket function, then the dwFlags parameter must have the WSA_FLAG_OVERLAPPED attribute set for the SO_RCVTIMEO or SO_SNDTIMEO socket options to function properly. Otherwise the timeout never takes effect on the socket.Connection-oriented sockets such as SOCK_STREAM provide full-duplex connections, and must be in a connected state before any data can be sent or received on them. A connection to a specified socket is established with a connect or WSAConnect function call. Once connected, data can be transferred using send/WSASend and recv/WSARecv calls. When a session has been completed, the closesocket function should be called to release the resources associated with the socket. For connection-oriented sockets, the shutdown function should be called to stop data transfer on the socket before calling the closesocket function.The communications protocols used to implement a reliable, connection-oriented socket ensure that data is not lost or duplicated. If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, the connection is considered broken and subsequent calls will fail with the error code set to WSAETIMEDOUT.Connectionless, message-oriented sockets allow sending and receiving of datagrams to and from arbitrary peers using sendto/WSASendTo and recvfrom/WSARecvFrom. If such a socket is connected to a specific peer, datagrams can be sent to that peer using send/WSASend and can be received from (only) this peer using recv/WSARecv.Support for sockets with type SOCK_RAW is not required, but service providers are encouraged to support raw sockets whenever possible.The WSASocket function can be used to create a socket to be used by a service so that if another socket tries to bind to the same port used by the service, an audit record is generated. To enable this option, an application would need to do the following:For more information on ACCESS_SYSTEM_SECURITY, see SACL Access Right and Audit Generation in the Authorization documentation.Applications that need to exchange multimedia streams over the network are an example where being able to establish a specific relationship among a set of sockets could be beneficial. It is up to the transport on how to treat socket groups.The WSASocket and WSAAccept functions can be used to explicitly create and join a socket group when creating a new socket. The socket group ID for a socket can be retrieved by using the getsockopt function with level parameter set to SOL_SOCKET and the optname parameter set to SO_GROUP_ID. A socket group and its associated socket group ID remain valid until the last socket belonging to this socket group is closed. Socket group IDs are unique across all processes for a given service provider. A socket group of zero indicates that the socket is not member of a socket group.The relative group priority of a socket group can be accessed by using the getsockopt function with the level parameter set to SOL_SOCKET and the optname parameter set to SO_GROUP_PRIORITY. The relative group priority of a socket group can be set by using setsockopt with the level parameter set to SOL_SOCKET and the optname parameter set to SO_GROUP_PRIORITY.The Winsock provider included with Windows allows the creation of socket groups and it enforces the SG_CONSTRAINED_GROUP. All sockets in a constrained socket group must be created with the same value for the type and protocol parameters. A constrained socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host. This is the only restriction applied to a socket group by the Winsock provider included with Windows. The socket group priority is not currently used by the Winsock provider or the TCP/IP stack included with Windows.Windows Phone 8: The WSASocketW function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: The WSASocketW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAPROTOCOL_INFOWinsock FunctionsWinsock Referenceacceptbindclosesocketconnectgetsocknamegetsockoptioctlsocketlistenrecvrecvfromselectsendsendtosetsockoptshutdownsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short WSASocketA(int af, int type, int protocol, WSAPROTOCOL_INFOA lpProtocolInfo, short g, uint dwFlags);

        /// <summary>
        ///The WSASocket function creates a socket that is bound to a specific transport-service provider.
        /// </summary>
        /// <param name="af">The address family specification. Possible values for the address family are defined in the Winsock2.h header file.On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly.The values currently supported are AF_INET or AF_INET6, which are the Internet address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants are identical (for example, AF_INET and PF_INET), so either constant can be used.The table below lists common values for address family although many other values are possible.</param>
        /// <param name="type">The type specification for the new socket.Possible values for the socket type are defined in the Winsock2.h header file.The following table lists the possible values for the type parameter supported for Windows Sockets 2:In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available transport protocol through the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for an address family and use this information when specifying this parameter. Socket type definitions in the Winsock2.h and Ws2def.h header files will be periodically updated as new socket types, address families, and protocols are defined.In Windows Sockets 1.1, the only possible socket types are SOCK_DGRAM and SOCK_STREAM.</param>
        /// <param name="protocol">The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type specified. Possible values for the protocol are defined are defined in the Winsock2.h and Wsrm.h header files.On the Windows SDK released for Windows Vista and later,, the organization of header files has changed and this parameter can be one of the values from the IPPROTO enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly.If a value of 0 is specified, the caller does not wish to specify a protocol and the service provider will choose the protocol to use.When the af parameter is AF_INET or AF_INET6 and the type is SOCK_RAW, the value specified for the protocol is set in the protocol field of the IPv6 or IPv4 packet header.The table below lists common values for the protocol although many other values are possible.</param>
        /// <param name="lpProtocolInfo">A pointer to a WSAPROTOCOL_INFO structure that defines the characteristics of the socket to be created. If this parameter is not NULL, the socket will be bound to the provider associated with the indicated WSAPROTOCOL_INFO structure.</param>
        /// <param name="g">An existing socket group ID or an appropriate action to take when creating a new socket and a new socket group.If g is an existing socket group ID, join the new socket to this socket group, provided all the requirements set by this group are met.If g is not an existing socket group ID, then the following values are possible.</param>
        /// <param name="dwFlags">A set of flags used to specify additional socket attributes.A combination of these flags may be set, although some combinations are not allowed.If no error occurs, WSASocket returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling WSAGetLastError.The WSASocket function causes a socket descriptor and any related resources to be allocated and associated with a transport-service provider. Most sockets should be created with the WSA_FLAG_OVERLAPPED attribute set in the dwFlags parameter. A socket created with this attribute supports the use of overlapped I/O operations which provide higher performance. By default, a socket created with the WSASocket function will not have this overlapped attribute set. In contrast, the socket function creates a socket that supports overlapped I/O operations as the default behavior.If the lpProtocolInfo parameter is NULL, Winsock will utilize the first available transport-service provider that supports the requested combination of address family, socket type and protocol specified in the af, type, and protocol parameters.If the lpProtocolInfo parameter is not NULL, the socket will be bound to the provider associated with the indicated WSAPROTOCOL_INFO structure. In this instance, the application can supply the manifest constant FROM_PROTOCOL_INFO as the value for any of af, type, or protocol parameters. This indicates that the corresponding values from the indicated WSAPROTOCOL_INFO structure (iAddressFamily, iSocketType, iProtocol) are to be assumed. In any case, the values specified for af, type, and protocol are passed unmodified to the transport-service provider.When selecting a protocol and its supporting service provider based on af, type, and protocol, this procedure will only choose a base protocol or a protocol chain, not a protocol layer by itself. Unchained protocol layers are not considered to have partial matches on type or af, either. That is, they do not lead to an error code of WSAEAFNOSUPPORT or WSAEPROTONOSUPPORT, if no suitable protocol is found.If a socket is created using the WSASocket function, then the dwFlags parameter must have the WSA_FLAG_OVERLAPPED attribute set for the SO_RCVTIMEO or SO_SNDTIMEO socket options to function properly. Otherwise the timeout never takes effect on the socket.Connection-oriented sockets such as SOCK_STREAM provide full-duplex connections, and must be in a connected state before any data can be sent or received on them. A connection to a specified socket is established with a connect or WSAConnect function call. Once connected, data can be transferred using send/WSASend and recv/WSARecv calls. When a session has been completed, the closesocket function should be called to release the resources associated with the socket. For connection-oriented sockets, the shutdown function should be called to stop data transfer on the socket before calling the closesocket function.The communications protocols used to implement a reliable, connection-oriented socket ensure that data is not lost or duplicated. If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, the connection is considered broken and subsequent calls will fail with the error code set to WSAETIMEDOUT.Connectionless, message-oriented sockets allow sending and receiving of datagrams to and from arbitrary peers using sendto/WSASendTo and recvfrom/WSARecvFrom. If such a socket is connected to a specific peer, datagrams can be sent to that peer using send/WSASend and can be received from (only) this peer using recv/WSARecv.Support for sockets with type SOCK_RAW is not required, but service providers are encouraged to support raw sockets whenever possible.The WSASocket function can be used to create a socket to be used by a service so that if another socket tries to bind to the same port used by the service, and audit record is generated. To enable this option, an application would need to do the following:For more information on ACCESS_SYSTEM_SECURITY, see SACL Access Right and Audit Generation in the Authorization documentation.Applications that need to exchange multimedia streams over the network are an example where being able to establish a specific relationship among a set of sockets could be beneficial. It is up to the transport on how to treat socket groups.The WSASocket and WSAAccept functions can be used to explicitly create and join a socket group when creating a new socket. The socket group ID for a socket can be retrieved by using the getsockopt function with level parameter set to SOL_SOCKET and the optname parameter set to SO_GROUP_ID. A socket group and its associated socket group ID remain valid until the last socket belonging to this socket group is closed. Socket group IDs are unique across all processes for a given service provider. A socket group of zero indicates that the socket is not member of a socket group.The relative group priority of a socket group can be accessed by using the getsockopt function with the level parameter set to SOL_SOCKET and the optname parameter set to SO_GROUP_PRIORITY. The relative group priority of a socket group can be set by using setsockopt with the level parameter set to SOL_SOCKET and the optname parameter set to SO_GROUP_PRIORITY.The Winsock provider included with Windows allows the creation of socket groups and it enforces the SG_CONSTRAINED_GROUP. All sockets in a constrained socket group must be created with the same value for the type and protocol parameters. A constrained socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host. This is the only restriction applied to a socket group by the Winsock provider included with Windows. The socket group priority is not currently used by the Winsock provider or the TCP/IP stack included with Windows.Windows Phone 8: The WSASocketW function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: The WSASocketW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.WSAPROTOCOL_INFOWinsock FunctionsWinsock Referenceacceptbindclosesocketconnectgetsocknamegetsockoptioctlsocketlistenrecvrecvfromselectsendsendtosetsockoptshutdownsocket</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short WSASocketW(int af, int type, int protocol, WSAPROTOCOL_INFOW lpProtocolInfo, short g, uint dwFlags);

        /// <summary>
        ///The WSAStartup function initiates use of the Winsock DLL by a process.
        /// </summary>
        /// <param name="wVersionRequested">The highest version of Windows Sockets specification that the caller can use. The high-order byte specifies the minor version number; the low-order byte specifies the major version number.</param>
        /// <param name="lpWSAData"></param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAStartup(short wVersionRequested, out WSADATA lpWSAData);

        /// <summary>
        ///The WSAStringToAddress function converts a network address in its standard text presentation form into its numeric binary form in a sockaddr structure, suitable for passing to Windows Sockets routines that take such a structure.
        /// </summary>
        /// <param name="AddressString">A pointer to the zero-terminated string that contains the network address in standard text form to convert.</param>
        /// <param name="AddressFamily">The address family of the network address pointed to by the AddressString parameter.</param>
        /// <param name="lpProtocolInfo"></param>
        /// <param name="lpAddress"></param>
        /// <param name="lpAddressLength">A pointer to the length, in bytes, of the buffer pointed to by the lpAddress parameter. If the function call is successful, this parameter returns a pointer to the size of the sockaddr structure returned in the lpAddress parameter. If the specified buffer is not large enough, the function fails with a specific error of WSAEFAULT and this parameter is updated with the required size in bytes.The return value for WSAStringToAddress is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.The WSAStringToAddress function converts a network address in standard text form into its numeric binary form in a sockaddr structure.Any missing components of the address will be defaulted to a reasonable value, if possible. For example, a missing port number will default to zero. If the caller wants the translation to be done by a particular provider, it should supply the corresponding WSAPROTOCOL_INFO structure in the lpProtocolInfo parameter.The WSAStringToAddress function fails (and returns WSAEINVAL) if the sin_family member of the SOCKADDR_IN structure, which is passed in the lpAddress parameter in the form of a sockaddr structure, is not set to AF_INET or AF_INET6.Support for IPv6 addresses using the WSAStringToAddress function was added on Windows XP with Service Pack 1 (SP1)and later. IPv6 must also be installed on the local computer for the WSAStringToAddress function to support IPv6 addresses.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.InetNtopInetPtonRtlIpv4AddressToStringRtlIpv4AddressToStringExRtlIpv4StringToAddressRtlIpv4StringToAddressExRtlIpv6AddressToStringRtlIpv6AddressToStringExRtlIpv6StringToAddressRtlIpv6StringToAddressExWSAAddressToStringWSAPROTOCOL_INFOWSAStartupinet_addrinet_ntoasockaddr</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAStringToAddressA(string AddressString, int AddressFamily, WSAPROTOCOL_INFOA lpProtocolInfo, out string lpAddress, out int lpAddressLength);

        /// <summary>
        ///The WSAStringToAddress function converts a network address in its standard text presentation form into its numeric binary form in a sockaddr structure, suitable for passing to Windows Sockets routines that take such a structure.
        /// </summary>
        /// <param name="AddressString">A pointer to the zero-terminated string that contains the network address in standard text form to convert.</param>
        /// <param name="AddressFamily">The address family of the network address pointed to by the AddressString parameter.</param>
        /// <param name="lpProtocolInfo"></param>
        /// <param name="lpAddress"></param>
        /// <param name="lpAddressLength">A pointer to the length, in bytes, of the buffer pointed to by the lpAddress parameter. If the function call is successful, this parameter returns a pointer to the size of the sockaddr structure returned in the lpAddress parameter. If the specified buffer is not large enough, the function fails with a specific error of WSAEFAULT and this parameter is updated with the required size in bytes.The return value for WSAStringToAddress is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.The WSAStringToAddress function converts a network address in standard text form into its numeric binary form in a sockaddr structure.Any missing components of the address will be defaulted to a reasonable value, if possible. For example, a missing port number will default to zero. If the caller wants the translation to be done by a particular provider, it should supply the corresponding WSAPROTOCOL_INFO structure in the lpProtocolInfo parameter.The WSAStringToAddress function fails (and returns WSAEINVAL) if the sin_family member of the SOCKADDR_IN structure, which is passed in the lpAddress parameter in the form of a sockaddr structure, is not set to AF_INET or AF_INET6.Support for IPv6 addresses using the WSAStringToAddress function was added on Windows XP with Service Pack 1 (SP1)and later. IPv6 must also be installed on the local computer for the WSAStringToAddress function to support IPv6 addresses.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.InetNtopInetPtonRtlIpv4AddressToStringRtlIpv4AddressToStringExRtlIpv4StringToAddressRtlIpv4StringToAddressExRtlIpv6AddressToStringRtlIpv6AddressToStringExRtlIpv6StringToAddressRtlIpv6StringToAddressExWSAAddressToStringWSAPROTOCOL_INFOWSAStartupinet_addrinet_ntoasockaddr</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAStringToAddressW(string AddressString, int AddressFamily, WSAPROTOCOL_INFOW lpProtocolInfo, out string lpAddress, out int lpAddressLength);

        /// <summary>
        ///This function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0.
        /// </summary>

        [DllImport("req.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int WSAUnhookBlockingHook();

        /// <summary>
        ///The WSAWaitForMultipleEvents function returns when one or all of the specified event objects are in the signaled state, when the time-out interval expires, or when an I/O completion routine has executed.
        /// </summary>
        /// <param name="cEvents">The number of event object handles in the array pointed to by lphEvents. The maximum number of event object handles is WSA_MAXIMUM_WAIT_EVENTS. One or more events must be specified.</param>
        /// <param name="lphEvents">A pointer to an array of event object handles. The array can contain handles of objects of different types. It may not contain multiple copies of the same handle if the fWaitAll parameter is set to TRUE. If one of these handles is closed while the wait is still pending, the behavior of WSAWaitForMultipleEvents is undefined.The handles must have the SYNCHRONIZE access right. For more information, see Standard Access Rights.</param>
        /// <param name="fWaitAll">A value that specifies the wait type. If TRUE, the function returns when the state of all objects in the lphEvents array is signaled. If FALSE, the function returns when any of the event objects is signaled. In the latter case, the return value minus WSA_WAIT_EVENT_0 indicates the index of the event object whose state caused the function to return. If more than one event object became signaled during the call, this is the array index to the signaled event object with the smallest index value of all the signaled event objects.</param>
        /// <param name="dwTimeout">The time-out interval, in milliseconds. WSAWaitForMultipleEvents returns if the time-out interval expires, even if conditions specified by the fWaitAll parameter are not satisfied. If the dwTimeout parameter is zero, WSAWaitForMultipleEvents tests the state of the specified event objects and returns immediately. If dwTimeout is WSA_INFINITE, WSAWaitForMultipleEvents waits forever; that is, the time-out interval never expires.</param>
        /// <param name="fAlertable">A value that specifies whether the thread is placed in an alertable wait state so the system can execute I/O completion routines. If TRUE, the thread is placed in an alertable wait state and WSAWaitForMultipleEvents can return when the system executes an I/O completion routine. In this case, WSA_WAIT_IO_COMPLETION is returned and the event that was being waited on is not signaled yet. The application must call the WSAWaitForMultipleEvents function again. If FALSE, the thread is not placed in an alertable wait state and I/O completion routines are not executed.If the WSAWaitForMultipleEvents function succeeds, the return value upon success is one of the following values.If the WSAWaitForMultipleEvents function fails, the return value is WSA_WAIT_FAILED. The following table lists values that can be used with WSAGetLastError to get extended error information.The WSAWaitForMultipleEvents function determines whether the wait criteria have been met. If the criteria have not been met, the calling thread enters the wait state. It uses no processor time while waiting for the criteria to be met.The WSAWaitForMultipleEvents function returns when any one or all of the specified objects are in the signaled state, or when the time-out interval elapses.When the bWaitAll parameter is TRUE, the wait operation is completed only when the states of all objects have been set to signaled. The function does not modify the states of the specified objects until the states of all objects have been set to signaled.When bWaitAll parameter is FALSE, WSAWaitForMultipleEvents checks the handles in the lphEvents array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the lphEvents array whose object was signaled.This function is also used to perform an alertable wait by setting the fAlertable parameter to TRUE. This enables the function to return when the system executes an I/O completion routine by the calling thread.A thread must be in an alertable wait state in order for the system to execute I/O completion routines (asynchronous procedure calls or APCs). So if an application calls WSAWaitForMultipleEvents when there are pending asynchronous operations that have I/O completion routines and the fAlertable parameter is FALSE, then those I/O completion routines will not be executed even if those I/O operations are completed.If the fAlertable parameter is TRUE and one of the pending operations completes, the APC is executed and WSAWaitForMultipleEvents will return WSA_IO_COMPLETION. The pending event is not signaled yet. The application must call the WSAWaitForMultipleEvents function again.Applications that require an alertable wait state without waiting for any event objects to be signaled should use the Windows SleepEx function.The current implementation of WSAWaitForMultipleEvents calls the WaitForMultipleObjectsEx function.Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later.Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.Standard Access RightsWSACloseEventWSACreateEventWaitForMultipleObjectsExWinsock FunctionsWinsock Reference</param>

        [DllImport("32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint WSAWaitForMultipleEvents(uint cEvents, SERVENT lphEvents, bool fWaitAll, uint dwTimeout, bool fAlertable);


    }
}