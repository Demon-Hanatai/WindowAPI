using WindowAPI.winuser.Enums;
using WindowAPI.winuser.Structures;

namespace WindowAPI.winuser
{
    public static class Functions
    {

        /// <summary>
        ///Sets the input locale identifier (formerly called the keyboard layout handle) for the calling thread or the current process. The input locale identifier specifies a locale as well as the physical layout of the keyboard.
        /// </summary>
        /// <param name="hkl">Type: HKLInput locale identifier to be activated.The input locale identifier must have been loaded by a previous call to the LoadKeyboardLayout function. This parameter must be either the handle to a keyboard layout or one of the following values.</param>
        /// <param name="Flags">Type: UINTSpecifies how the input locale identifier is to be activated. This parameter can be one of the following values.Type: HKLThe return value is of type HKL. If the function succeeds, the return value is the previous input locale identifier. Otherwise, it is zero.To get extended error information, use the GetLastError function.This function only affects the layout for the current process or thread.This function is not restricted to keyboard layouts. The hkl parameter is actually an input locale identifier. This is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input. Several input locale identifiers can be loaded at any one time, but only one is active at a time. Loading multiple input locale identifiers makes it possible to rapidly switch between them.When multiple IMEs are allowed for each locale, passing an input locale identifier in which the high word (the device handle) is zero activates the first IME in the list belonging to the locale.The KLF_RESET and KLF_SHIFTLOCK flags alter the method by which the Caps Lock state is turned off. By default, the Caps Lock state is turned off by hitting the Caps Lock key again. If only KLF_RESET is set, the default state is reestablished. If KLF_RESET and KLF_SHIFTLOCK are set, the Caps Lock state is turned off by pressing either Caps Lock key. This feature is used to conform to local keyboard behavior standards as well as for personal preferences.ConceptualGetKeyboardLayoutNameKeyboard InputLoadKeyboardLayoutReferenceUnloadKeyboardLayout</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint ActivateKeyboardLayout(nint hkl, uint Flags);

        /// <summary>
        ///Places the given window in the system-maintained clipboard format listener list.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window to be placed in the clipboard format listener list.Type: BOOL</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool AddClipboardFormatListener(nint hwnd);

        /// <summary>
        ///Calculates the required size of the window rectangle, based on the desired client-rectangle size. The window rectangle can then be passed to the CreateWindow function to create a window whose client area is the desired size.
        /// </summary>
        /// <param name="lpRect">Type: LPRECTA pointer to a RECT structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area.</param>
        /// <param name="dwStyle">Type: DWORDThe window style of the window whose required size is to be calculated. Note that you cannot specify the WS_OVERLAPPED style.</param>
        /// <param name="bMenu">Type: BOOLIndicates whether the window has a menu.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.A client rectangle is the smallest rectangle that completely encloses a client area. A window rectangle is the smallest rectangle that completely encloses the window, which includes the client area and the nonclient area.The AdjustWindowRect function does not add extra space when a menu bar wraps to two or more rows.The AdjustWindowRect function does not take the WS_VSCROLL or WS_HSCROLL styles into account. To account for the scroll bars, call the GetSystemMetrics function with SM_CXVSCROLL or SM_CYHSCROLL.AdjustWindowRectExConceptualCreateWindowGetSystemMetricsOther ResourcesRECTReferenceWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool AdjustWindowRect(out RECT lpRect, uint dwStyle, bool bMenu);

        /// <summary>
        ///Calculates the required size of the window rectangle, based on the desired size of the client rectangle. The window rectangle can then be passed to the CreateWindowEx function to create a window whose client area is the desired size.
        /// </summary>
        /// <param name="lpRect">Type: LPRECTA pointer to a RECT structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area.</param>
        /// <param name="dwStyle">Type: DWORDThe window style of the window whose required size is to be calculated. Note that you cannot specify the WS_OVERLAPPED style.</param>
        /// <param name="bMenu">Type: BOOLIndicates whether the window has a menu.</param>
        /// <param name="dwExStyle">Type: DWORDThe extended window style of the window whose required size is to be calculated.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.A client rectangle is the smallest rectangle that completely encloses a client area. A window rectangle is the smallest rectangle that completely encloses the window, which includes the client area and the nonclient area.The AdjustWindowRectEx function does not add extra space when a menu bar wraps to two or more rows.The AdjustWindowRectEx function does not take the WS_VSCROLL or WS_HSCROLL styles into account. To account for the scroll bars, call the GetSystemMetrics function with SM_CXVSCROLL or SM_CYHSCROLL.This API is not DPI aware, and should not be used if the calling thread is per-monitor DPI aware. For the DPI-aware version of this API, see AdjustWindowsRectExForDPI. For more information on DPI awareness, see the Windows High DPI documentation.AdjustWindowsRectExForDPIConceptualCreateWindowExOther ResourcesRECTReferenceWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool AdjustWindowRectEx(out RECT lpRect, uint dwStyle, bool bMenu, uint dwExStyle);

        /// <summary>
        ///Calculates the required size of the window rectangle, based on the desired size of the client rectangle and the provided DPI. This window rectangle can then be passed to the CreateWindowEx function to create a window with a client area of the desired size.
        /// </summary>
        /// <param name="lpRect">A pointer to a RECT structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area.</param>
        /// <param name="dwStyle">The Window Style of the window whose required size is to be calculated. Note that you cannot specify the WS_OVERLAPPED style.</param>
        /// <param name="bMenu">Indicates whether the window has a menu.</param>
        /// <param name="dwExStyle">The Extended Window Style of the window whose required size is to be calculated.</param>
        /// <param name="dpi">The DPI to use for scaling.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.This function returns the same result as AdjustWindowRectEx but scales it according to an arbitrary DPI you provide if appropriate.</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool AdjustWindowRectExForDpi(out RECT lpRect, uint dwStyle, bool bMenu, uint dwExStyle, uint dpi);

        /// <summary>
        ///Enables the specified process to set the foreground window using the SetForegroundWindow function. The calling process must already be able to set the foreground window. For more information, see Remarks later in this topic.
        /// </summary>
        /// <param name="dwProcessId">Type: DWORDThe identifier of the process that will be enabled to set the foreground window. If this parameter is ASFW_ANY, all processes will be enabled to set the foreground window.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. The function will fail if the calling process cannot set the foreground window. To get extended error information, call GetLastError.The system restricts which processes can set the foreground window. Normally, a process can set the foreground window by calling the SetForegroundWindow function only if:A process that can set the foreground window can enable another process to set the foreground window by calling AllowSetForegroundWindow. The process specified by the dwProcessId parameter loses the ability to set the foreground window the next time that either the user generates input, unless the input is directed at that process, or the next time a process calls AllowSetForegroundWindow, unless the same process is specified as in the previous call to AllowSetForegroundWindow.ConceptualLockSetForegroundWindowReferenceSetForegroundWindowWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool AllowSetForegroundWindow(uint dwProcessId);

        /// <summary>
        ///Enables you to produce special effects when showing or hiding windows. There are four types of animation: roll, slide, collapse or expand, and alpha-blended fade.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to animate. The calling thread must own this window.</param>
        /// <param name="dwTime">Type: DWORDThe time it takes to play the animation, in milliseconds. Typically, an animation takes 200 milliseconds to play.</param>
        /// <param name="dwFlags">Type: DWORDThe type of animation. This parameter can be one or more of the following values. Note that, by default, these flags take effect when showing a window. To take effect when hiding a window, use AW_HIDE and a logical OR operator with the appropriate flags.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. The function will fail in the following situations:To show or hide a window without special effects, use ShowWindow.When using slide or roll animation, you must specify the direction. It can be either AW_HOR_POSITIVE, AW_HOR_NEGATIVE, AW_VER_POSITIVE, or AW_VER_NEGATIVE.You can combine AW_HOR_POSITIVE or AW_HOR_NEGATIVE with AW_VER_POSITIVE or AW_VER_NEGATIVE to animate a window diagonally.The window procedures for the window and its child windows should handle any WM_PRINT or WM_PRINTCLIENT messages. Dialog boxes, controls, and common controls already handle WM_PRINTCLIENT. The default window procedure already handles WM_PRINT.If a child window is displayed partially clipped, when it is animated it will have holes where it is clipped.AnimateWindow supports RTL windows.Avoid animating a window that has a drop shadow because it produces visually distracting, jerky animations.ConceptualOther ResourcesReferenceShowWindowWM_PRINTWM_PRINTCLIENTWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool AnimateWindow(nint hWnd, uint dwTime, uint dwFlags);

        /// <summary>
        ///Indicates whether an owned, visible, top-level pop-up, or overlapped window exists on the screen. The function searches the entire screen, not just the calling application's client area.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool AnyPopup();

        /// <summary>
        ///Appends a new item to the end of the specified menu bar, drop-down menu, submenu, or shortcut menu. You can use this function to specify the content, appearance, and behavior of the menu item.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu bar, drop-down menu, submenu, or shortcut menu to be changed.</param>
        /// <param name="uFlags">Type: UINTControls the appearance and behavior of the new menu item. This parameter can be a combination of the following values.</param>
        /// <param name="uIDNewItem">Type: UINT_PTRThe identifier of the new menu item or, if the uFlags parameter is set to MF_POPUP, a handle to the drop-down menu or submenu.</param>
        /// <param name="lpNewItem"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool AppendMenuA(nint hMenu, uint uFlags, nint uIDNewItem, string lpNewItem);

        /// <summary>
        ///Appends a new item to the end of the specified menu bar, drop-down menu, submenu, or shortcut menu. You can use this function to specify the content, appearance, and behavior of the menu item.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu bar, drop-down menu, submenu, or shortcut menu to be changed.</param>
        /// <param name="uFlags">Type: UINTControls the appearance and behavior of the new menu item. This parameter can be a combination of the following values.</param>
        /// <param name="uIDNewItem">Type: UINT_PTRThe identifier of the new menu item or, if the uFlags parameter is set to MF_POPUP, a handle to the drop-down menu or submenu.</param>
        /// <param name="lpNewItem"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool AppendMenuW(nint hMenu, uint uFlags, nint uIDNewItem, string lpNewItem);

        /// <summary>
        ///Determines whether two DPI_AWARENESS_CONTEXT values are identical.
        /// </summary>
        /// <param name="dpiContextA">The first value to compare.</param>
        /// <param name="dpiContextB">The second value to compare.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool AreDpiAwarenessContextsEqual(DPI_AWARENESS dpiContextA, DPI_AWARENESS dpiContextB);

        /// <summary>
        ///Arranges all the minimized (iconic) child windows of the specified parent window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the parent window.Type: UINTIf the function succeeds, the return value is the height of one row of icons.If the function fails, the return value is zero. To get extended error information, call GetLastError.An application that maintains its own minimized child windows can use the ArrangeIconicWindows function to arrange icons in a parent window. This function can also arrange icons on the desktop. To retrieve the window handle to the desktop window, use the GetDesktopWindow function.An application sends the WM_MDIICONARRANGE message to the multiple-document interface (MDI) client window to prompt the client window to arrange its minimized MDI child windows.CloseWindowConceptualGetDesktopWindowReferenceWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint ArrangeIconicWindows(nint hWnd);

        /// <summary>
        ///Attaches or detaches the input processing mechanism of one thread to that of another thread.
        /// </summary>
        /// <param name="idAttach">The identifier of the thread to be attached to another thread. The thread to be attached cannot be a system thread.</param>
        /// <param name="idAttachTo">The identifier of the thread to which idAttach will be attached. This thread cannot be a system thread.A thread cannot attach to itself. Therefore, idAttachTo cannot equal idAttach.</param>
        /// <param name="fAttach">If this parameter is TRUE, the two threads are attached. If the parameter is FALSE, the threads are detached.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Windows Server 2003 and Windows XP:  There is no extended error information; do not call GetLastError. This behavior changed as of Windows Vista.By using the AttachThreadInput function, a thread can share its input states (such as keyboard states and the current focus window) with another thread. Keyboard and mouse events received by both threads are processed in the order they were received until the threads are detached by calling AttachThreadInput a second time and specifying FALSE for the fAttach parameter.The AttachThreadInput function fails if either of the specified threads does not have a message queue. The system creates a thread's message queue when the thread makes its first call to one of the USER or GDI functions. The AttachThreadInput function also fails if a journal record hook is installed. Journal record hooks attach all input queues together.Note that key state, which can be ascertained by calls to the GetKeyState or GetKeyboardState function, is reset after a call to AttachThreadInput. You cannot attach a thread to a thread in another desktop.GetCurrentThreadIdGetKeyStateGetKeyboardStateGetWindowThreadProcessIdProcess and Thread FunctionsSetFocusThreads</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool AttachThreadInput(uint idAttach, uint idAttachTo, bool fAttach);

        /// <summary>
        ///Allocates memory for a multiple-window- position structure and returns the handle to the structure.
        /// </summary>
        /// <param name="nNumWindows">Type: intThe initial number of windows for which to store position information. The DeferWindowPos function increases the size of the structure, if necessary.Type: HDWPIf the function succeeds, the return value identifies the multiple-window-position structure. If insufficient system resources are available to allocate the structure, the return value is NULL. To get extended error information, call GetLastError.The multiple-window-position structure is an internal structure; an application cannot access it directly.DeferWindowPos fills the multiple-window-position structure with information about the target position for one or more windows about to be moved. The EndDeferWindowPos function accepts the handle to this structure and repositions the windows by using the information stored in the structure.If the system must increase the size of the multiple-window- position structure beyond the initial size specified by the nNumWindows parameter but cannot allocate enough memory to do so, the system fails the entire window positioning sequence (BeginDeferWindowPos, DeferWindowPos, and EndDeferWindowPos). By specifying the maximum size needed, an application can detect and process failure early in the process.ConceptualDeferWindowPosEndDeferWindowPosReferenceSetWindowPosWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint BeginDeferWindowPos(int nNumWindows);

        /// <summary>
        ///The BeginPaint function prepares the specified window for painting and fills a PAINTSTRUCT structure with information about the painting.
        /// </summary>
        /// <param name="hWnd">Handle to the window to be repainted.</param>
        /// <param name="lpPaint"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint BeginPaint(nint hWnd, out PAINTSTRUCT lpPaint);

        /// <summary>
        ///Blocks keyboard and mouse input events from reaching applications.
        /// </summary>
        /// <param name="fBlockIt">Type: BOOLThe function's purpose. If this parameter is TRUE, keyboard and mouse input events are blocked. If this parameter is FALSE, keyboard and mouse events are unblocked. Note that only the thread that blocked input can successfully unblock input.Type: BOOLIf the function succeeds, the return value is nonzero.If input is already blocked, the return value is zero. To get extended error information, call GetLastError.When input is blocked, real physical input from the mouse or keyboard will not affect the input queue's synchronous key state (reported by GetKeyState and GetKeyboardState), nor will it affect the asynchronous key state (reported by GetAsyncKeyState). However, the thread that is blocking input can affect both of these key states by calling SendInput. No other thread can do this.The system will unblock input in the following cases:ConceptualGetAsyncKeyStateGetKeyStateGetKeyboardStateKeyboard InputReferenceSendInput</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool BlockInput(bool fBlockIt);

        /// <summary>
        ///Brings the specified window to the top of the Z order. If the window is a top-level window, it is activated. If the window is a child window, the top-level parent window associated with the child window is activated.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to bring to the top of the Z order.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Use the BringWindowToTop function to uncover any window that is partially or completely obscured by other windows.Calling this function is similar to calling the SetWindowPos function to change a window's position in the Z order. BringWindowToTop does not make a window a top-level window.ConceptualReferenceSetWindowPosWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool BringWindowToTop(nint hWnd);

        /// <summary>
        ///Sends a message to the specified recipients. The recipients can be applications, installable drivers, network drivers, system-level device drivers, or any combination of these system components.
        /// </summary>
        /// <param name="flags">Type: DWORDThe broadcast option. This parameter can be one or more of the following values.</param>
        /// <param name="lpInfo"></param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: longIf the function succeeds, the return value is a positive value.If the function is unable to broadcast the message, the return value is –1.If the dwFlags parameter is BSF_QUERY and at least one recipient returned BROADCAST_QUERY_DENY to the corresponding message, the return value is zero. To get extended error information, call GetLastError.If BSF_QUERY is not specified, the function sends the specified message to all requested recipients, ignoring values returned by those recipients.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.For an example, see Terminating a Process.BroadcastSystemMessageExConceptualMessages and Message QueuesReferenceSendNotifyMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int BroadcastSystemMessage(uint flags, out uint lpInfo, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Sends a message to the specified recipients. The recipients can be applications, installable drivers, network drivers, system-level device drivers, or any combination of these system components.
        /// </summary>
        /// <param name="flags">Type: DWORDThe broadcast option. This parameter can be one or more of the following values.</param>
        /// <param name="lpInfo"></param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: longIf the function succeeds, the return value is a positive value.If the function is unable to broadcast the message, the return value is –1.If the dwFlags parameter is BSF_QUERY and at least one recipient returned BROADCAST_QUERY_DENY to the corresponding message, the return value is zero. To get extended error information, call GetLastError.If BSF_QUERY is not specified, the function sends the specified message to all requested recipients, ignoring values returned by those recipients.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.For an example, see Terminating a Process.BroadcastSystemMessageExConceptualMessages and Message QueuesReferenceSendNotifyMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int BroadcastSystemMessageA(uint flags, out uint lpInfo, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Sends a message to the specified recipients. The recipients can be applications, installable drivers, network drivers, system-level device drivers, or any combination of these system components.
        /// </summary>
        /// <param name="flags">Type: DWORDThe broadcast option. This parameter can be one or more of the following values.</param>
        /// <param name="lpInfo"></param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.</param>
        /// <param name="pbsmInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int BroadcastSystemMessageExA(uint flags, out uint lpInfo, uint Msg, nint wParam, nint lParam, out BSMINFO pbsmInfo);

        /// <summary>
        ///Sends a message to the specified recipients. The recipients can be applications, installable drivers, network drivers, system-level device drivers, or any combination of these system components.
        /// </summary>
        /// <param name="flags">Type: DWORDThe broadcast option. This parameter can be one or more of the following values.</param>
        /// <param name="lpInfo"></param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.</param>
        /// <param name="pbsmInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int BroadcastSystemMessageExW(uint flags, out uint lpInfo, uint Msg, nint wParam, nint lParam, out BSMINFO pbsmInfo);

        /// <summary>
        ///Sends a message to the specified recipients. The recipients can be applications, installable drivers, network drivers, system-level device drivers, or any combination of these system components.
        /// </summary>
        /// <param name="flags">Type: DWORDThe broadcast option. This parameter can be one or more of the following values.</param>
        /// <param name="lpInfo"></param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: longIf the function succeeds, the return value is a positive value.If the function is unable to broadcast the message, the return value is –1.If the dwFlags parameter is BSF_QUERY and at least one recipient returned BROADCAST_QUERY_DENY to the corresponding message, the return value is zero. To get extended error information, call GetLastError.If BSF_QUERY is not specified, the function sends the specified message to all requested recipients, ignoring values returned by those recipients.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.For an example, see Terminating a Process.BroadcastSystemMessageExConceptualMessages and Message QueuesReferenceSendNotifyMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int BroadcastSystemMessageW(uint flags, out uint lpInfo, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Calculates an appropriate pop-up window position using the specified anchor point, pop-up window size, flags, and the optional exclude rectangle. When the specified pop-up window size is smaller than the desktop window size, use the CalculatePopupWindowPosition function to ensure that the pop-up window is fully visible on the desktop window, regardless of the specified anchor point.
        /// </summary>
        /// <param name="anchorPoint">Type: const POINT*The specified anchor point.</param>
        /// <param name="windowSize">Type: const SIZE*The specified window size.</param>
        /// <param name="flags">Type: UINTUse one of the following flags to specify how the function positions the pop-up window horizontally and vertically. The flags are the same as the vertical and horizontal positioning flags of the TrackPopupMenuEx function.Use one of the following flags to specify how the function positions the pop-up window horizontally.Uses one of the following flags to specify how the function positions the pop-up window vertically.Use one of the following flags to specify whether to accommodate horizontal or vertical alignment.The following flag is available starting with Windows 7.</param>
        /// <param name="excludeRect"></param>
        /// <param name="popupWindowPosition"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CalculatePopupWindowPosition(POINT anchorPoint, SIZE windowSize, uint flags, RECT excludeRect, out RECT popupWindowPosition);

        /// <summary>
        ///Passes the specified message and hook code to the hook procedures associated with the WH_SYSMSGFILTER and WH_MSGFILTER hooks. A WH_SYSMSGFILTER or WH_MSGFILTER hook procedure is an application-defined callback function that examines and, optionally, modifies messages for a dialog box, message box, menu, or scroll bar.
        /// </summary>
        /// <param name="lpMsg">Type: LPMSGA pointer to an MSG structure that contains the message to be passed to the hook procedures.</param>
        /// <param name="nCode">Type: intAn application-defined code used by the hook procedure to determine how to process the message. The code must not have the same value as system-defined hook codes (MSGF_ and HC_) associated with the WH_SYSMSGFILTER and WH_MSGFILTER hooks.Type: BOOLIf the application should process the message further, the return value is zero.If the application should not process the message further, the return value is nonzero.The system calls CallMsgFilter to enable applications to examine and control the flow of messages during internal processing of dialog boxes, message boxes, menus, and scroll bars, or when the user activates a different window by pressing the ALT+TAB key combination.Install this hook procedure by using the SetWindowsHookEx function.For an example, see WH_MSGFILTER and WH_SYSMSGFILTER Hooks.ConceptualHooksMSGMessageProcReferenceSetWindowsHookExSysMsgProc</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CallMsgFilterA(MSG lpMsg, int nCode);

        /// <summary>
        ///Passes the specified message and hook code to the hook procedures associated with the WH_SYSMSGFILTER and WH_MSGFILTER hooks. A WH_SYSMSGFILTER or WH_MSGFILTER hook procedure is an application-defined callback function that examines and, optionally, modifies messages for a dialog box, message box, menu, or scroll bar.
        /// </summary>
        /// <param name="lpMsg">Type: LPMSGA pointer to an MSG structure that contains the message to be passed to the hook procedures.</param>
        /// <param name="nCode">Type: intAn application-defined code used by the hook procedure to determine how to process the message. The code must not have the same value as system-defined hook codes (MSGF_ and HC_) associated with the WH_SYSMSGFILTER and WH_MSGFILTER hooks.Type: BOOLIf the application should process the message further, the return value is zero.If the application should not process the message further, the return value is nonzero.The system calls CallMsgFilter to enable applications to examine and control the flow of messages during internal processing of dialog boxes, message boxes, menus, and scroll bars, or when the user activates a different window by pressing the ALT+TAB key combination.Install this hook procedure by using the SetWindowsHookEx function.For an example, see WH_MSGFILTER and WH_SYSMSGFILTER Hooks.ConceptualHooksMSGMessageProcReferenceSetWindowsHookExSysMsgProc</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CallMsgFilterW(MSG lpMsg, int nCode);

        /// <summary>
        ///Passes the hook information to the next hook procedure in the current hook chain. A hook procedure can call this function either before or after processing the hook information.
        /// </summary>
        /// <param name="hhk"></param>
        /// <param name="nCode">Type: intThe hook code passed to the current hook procedure. The next hook procedure uses this code to determine how to process the hook information.</param>
        /// <param name="wParam">Type: WPARAMThe wParam value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated with the current hook chain.</param>
        /// <param name="lParam">Type: LPARAMThe lParam value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated with the current hook chain.Type: LRESULTThis value is returned by the next hook procedure in the chain. The current hook procedure must also return this value. The meaning of the return value depends on the hook type. For more information, see the descriptions of the individual hook procedures.Hook procedures are installed in chains for particular hook types. CallNextHookEx calls the next hook in the chain.Calling CallNextHookEx is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call CallNextHookEx unless you absolutely need to prevent the notification from being seen by other applications.ConceptualHooksReferenceSetWindowsHookExUnhookWindowsHookEx function</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CallNextHookEx(short hhk, int nCode, nint wParam, nint lParam);

        /// <summary>
        ///Passes message information to the specified window procedure.
        /// </summary>
        /// <param name="lpPrevWndFunc">Type: WNDPROCThe previous window procedure. If this value is obtained by calling the GetWindowLong function with the nIndex parameter set to GWL_WNDPROC or DWL_DLGPROC, it is actually either the address of a window or dialog box procedure, or a special internal value meaningful only to CallWindowProc.</param>
        /// <param name="hWnd">Type: HWNDA handle to the window procedure to receive the message.</param>
        /// <param name="Msg">Type: UINTThe message.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information. The contents of this parameter depend on the value of the Msg parameter.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information. The contents of this parameter depend on the value of the Msg parameter.Type: LRESULTThe return value specifies the result of the message processing and depends on the message sent.Use the CallWindowProc function for window subclassing. Usually, all windows with the same class share one window procedure. A subclass is a window or set of windows with the same class whose messages are intercepted and processed by another window procedure (or procedures) before being passed to the window procedure of the class.The SetWindowLong function creates the subclass by changing the window procedure associated with a particular window, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling CallWindowProc. This allows the application to create a chain of window procedures.If STRICT is defined, the lpPrevWndFunc parameter has the data type WNDPROC. The WNDPROC type is declared as follows:If STRICT is not defined, the lpPrevWndFunc parameter has the data type FARPROC. The FARPROC type is declared as follows:In C, the FARPROC declaration indicates a callback function that has an unspecified parameter list. In C++, however, the empty parameter list in the declaration indicates that a function has no parameters. This subtle distinction can break careless code. Following is one way to handle this situation:For further information about functions declared with empty argument lists, refer to The C++ Programming Language, Second Edition, by Bjarne Stroustrup.The CallWindowProc function handles Unicode-to-ANSI conversion. You cannot take advantage of this conversion if you call the window procedure directly.For an example, see Subclassing a WindowConceptualGetWindowLongReferenceSetClassLongSetWindowLongWindow Procedures</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CallWindowProcA(WNDPROC lpPrevWndFunc, nint hWnd, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Passes message information to the specified window procedure.
        /// </summary>
        /// <param name="lpPrevWndFunc">Type: WNDPROCThe previous window procedure. If this value is obtained by calling the GetWindowLong function with the nIndex parameter set to GWL_WNDPROC or DWL_DLGPROC, it is actually either the address of a window or dialog box procedure, or a special internal value meaningful only to CallWindowProc.</param>
        /// <param name="hWnd">Type: HWNDA handle to the window procedure to receive the message.</param>
        /// <param name="Msg">Type: UINTThe message.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information. The contents of this parameter depend on the value of the Msg parameter.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information. The contents of this parameter depend on the value of the Msg parameter.Type: LRESULTThe return value specifies the result of the message processing and depends on the message sent.Use the CallWindowProc function for window subclassing. Usually, all windows with the same class share one window procedure. A subclass is a window or set of windows with the same class whose messages are intercepted and processed by another window procedure (or procedures) before being passed to the window procedure of the class.The SetWindowLong function creates the subclass by changing the window procedure associated with a particular window, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling CallWindowProc. This allows the application to create a chain of window procedures.If STRICT is defined, the lpPrevWndFunc parameter has the data type WNDPROC. The WNDPROC type is declared as follows:If STRICT is not defined, the lpPrevWndFunc parameter has the data type FARPROC. The FARPROC type is declared as follows:In C, the FARPROC declaration indicates a callback function that has an unspecified parameter list. In C++, however, the empty parameter list in the declaration indicates that a function has no parameters. This subtle distinction can break careless code. Following is one way to handle this situation:For further information about functions declared with empty argument lists, refer to The C++ Programming Language, Second Edition, by Bjarne Stroustrup.The CallWindowProc function handles Unicode-to-ANSI conversion. You cannot take advantage of this conversion if you call the window procedure directly.For an example, see Subclassing a WindowConceptualGetWindowLongReferenceSetClassLongSetWindowLongWindow Procedures</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CallWindowProcW(WNDPROC lpPrevWndFunc, nint hWnd, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Cascades the specified child windows of the specified parent window.
        /// </summary>
        /// <param name="hwndParent"></param>
        /// <param name="wHow">Type: UINTA cascade flag. This parameter can be one or more of the following values.</param>
        /// <param name="lpRect"></param>
        /// <param name="cKids">Type: UINTThe number of elements in the array specified by the lpKids parameter. This parameter is ignored if lpKids is NULL.</param>
        /// <param name="lpKids"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short CascadeWindows(nint hwndParent, uint wHow, RECT lpRect, uint cKids, nint lpKids);

        /// <summary>
        ///Removes a specified window from the chain of clipboard viewers.
        /// </summary>
        /// <param name="hWndRemove">Type: HWNDA handle to the window to be removed from the chain. The handle must have been passed to the SetClipboardViewer function.</param>
        /// <param name="hWndNewNext">Type: HWNDA handle to the window that follows the hWndRemove window in the clipboard viewer chain. (This is the handle returned by SetClipboardViewer, unless the sequence was changed in response to a WM_CHANGECBCHAIN message.)Type: BOOLThe return value indicates the result of passing the WM_CHANGECBCHAIN message to the windows in the clipboard viewer chain. Because a window in the chain typically returns FALSE when it processes WM_CHANGECBCHAIN, the return value from ChangeClipboardChain is typically FALSE. If there is only one window in the chain, the return value is typically TRUE.The window identified by hWndNewNext replaces the hWndRemove window in the chain. The SetClipboardViewer function sends a WM_CHANGECBCHAIN message to the first window in the clipboard viewer chain.For an example, see Removing a Window from the Clipboard Viewer Chain.ChangeClipboardChainClipboardConceptualReferenceSetClipboardViewerWM_CHANGECBCHAIN</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ChangeClipboardChain(nint hWndRemove, nint hWndNewNext);

        /// <summary>
        ///The ChangeDisplaySettings function changes the settings of the default display device to the specified graphics mode.
        /// </summary>
        /// <param name="lpDevMode">A pointer to a DEVMODE structure that describes the new graphics mode. If lpDevMode is NULL, all the values currently in the registry will be used for the display setting. Passing NULL for the lpDevMode parameter and 0 for the dwFlags parameter is the easiest way to return to the default mode after a dynamic mode change.The dmSize member of DEVMODE must be initialized to the size, in bytes, of the DEVMODE structure. The dmDriverExtra member of DEVMODE must be initialized to indicate the number of bytes of private driver data following the DEVMODE structure. In addition, you can use any or all of the following members of the DEVMODE structure.In addition to using one or more of the preceding DEVMODE members, you must also set one or more of the following values in the dmFields member to change the display setting.</param>
        /// <param name="dwFlags">Indicates how the graphics mode should be changed. This parameter can be one of the following values.Specifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to change to that graphics mode.If CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the registry and DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information is stored in the registry and DISP_CHANGE_RESTART is returned.If CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and DISP_CHANGE_NOTUPDATED is returned.The ChangeDisplaySettings function returns one of the following values.To ensure that the DEVMODE structure passed to ChangeDisplaySettings is valid and contains only values supported by the display driver, use the DEVMODE returned by the EnumDisplaySettings function.When the display mode is changed dynamically, the WM_DISPLAYCHANGE message is sent to all running applications with the following message parameters.ChangeDisplaySettingsExCreateDCDEVMODEDevice Context FunctionsDevice Contexts OverviewEnumDisplayDevicesEnumDisplaySettingsWM_DISPLAYCHANGE</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ChangeDisplaySettingsA(uint lpDevMode, uint dwFlags);

        /// <summary>
        ///The ChangeDisplaySettingsEx function changes the settings of the specified display device to the specified graphics mode.
        /// </summary>
        /// <param name="lpszDeviceName">A pointer to a null-terminated string that specifies the display device whose graphics mode will change. Only display device names as returned by EnumDisplayDevices are valid. See EnumDisplayDevices for further information on the names associated with these display devices.The lpszDeviceName parameter can be NULL. A NULL value specifies the default display device. The default device can be determined by calling EnumDisplayDevices and checking for the DISPLAY_DEVICE_PRIMARY_DEVICE flag.</param>
        /// <param name="lpDevMode">A pointer to a DEVMODE structure that describes the new graphics mode. If lpDevMode is NULL, all the values currently in the registry will be used for the display setting. Passing NULL for the lpDevMode parameter and 0 for the dwFlags parameter is the easiest way to return to the default mode after a dynamic mode change.The dmSize member must be initialized to the size, in bytes, of the DEVMODE structure. The dmDriverExtra member must be initialized to indicate the number of bytes of private driver data following the DEVMODE structure. In addition, you can use any of the following members of the DEVMODE structure.In addition to using one or more of the preceding DEVMODE members, you must also set one or more of the following values in the dmFields member to change the display settings.hwndReserved; must be NULL.</param>
        /// <param name="hwnd"></param>
        /// <param name="dwflags">Indicates how the graphics mode should be changed. This parameter can be one of the following values.Specifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to change to them.If CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the registry and DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information is stored in the registry and DISP_CHANGE_RESTART is returned.If CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and DISP_CHANGE_NOTUPDATED is returned.</param>
        /// <param name="lParam">If dwFlags is CDS_VIDEOPARAMETERS, lParam is a pointer to a VIDEOPARAMETERS structure. Otherwise lParam must be NULL.The ChangeDisplaySettingsEx function returns one of the following values.To ensure that the DEVMODE structure passed to ChangeDisplaySettingsEx is valid and contains only values supported by the display driver, use the DEVMODE returned by the EnumDisplaySettings function.When adding a display monitor to a multiple-monitor system programmatically, set DEVMODE.dmFields to DM_POSITION and specify a position (in DEVMODE.dmPosition) for the monitor you are adding that is adjacent to at least one pixel of the display area of an existing monitor. To detach the monitor, set DEVMODE.dmFields to DM_POSITION but set DEVMODE.dmPelsWidth and DEVMODE.dmPelsHeight to zero. For more information, see Multiple Display Monitors.When the display mode is changed dynamically, the WM_DISPLAYCHANGE message is sent to all running applications with the following message parameters.To change the settings for more than one display at the same time, first call ChangeDisplaySettingsEx for each device individually to update the registry without applying the changes. Then call ChangeDisplaySettingsEx once more, with a NULL device, to apply the changes. For example, to change the settings for two displays, do the following:CreateDCDEVMODEDevice Context FunctionsDevice Contexts OverviewEnumDisplayDevicesEnumDisplaySettingsVIDEOPARAMETERSWM_DISPLAYCHANGE</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ChangeDisplaySettingsExA(string lpszDeviceName, uint lpDevMode, nint hwnd, uint dwflags, nint lParam);

        /// <summary>
        ///The ChangeDisplaySettingsEx function changes the settings of the specified display device to the specified graphics mode.
        /// </summary>
        /// <param name="lpszDeviceName">A pointer to a null-terminated string that specifies the display device whose graphics mode will change. Only display device names as returned by EnumDisplayDevices are valid. See EnumDisplayDevices for further information on the names associated with these display devices.The lpszDeviceName parameter can be NULL. A NULL value specifies the default display device. The default device can be determined by calling EnumDisplayDevices and checking for the DISPLAY_DEVICE_PRIMARY_DEVICE flag.</param>
        /// <param name="lpDevMode">A pointer to a DEVMODE structure that describes the new graphics mode. If lpDevMode is NULL, all the values currently in the registry will be used for the display setting. Passing NULL for the lpDevMode parameter and 0 for the dwFlags parameter is the easiest way to return to the default mode after a dynamic mode change.The dmSize member must be initialized to the size, in bytes, of the DEVMODE structure. The dmDriverExtra member must be initialized to indicate the number of bytes of private driver data following the DEVMODE structure. In addition, you can use any of the following members of the DEVMODE structure.In addition to using one or more of the preceding DEVMODE members, you must also set one or more of the following values in the dmFields member to change the display settings.hwndReserved; must be NULL.</param>
        /// <param name="hwnd"></param>
        /// <param name="dwflags">Indicates how the graphics mode should be changed. This parameter can be one of the following values.Specifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to change to them.If CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the registry and DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information is stored in the registry and DISP_CHANGE_RESTART is returned.If CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and DISP_CHANGE_NOTUPDATED is returned.</param>
        /// <param name="lParam">If dwFlags is CDS_VIDEOPARAMETERS, lParam is a pointer to a VIDEOPARAMETERS structure. Otherwise lParam must be NULL.The ChangeDisplaySettingsEx function returns one of the following values.To ensure that the DEVMODE structure passed to ChangeDisplaySettingsEx is valid and contains only values supported by the display driver, use the DEVMODE returned by the EnumDisplaySettings function.When adding a display monitor to a multiple-monitor system programmatically, set DEVMODE.dmFields to DM_POSITION and specify a position (in DEVMODE.dmPosition) for the monitor you are adding that is adjacent to at least one pixel of the display area of an existing monitor. To detach the monitor, set DEVMODE.dmFields to DM_POSITION but set DEVMODE.dmPelsWidth and DEVMODE.dmPelsHeight to zero. For more information, see Multiple Display Monitors.When the display mode is changed dynamically, the WM_DISPLAYCHANGE message is sent to all running applications with the following message parameters.To change the settings for more than one display at the same time, first call ChangeDisplaySettingsEx for each device individually to update the registry without applying the changes. Then call ChangeDisplaySettingsEx once more, with a NULL device, to apply the changes. For example, to change the settings for two displays, do the following:CreateDCDEVMODEDevice Context FunctionsDevice Contexts OverviewEnumDisplayDevicesEnumDisplaySettingsVIDEOPARAMETERSWM_DISPLAYCHANGE</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ChangeDisplaySettingsExW(string lpszDeviceName, uint lpDevMode, nint hwnd, uint dwflags, nint lParam);

        /// <summary>
        ///The ChangeDisplaySettings function changes the settings of the default display device to the specified graphics mode.
        /// </summary>
        /// <param name="lpDevMode">A pointer to a DEVMODE structure that describes the new graphics mode. If lpDevMode is NULL, all the values currently in the registry will be used for the display setting. Passing NULL for the lpDevMode parameter and 0 for the dwFlags parameter is the easiest way to return to the default mode after a dynamic mode change.The dmSize member of DEVMODE must be initialized to the size, in bytes, of the DEVMODE structure. The dmDriverExtra member of DEVMODE must be initialized to indicate the number of bytes of private driver data following the DEVMODE structure. In addition, you can use any or all of the following members of the DEVMODE structure.In addition to using one or more of the preceding DEVMODE members, you must also set one or more of the following values in the dmFields member to change the display setting.</param>
        /// <param name="dwFlags">Indicates how the graphics mode should be changed. This parameter can be one of the following values.Specifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to change to that graphics mode.If CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the registry and DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information is stored in the registry and DISP_CHANGE_RESTART is returned.If CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and DISP_CHANGE_NOTUPDATED is returned.The ChangeDisplaySettings function returns one of the following values.To ensure that the DEVMODE structure passed to ChangeDisplaySettings is valid and contains only values supported by the display driver, use the DEVMODE returned by the EnumDisplaySettings function.When the display mode is changed dynamically, the WM_DISPLAYCHANGE message is sent to all running applications with the following message parameters.ChangeDisplaySettingsExCreateDCDEVMODEDevice Context FunctionsDevice Contexts OverviewEnumDisplayDevicesEnumDisplaySettingsWM_DISPLAYCHANGE</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ChangeDisplaySettingsW(uint lpDevMode, uint dwFlags);

        /// <summary>
        ///[Using the ChangeWindowMessageFilter function is not recommended, as it has process-wide scope. Instead, use the ChangeWindowMessageFilterEx function to control access to specific windows as needed. ChangeWindowMessageFilter may not be supported in future versions of Windows.]
        /// </summary>
        /// <param name="message">Type: UINTThe message to add to or remove from the filter.</param>
        /// <param name="dwFlag">Type: DWORDThe action to be performed. One of the following values.Type: BOOLTRUE if successful; otherwise, FALSE. To get extended error information, call GetLastError.UIPI is a security feature that prevents messages from being received from a lower integrity level sender. All such messages with a value above WM_USER are blocked by default. The filter, somewhat contrary to intuition, is a list of messages that are allowed through. Therefore, adding a message to the filter allows that message to be received from a lower integrity sender, while removing a message blocks that message from being received.Certain messages with a value less than WM_USER are required to pass through the filter regardless of the filter setting. You can call this function to remove one of those messages from the filter and it will return TRUE. However, the message will still be received by the calling process.Processes at or below SECURITY_MANDATORY_LOW_RID are not allowed to change the filter. If those processes call this function, it will fail.For more information on integrity levels, see Understanding and Working in Protected Mode Internet Explorer.</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ChangeWindowMessageFilter(uint message, uint dwFlag);

        /// <summary>
        ///Modifies the User Interface Privilege Isolation (UIPI) message filter for a specified window.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window whose UIPI message filter is to be modified.</param>
        /// <param name="message">Type: UINTThe message that the message filter allows through or blocks.</param>
        /// <param name="action">Type: DWORDThe action to be performed, and can take one of the following values:</param>
        /// <param name="pChangeFilterStruct"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ChangeWindowMessageFilterEx(nint hwnd, uint message, uint action, out CHANGEFILTERSTRUCT pChangeFilterStruct);

        /// <summary>
        ///Converts a character string or a single character to lowercase. If the operand is a character string, the function converts the characters in place.
        /// </summary>
        /// <param name="lpsz">Type: LPTSTRA null-terminated string, or specifies a single character. If the high-order word of this parameter is zero, the low-order word must contain a single character to be converted.Type: LPTSTRIf the operand is a character string, the function returns a pointer to the converted string. Because the string is converted in place, the return value is equal to lpsz.If the operand is a single character, the return value is a 32-bit value whose high-order word is zero, and low-order word contains the converted character.There is no indication of success or failure. Failure is rare. There is no extended error information for this function; do not call GetLastError.Note that CharLower always maps uppercase I to lowercase I ("i"), even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call LCMapString.Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.CharLowerBuffCharUpperCharUpperBuffConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern string CharLowerA(out string lpsz);

        /// <summary>
        ///Converts uppercase characters in a buffer to lowercase characters. The function converts the characters in place.
        /// </summary>
        /// <param name="lpsz">Type: LPTSTRA buffer containing one or more characters to be processed.</param>
        /// <param name="cchLength">Type: DWORDThe size, in characters, of the buffer pointed to by lpsz. The function examines each character, and converts uppercase characters to lowercase characters. The function examines the number of characters indicated by cchLength, even if one or more characters are null characters.Type: DWORDThe return value is the number of characters processed. For example, if CharLowerBuff("Acme of Operating Systems", 10) succeeds, the return value is 10.Note that CharLowerBuff always maps uppercase I to lowercase I ("i"), even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call LCMapSting.Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.For an example, see "Creating a Spell Dialog Box" in Using Combo Boxes.CharLowerCharUpperCharUpperBuffConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint CharLowerBuffA(out string lpsz, uint cchLength);

        /// <summary>
        ///Converts uppercase characters in a buffer to lowercase characters. The function converts the characters in place.
        /// </summary>
        /// <param name="lpsz">Type: LPTSTRA buffer containing one or more characters to be processed.</param>
        /// <param name="cchLength">Type: DWORDThe size, in characters, of the buffer pointed to by lpsz. The function examines each character, and converts uppercase characters to lowercase characters. The function examines the number of characters indicated by cchLength, even if one or more characters are null characters.Type: DWORDThe return value is the number of characters processed. For example, if CharLowerBuff("Acme of Operating Systems", 10) succeeds, the return value is 10.Note that CharLowerBuff always maps uppercase I to lowercase I ("i"), even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call LCMapSting.Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.For an example, see "Creating a Spell Dialog Box" in Using Combo Boxes.CharLowerCharUpperCharUpperBuffConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint CharLowerBuffW(out string lpsz, uint cchLength);

        /// <summary>
        ///Converts a character string or a single character to lowercase. If the operand is a character string, the function converts the characters in place.
        /// </summary>
        /// <param name="lpsz">Type: LPTSTRA null-terminated string, or specifies a single character. If the high-order word of this parameter is zero, the low-order word must contain a single character to be converted.Type: LPTSTRIf the operand is a character string, the function returns a pointer to the converted string. Because the string is converted in place, the return value is equal to lpsz.If the operand is a single character, the return value is a 32-bit value whose high-order word is zero, and low-order word contains the converted character.There is no indication of success or failure. Failure is rare. There is no extended error information for this function; do not call GetLastError.Note that CharLower always maps uppercase I to lowercase I ("i"), even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call LCMapString.Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.CharLowerBuffCharUpperCharUpperBuffConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern string CharLowerW(out string lpsz);

        /// <summary>
        ///Retrieves a pointer to the next character in a string. This function can handle strings consisting of either single- or multi-byte characters.
        /// </summary>
        /// <param name="lpsz">Type: LPCTSTRA character in a null-terminated string.Type: LPTSTRThe return value is a pointer to the next character in the string, or to the terminating null character if at the end of the string.If lpsz points to the terminating null character, the return value is equal to lpsz.When called as an ANSI function, CharNext uses the system default code-page, whereas CharNextExA specifies a code-page to use.This function works with default "user" expectations of characters when dealing with diacritics. For example: A string that contains U+0061 U+030a "LATIN SMALL LETTER A" + COMBINING RING ABOVE" — which looks like "å", will advance two code points, not one. A string that contains U+0061 U+0301 U+0302 U+0303 U+0304 — which looks like "a´^~¯", will advance five code points, not one, and so on.CharNextExACharPrevConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern string CharNextA(string lpsz);

        /// <summary>
        ///Retrieves the pointer to the next character in a string. This function can handle strings consisting of either single- or multi-byte characters.
        /// </summary>
        /// <param name="CodePage">Type: WORDThe identifier of the code page to use to check lead-byte ranges. Can be one of the code-page values provided in Code Page Identifiers, or one of the following predefined values.</param>
        /// <param name="lpCurrentChar">Type: LPCSTRA character in a null-terminated string.</param>
        /// <param name="dwFlags">Type: DWORDThis parameter is reserved and must be 0.Type: LPSTRThe return value is a pointer to the next character in the string, or to the terminating null character if at the end of the string.If lpCurrentChar points to the terminating null character, the return value is equal to lpCurrentChar.CharNextExA specifies a code-page to use, whereas CharNext (if called as an ANSI function) uses the system default code-page.CharNextCharPrevExAConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern string CharNextExA(short CodePage, string lpCurrentChar, uint dwFlags);

        /// <summary>
        ///Retrieves a pointer to the next character in a string. This function can handle strings consisting of either single- or multi-byte characters.
        /// </summary>
        /// <param name="lpsz">Type: LPCTSTRA character in a null-terminated string.Type: LPTSTRThe return value is a pointer to the next character in the string, or to the terminating null character if at the end of the string.If lpsz points to the terminating null character, the return value is equal to lpsz.When called as an ANSI function, CharNext uses the system default code-page, whereas CharNextExA specifies a code-page to use.This function works with default "user" expectations of characters when dealing with diacritics. For example: A string that contains U+0061 U+030a "LATIN SMALL LETTER A" + COMBINING RING ABOVE" — which looks like "å", will advance two code points, not one. A string that contains U+0061 U+0301 U+0302 U+0303 U+0304 — which looks like "a´^~¯", will advance five code points, not one, and so on.CharNextExACharPrevConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern string CharNextW(string lpsz);

        /// <summary>
        ///Retrieves a pointer to the preceding character in a string. This function can handle strings consisting of either single- or multi-byte characters.
        /// </summary>
        /// <param name="lpszStart">Type: LPCTSTRThe beginning of the string.</param>
        /// <param name="lpszCurrent">Type: LPCTSTRA character in a null-terminated string.Type: LPTSTRThe return value is a pointer to the preceding character in the string, or to the first character in the string if the lpszCurrent parameter equals the lpszStart parameter.When called as an ANSI function, CharPrev uses the system default code-page, whereas CharPrevExA specifies a code-page to use.This function works with default "user" expectations of characters when dealing with diacritics. For example: A string that contains U+0061 U+030a "LATIN SMALL LETTER A" + COMBINING RING ABOVE" — which looks like "å", will advance two code points, not one. A string that contains U+0061 U+0301 U+0302 U+0303 U+0304 — which looks like "a´^~¯", will advance five code points, not one, and so on.CharNextCharNextExACharPrevExAConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern string CharPrevA(string lpszStart, string lpszCurrent);

        /// <summary>
        ///Retrieves the pointer to the preceding character in a string. This function can handle strings consisting of either single- or multi-byte characters.
        /// </summary>
        /// <param name="CodePage">Type: WORDThe identifier of the code page to use to check lead-byte ranges. Can be one of the code-page values provided in Code Page Identifiers, or one of the following predefined values.</param>
        /// <param name="lpStart">Type: LPCSTRThe beginning of the string.</param>
        /// <param name="lpCurrentChar">Type: LPCSTRA character in a null-terminated string.</param>
        /// <param name="dwFlags">Type: DWORDThis parameter is reserved and must be zero.Type: LPSTRThe return value is a pointer to the preceding character in the string, or to the first character in the string if the lpCurrentChar parameter equals the lpStart parameter.CharPrevExA specifies a code-page to use, whereas CharPrev (if called as an ANSI function) uses the system default code-page.CharNextExACharPrevConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern string CharPrevExA(short CodePage, string lpStart, string lpCurrentChar, uint dwFlags);

        /// <summary>
        ///Retrieves a pointer to the preceding character in a string. This function can handle strings consisting of either single- or multi-byte characters.
        /// </summary>
        /// <param name="lpszStart">Type: LPCTSTRThe beginning of the string.</param>
        /// <param name="lpszCurrent">Type: LPCTSTRA character in a null-terminated string.Type: LPTSTRThe return value is a pointer to the preceding character in the string, or to the first character in the string if the lpszCurrent parameter equals the lpszStart parameter.When called as an ANSI function, CharPrev uses the system default code-page, whereas CharPrevExA specifies a code-page to use.This function works with default "user" expectations of characters when dealing with diacritics. For example: A string that contains U+0061 U+030a "LATIN SMALL LETTER A" + COMBINING RING ABOVE" — which looks like "å", will advance two code points, not one. A string that contains U+0061 U+0301 U+0302 U+0303 U+0304 — which looks like "a´^~¯", will advance five code points, not one, and so on.CharNextCharNextExACharPrevExAConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern string CharPrevW(string lpszStart, string lpszCurrent);

        /// <summary>
        ///Translates a string into the OEM-defined character set.
        /// </summary>
        /// <param name="pSrc">Type: LPCTSTRThe null-terminated string to be translated.</param>
        /// <param name="pDst"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CharToOemA(string pSrc, out string pDst);

        /// <summary>
        ///Translates a specified number of characters in a string into the OEM-defined character set.
        /// </summary>
        /// <param name="lpszSrc">Type: LPCTSTRThe null-terminated string to be translated.</param>
        /// <param name="lpszDst"></param>
        /// <param name="cchDstLength">Type: DWORDThe number of characters to translate in the string identified by the lpszSrc parameter.Type: BOOLThe return value is always nonzero except when you pass the same address to lpszSrc and lpszDst in the wide-character version of the function. In this case the function returns zero and GetLastError returns ERROR_INVALID_ADDRESS.Unlike the CharToOem function, the CharToOemBuff function does not stop converting characters when it encounters a null character in the buffer pointed to by lpszSrc. The CharToOemBuff function converts all cchDstLength characters.CharToOemConceptualOemToCharOemToCharBuffReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CharToOemBuffA(string lpszSrc, out string lpszDst, uint cchDstLength);

        /// <summary>
        ///Translates a specified number of characters in a string into the OEM-defined character set.
        /// </summary>
        /// <param name="lpszSrc">Type: LPCTSTRThe null-terminated string to be translated.</param>
        /// <param name="lpszDst"></param>
        /// <param name="cchDstLength">Type: DWORDThe number of characters to translate in the string identified by the lpszSrc parameter.Type: BOOLThe return value is always nonzero except when you pass the same address to lpszSrc and lpszDst in the wide-character version of the function. In this case the function returns zero and GetLastError returns ERROR_INVALID_ADDRESS.Unlike the CharToOem function, the CharToOemBuff function does not stop converting characters when it encounters a null character in the buffer pointed to by lpszSrc. The CharToOemBuff function converts all cchDstLength characters.CharToOemConceptualOemToCharOemToCharBuffReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CharToOemBuffW(string lpszSrc, out string lpszDst, uint cchDstLength);

        /// <summary>
        ///Translates a string into the OEM-defined character set.
        /// </summary>
        /// <param name="pSrc">Type: LPCTSTRThe null-terminated string to be translated.</param>
        /// <param name="pDst"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CharToOemW(string pSrc, out string pDst);

        /// <summary>
        ///Converts a character string or a single character to uppercase. If the operand is a character string, the function converts the characters in place.
        /// </summary>
        /// <param name="lpsz">Type: LPTSTRA null-terminated string, or a single character. If the high-order word of this parameter is zero, the low-order word must contain a single character to be converted.Type: LPTSTRIf the operand is a character string, the function returns a pointer to the converted string. Because the string is converted in place, the return value is equal to lpsz.If the operand is a single character, the return value is a 32-bit value whose high-order word is zero, and low-order word contains the converted character.There is no indication of success or failure. Failure is rare. There is no extended error information for this function; do not call GetLastError.Note that CharUpper always maps lowercase I ("i") to uppercase I, even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call LCMapString.Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.CharLowerCharLowerBuffCharUpperBuffConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern string CharUpperA(out string lpsz);

        /// <summary>
        ///Converts lowercase characters in a buffer to uppercase characters. The function converts the characters in place.
        /// </summary>
        /// <param name="lpsz">Type: LPTSTRA buffer containing one or more characters to be processed.</param>
        /// <param name="cchLength">Type: DWORDThe size, in characters, of the buffer pointed to by lpsz.The function examines each character, and converts lowercase characters to uppercase characters. The function examines the number of characters indicated by cchLength, even if one or more characters are null characters.Type: DWORDThe return value is the number of characters processed.For example, if CharUpperBuff("Zenith of API Sets", 10) succeeds, the return value is 10.Note that CharUpperBuff always maps lowercase I ("i") to uppercase I, even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call LCMapString.Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.For an example, see Creating and Using a Temporary File.CharLowerCharLowerBuffCharUpperConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint CharUpperBuffA(out string lpsz, uint cchLength);

        /// <summary>
        ///Converts lowercase characters in a buffer to uppercase characters. The function converts the characters in place.
        /// </summary>
        /// <param name="lpsz">Type: LPTSTRA buffer containing one or more characters to be processed.</param>
        /// <param name="cchLength">Type: DWORDThe size, in characters, of the buffer pointed to by lpsz.The function examines each character, and converts lowercase characters to uppercase characters. The function examines the number of characters indicated by cchLength, even if one or more characters are null characters.Type: DWORDThe return value is the number of characters processed.For example, if CharUpperBuff("Zenith of API Sets", 10) succeeds, the return value is 10.Note that CharUpperBuff always maps lowercase I ("i") to uppercase I, even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call LCMapString.Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.For an example, see Creating and Using a Temporary File.CharLowerCharLowerBuffCharUpperConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint CharUpperBuffW(out string lpsz, uint cchLength);

        /// <summary>
        ///Converts a character string or a single character to uppercase. If the operand is a character string, the function converts the characters in place.
        /// </summary>
        /// <param name="lpsz">Type: LPTSTRA null-terminated string, or a single character. If the high-order word of this parameter is zero, the low-order word must contain a single character to be converted.Type: LPTSTRIf the operand is a character string, the function returns a pointer to the converted string. Because the string is converted in place, the return value is equal to lpsz.If the operand is a single character, the return value is a 32-bit value whose high-order word is zero, and low-order word contains the converted character.There is no indication of success or failure. Failure is rare. There is no extended error information for this function; do not call GetLastError.Note that CharUpper always maps lowercase I ("i") to uppercase I, even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call LCMapString.Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.CharLowerCharLowerBuffCharUpperBuffConceptualReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern string CharUpperW(out string lpsz);

        /// <summary>
        ///Changes the check state of a button control.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the button.</param>
        /// <param name="nIDButton">Type: intThe identifier of the button to modify.</param>
        /// <param name="uCheck">Type: UINTThe check state of the button. This parameter can be one of the following values.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The CheckDlgButton function sends a BM_SETCHECK message to the specified button control in the specified dialog box.For an example, see Creating a Modeless Dialog Box in Using Dialog Boxes.CheckRadioButtonIsDlgButtonCheckedReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CheckDlgButton(nint hDlg, int nIDButton, uint uCheck);

        /// <summary>
        ///[CheckMenuItem is available for use in the operating systems specified in the Requirements section. It may be altered or unavailable in subsequent versions. Instead, use SetMenuItemInfo. ]
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu of interest.</param>
        /// <param name="uIDCheckItem">Type: UINTThe menu item whose check-mark attribute is to be set, as determined by the uCheck parameter.</param>
        /// <param name="uCheck">Type: UINTThe flags that control the interpretation of the uIDCheckItem parameter and the state of the menu item's check-mark attribute. This parameter can be a combination of either MF_BYCOMMAND, or MF_BYPOSITION and MF_CHECKED or MF_UNCHECKED.Type: DWORDThe return value specifies the previous state of the menu item (either MF_CHECKED or MF_UNCHECKED). If the menu item does not exist, the return value is –1.An item in a menu bar cannot have a check mark.The uIDCheckItem parameter identifies a item that opens a submenu or a command item. For a item that opens a submenu, the uIDCheckItem parameter must specify the position of the item. For a command item, the uIDCheckItem parameter can specify either the item's position or its identifier.For an example, see Simulating Check Boxes in a Menu.ConceptualEnableMenuItemGetMenuItemIDMenusReferenceSetMenuItemBitmapsSetMenuItemInfo</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint CheckMenuItem(nint hMenu, uint uIDCheckItem, uint uCheck);

        /// <summary>
        ///Checks a specified menu item and makes it a radio item. At the same time, the function clears all other menu items in the associated group and clears the radio-item type flag for those items.
        /// </summary>
        /// <param name="hmenu">Type: HMENUA handle to the menu that contains the group of menu items.</param>
        /// <param name="first">Type: UINTThe identifier or position of the first menu item in the group.</param>
        /// <param name="last">Type: UINTThe identifier or position of the last menu item in the group.</param>
        /// <param name="check">Type: UINTThe identifier or position of the menu item to check.</param>
        /// <param name="flags">Type: UINTIndicates the meaning of idFirst, idLast, and idCheck. If this parameter is MF_BYCOMMAND, the other parameters specify menu item identifiers. If it is MF_BYPOSITION, the other parameters specify the menu item positions.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.The CheckMenuRadioItem function sets the MFT_RADIOCHECK type flag and the MFS_CHECKED state for the item specified by idCheck and, at the same time, clears both flags for all other items in the group. The selected item is displayed using a bullet bitmap instead of a check-mark bitmap.For more information about menu item type and state flags, see the MENUITEMINFO structure.For an example, see Example of Example of Using Custom Checkmark Bitmaps.ConceptualMENUITEMINFOMenusReference</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CheckMenuRadioItem(nint hmenu, uint first, uint last, uint check, uint flags);

        /// <summary>
        ///Adds a check mark to (checks) a specified radio button in a group and removes a check mark from (clears) all other radio buttons in the group.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the radio button.</param>
        /// <param name="nIDFirstButton">Type: intThe identifier of the first radio button in the group.</param>
        /// <param name="nIDLastButton">Type: intThe identifier of the last radio button in the group.</param>
        /// <param name="nIDCheckButton">Type: intThe identifier of the radio button to select.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The CheckRadioButton function sends a BM_SETCHECK message to each of the radio buttons in the indicated group.The nIDFirstButton and nIDLastButton parameters specify a range of button identifiers (normally the resource IDs of the buttons). The position of buttons in the tab order is irrelevant; if a button forms part of a group, but has an ID outside the specified range, it is not affected by this call.CheckDlgButtonIsDlgButtonCheckedReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CheckRadioButton(nint hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton);

        /// <summary>
        ///Determines which, if any, of the child windows belonging to a parent window contains the specified point. The search is restricted to immediate child windows. Grandchildren, and deeper descendant windows are not searched.
        /// </summary>
        /// <param name="hWndParent">Type: HWNDA handle to the parent window.</param>
        /// <param name="Point">Type: POINTA structure that defines the client coordinates, relative to hWndParent, of the point to be checked.Type: HWNDThe return value is a handle to the child window that contains the point, even if the child window is hidden or disabled. If the point lies outside the parent window, the return value is NULL. If the point is within the parent window but not within any child window, the return value is a handle to the parent window.The system maintains an internal list, containing the handles of the child windows associated with a parent window. The order of the handles in the list depends on the Z order of the child windows. If more than one child window contains the specified point, the system returns a handle to the first window in the list that contains the point.ChildWindowFromPoint treats an HTTRANSPARENT area of a standard control the same as other parts of the control. In contrast, RealChildWindowFromPoint treats an HTTRANSPARENT area differently; it returns the child window behind a transparent area of a control. For example, if the point is in a transparent area of a groupbox, ChildWindowFromPoint returns the groupbox while RealChildWindowFromPoint returns the child window behind the groupbox. However, both APIs return a static field, even though it, too, returns HTTRANSPARENT.For an example, see "Creating a Combo Box Toolbar" in Using Combo Boxes.ChildWindowFromPointExConceptualOther ResourcesPOINTRealChildWindowFromPointReferenceWindowFromPointWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint ChildWindowFromPoint(nint hWndParent, POINT Point);

        /// <summary>
        ///Determines which, if any, of the child windows belonging to the specified parent window contains the specified point. The function can ignore invisible, disabled, and transparent child windows. The search is restricted to immediate child windows. Grandchildren and deeper descendants are not searched.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the parent window.</param>
        /// <param name="pt">Type: POINTA structure that defines the client coordinates (relative to hwndParent) of the point to be checked.</param>
        /// <param name="flags">Type: UINTThe child windows to be skipped. This parameter can be one or more of the following values.Type: HWNDThe return value is a handle to the first child window that contains the point and meets the criteria specified by uFlags. If the point is within the parent window but not within any child window that meets the criteria, the return value is a handle to the parent window. If the point lies outside the parent window or if the function fails, the return value is NULL.The system maintains an internal list that contains the handles of the child windows associated with a parent window. The order of the handles in the list depends on the Z order of the child windows. If more than one child window contains the specified point, the system returns a handle to the first window in the list that contains the point and meets the criteria specified by uFlags.ConceptualOther ResourcesPOINTReferenceWindowFromPointWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint ChildWindowFromPointEx(nint hwnd, POINT pt, uint flags);

        /// <summary>
        ///The ClientToScreen function converts the client-area coordinates of a specified point to screen coordinates.
        /// </summary>
        /// <param name="hWnd">A handle to the window whose client area is used for the conversion.</param>
        /// <param name="lpPoint">A pointer to a POINT structure that contains the client coordinates to be converted. The new screen coordinates are copied into this structure if the function succeeds.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.The ClientToScreen function replaces the client-area coordinates in the POINT structure with the screen coordinates. The screen coordinates are relative to the upper-left corner of the screen. Note, a screen-coordinate point that is above the window's client area has a negative y-coordinate. Similarly, a screen coordinate to the left of a client area has a negative x-coordinate.All coordinates are device coordinates.For an example, see "Drawing Lines with the Mouse" in Using Mouse Input.Coordinate Space and Transformation FunctionsCoordinate Spaces and Transformations OverviewMapWindowPointsPOINTScreenToClient</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ClientToScreen(nint hWnd, out POINT lpPoint);

        /// <summary>
        ///Confines the cursor to a rectangular area on the screen. If a subsequent cursor position (set by the SetCursorPos function or the mouse) lies outside the rectangle, the system automatically adjusts the position to keep the cursor inside the rectangular area.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ClipCursor(RECT lpRect);

        /// <summary>
        ///Closes the clipboard.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CloseClipboard();

        /// <summary>
        ///Closes an open handle to a desktop object.
        /// </summary>
        /// <param name="hDesktop">A handle to the desktop to be closed. This can be a handle returned by the CreateDesktop, OpenDesktop, or OpenInputDesktop functions. Do not specify the handle returned by the GetThreadDesktop function.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The CloseDesktop function will fail if any thread in the calling process is using the specified desktop handle or if the handle refers to the initial desktop of the calling process.CreateDesktopDesktopsOpenDesktopOpenInputDesktopWindow Station and Desktop Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CloseDesktop(nint hDesktop);

        /// <summary>
        ///Closes resources associated with a gesture information handle.
        /// </summary>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CloseGestureInfoHandle(GESTUREINFO hGestureInfo);

        /// <summary>
        ///Closes a touch input handle, frees process memory associated with it, and invalidates the handle.
        /// </summary>
        /// <param name="hTouchInput">The touch input handle received in the LPARAM of a touch message. The function fails with ERROR_INVALID_HANDLE if this handle is not valid. Note that the handle is not valid after it has been used in a successful call to CloseTouchInputHandle or after it has been passed to DefWindowProc, PostMessage, SendMessage or one of their variants.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.Calling CloseTouchInputHandle will not free memory associated with values retrieved in a call to GetTouchInputInfo. Values in structures passed to GetTouchInputInfo will be valid until you delete them.FunctionsGetTouchInputInfo</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CloseTouchInputHandle(TOUCHINPUT hTouchInput);

        /// <summary>
        ///Minimizes (but does not destroy) the specified window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to be minimized.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.To destroy a window, an application must use the DestroyWindow function.ArrangeIconicWindowsConceptualDestroyWindowIsIconicOpenIconReferenceWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CloseWindow(nint hWnd);

        /// <summary>
        ///Closes an open window station handle.
        /// </summary>
        /// <param name="hWinSta">A handle to the window station to be closed. This handle is returned by the CreateWindowStation or OpenWindowStation function. Do not specify the handle returned by the GetProcessWindowStation function.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Windows Server 2003 and Windows XP/2000:  This function does not set the last error code on failure.The CloseWindowStation function will fail if the handle being closed is for the window station assigned to the calling process.Window Station and Desktop FunctionsWindow Stations</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CloseWindowStation(int hWinSta);

        /// <summary>
        ///Copies the specified accelerator table. This function is used to obtain the accelerator-table data that corresponds to an accelerator-table handle, or to determine the size of the accelerator-table data.
        /// </summary>
        /// <param name="hAccelSrc">Type: HACCELA handle to the accelerator table to copy.</param>
        /// <param name="lpAccelDst"></param>
        /// <param name="cAccelEntries">Type: intThe number of ACCEL structures to copy to the buffer pointed to by the lpAccelDst parameter.Type: intIf lpAccelDst is NULL, the return value specifies the number of accelerator-table entries in the original table. Otherwise, it specifies the number of accelerator-table entries that were copied.ACCELConceptualCreateAcceleratorTableDestroyAcceleratorTableKeyboard AcceleratorsLoadAcceleratorsReferenceTranslateAccelerator</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int CopyAcceleratorTableA(ACCEL hAccelSrc, out ACCEL lpAccelDst, int cAccelEntries);

        /// <summary>
        ///Copies the specified accelerator table. This function is used to obtain the accelerator-table data that corresponds to an accelerator-table handle, or to determine the size of the accelerator-table data.
        /// </summary>
        /// <param name="hAccelSrc">Type: HACCELA handle to the accelerator table to copy.</param>
        /// <param name="lpAccelDst"></param>
        /// <param name="cAccelEntries">Type: intThe number of ACCEL structures to copy to the buffer pointed to by the lpAccelDst parameter.Type: intIf lpAccelDst is NULL, the return value specifies the number of accelerator-table entries in the original table. Otherwise, it specifies the number of accelerator-table entries that were copied.ACCELConceptualCreateAcceleratorTableDestroyAcceleratorTableKeyboard AcceleratorsLoadAcceleratorsReferenceTranslateAccelerator</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int CopyAcceleratorTableW(ACCEL hAccelSrc, out ACCEL lpAccelDst, int cAccelEntries);

        /// <summary>
        ///Copies the specified icon from another module to the current module.
        /// </summary>
        /// <param name="hIcon">Type: HICONA handle to the icon to be copied.Type: HICONIf the function succeeds, the return value is a handle to the duplicate icon.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The CopyIcon function enables an application or DLL to get its own handle to an icon owned by another module. If the other module is freed, the application icon will still be able to use the icon.Before closing, an application must call the DestroyIcon function to free any system resources associated with the icon.ConceptualCopyCursorDestroyIconDrawIconDrawIconExIconsReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CopyIcon(nint hIcon);

        /// <summary>
        ///Creates a new image (icon, cursor, or bitmap) and copies the attributes of the specified image to the new one. If necessary, the function stretches the bits to fit the desired size of the new image.
        /// </summary>
        /// <param name="h">Type: HANDLEA handle to the image to be copied.</param>
        /// <param name="type">Type: UINTThe type of image to be copied. This parameter can be one of the following values.</param>
        /// <param name="cx">Type: intThe desired width, in pixels, of the image. If this is zero, then the returned image will have the same width as the original hImage.</param>
        /// <param name="cy">Type: intThe desired height, in pixels, of the image. If this is zero, then the returned image will have the same height as the original hImage.</param>
        /// <param name="flags">Type: UINTThis parameter can be one or more of the following values.Type: HANDLEIf the function succeeds, the return value is the handle to the newly created image.If the function fails, the return value is NULL. To get extended error information, call GetLastError.When you are finished using the resource, you can release its associated memory by calling one of the functions in the following table.The system automatically deletes the resource when its process terminates, however, calling the appropriate function saves memory and decreases the size of the process's working set.ConceptualLoadImageReferenceResources</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CopyImage(nint h, uint type, int cx, int cy, uint flags);

        /// <summary>
        ///The CopyRect function copies the coordinates of one rectangle to another.
        /// </summary>
        /// <param name="lprcDst"></param>
        /// <param name="lprcSrc">Pointer to the RECT structure whose coordinates are to be copied in logical units.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure.For an example, see Using Rectangles.RECTRectangle FunctionsRectangles OverviewSetRectSetRectEmpty</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CopyRect(out RECT lprcDst, RECT lprcSrc);

        /// <summary>
        ///Retrieves the number of different data formats currently on the clipboard.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int CountClipboardFormats();

        /// <summary>
        ///Creates an accelerator table.
        /// </summary>
        /// <param name="paccel">Type: LPACCELAn array of ACCEL structures that describes the accelerator table.</param>
        /// <param name="cAccel">Type: intThe number of ACCEL structures in the array. This must be within the range 1 to 32767 or the function will fail.Type: HACCELIf the function succeeds, the return value is the handle to the created accelerator table; otherwise, it is NULL. To get extended error information, call GetLastError.Before an application closes, it can use the DestroyAcceleratorTable function to destroy any accelerator tables that it created by using the CreateAcceleratorTable function.For an example, see Creating User Editable Accelerators.ACCELConceptualCopyAcceleratorTableDestroyAcceleratorTableKeyboard AcceleratorsLoadAcceleratorsReferenceTranslateAccelerator</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern ACCEL CreateAcceleratorTableA(ACCEL paccel, int cAccel);

        /// <summary>
        ///Creates an accelerator table.
        /// </summary>
        /// <param name="paccel">Type: LPACCELAn array of ACCEL structures that describes the accelerator table.</param>
        /// <param name="cAccel">Type: intThe number of ACCEL structures in the array. This must be within the range 1 to 32767 or the function will fail.Type: HACCELIf the function succeeds, the return value is the handle to the created accelerator table; otherwise, it is NULL. To get extended error information, call GetLastError.Before an application closes, it can use the DestroyAcceleratorTable function to destroy any accelerator tables that it created by using the CreateAcceleratorTable function.For an example, see Creating User Editable Accelerators.ACCELConceptualCopyAcceleratorTableDestroyAcceleratorTableKeyboard AcceleratorsLoadAcceleratorsReferenceTranslateAccelerator</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern ACCEL CreateAcceleratorTableW(ACCEL paccel, int cAccel);

        /// <summary>
        ///Creates a new shape for the system caret and assigns ownership of the caret to the specified window. The caret shape can be a line, a block, or a bitmap.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window that owns the caret.</param>
        /// <param name="hBitmap"></param>
        /// <param name="nWidth">Type: intThe width of the caret, in logical units. If this parameter is zero, the width is set to the system-defined window border width. If hBitmap is a bitmap handle, CreateCaret ignores this parameter.</param>
        /// <param name="nHeight">Type: intThe height of the caret, in logical units. If this parameter is zero, the height is set to the system-defined window border height. If hBitmap is a bitmap handle, CreateCaret ignores this parameter.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The nWidth and nHeight parameters specify the caret's width and height, in logical units; the exact width and height, in pixels, depend on the window's mapping mode.CreateCaret automatically destroys the previous caret shape, if any, regardless of the window that owns the caret. The caret is hidden until the application calls the ShowCaret function to make the caret visible.The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The window should destroy the caret before losing the keyboard focus or becoming inactive.CaretsConceptualCreateBitmapCreateDIBitmapDestroyCaretGetSystemMetricsHideCaretLoadBitmapOther ResourcesReferenceShowCaret</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CreateCaret(nint hWnd, nint hBitmap, int nWidth, int nHeight);

        /// <summary>
        ///Creates a monochrome cursor having the specified size, bit patterns, and hot spot.
        /// </summary>
        /// <param name="hInst"></param>
        /// <param name="xHotSpot">Type: intThe horizontal position of the cursor's hot spot.</param>
        /// <param name="yHotSpot">Type: intThe vertical position of the cursor's hot spot.</param>
        /// <param name="nWidth">Type: intThe width of the cursor, in pixels.</param>
        /// <param name="nHeight">Type: intThe height of the cursor, in pixels.</param>
        /// <param name="pvANDPlane">Type: const VOID*An array of bytes that contains the bit values for the AND mask of the cursor, as in a monochrome bitmap. See remarks.</param>
        /// <param name="pvXORPlane">Type: const VOID*An array of bytes that contains the bit values for the XOR mask of the cursor, as in a monochrome bitmap. See remarks.Type: HCURSORIf the function succeeds, the return value is a handle to the cursor.If the function fails, the return value is NULL. To get extended error information, call GetLastError.To determine the nominal size of a cursor, use the GetSystemMetrics function, specifying the SM_CXCURSOR or SM_CYCURSOR value. Also, you can use the DPI-aware version of this API, see (GetSystemMetricsForDpi)(/windows/win32/api/winuser/nf-winuser-getsystemmetricsfordpi). For more information see High DPI Desktop Application Development on Windows.For more information about pvANDPlane and pvXORPlane parameters see description of lpBits parameter of CreateBitmap function.CreateCursor applies the following truth table to the AND and XOR bitmasks:Before closing, an application must call the DestroyCursor function to free any system resources associated with the cursor.For an example, see Creating a Cursor.CreateIconCreateIconIndirectDestroyCursorGetSystemMetricsSetCursorCursors</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateCursor(nint hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, nint pvANDPlane, nint pvXORPlane);

        /// <summary>
        ///Creates a new desktop, associates it with the current window station of the calling process, and assigns it to the calling thread. The calling process must have an associated window station, either assigned by the system at process creation time or set by the SetProcessWindowStation function.
        /// </summary>
        /// <param name="lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).lpszDeviceReserved; must be NULL.pDevmodeReserved; must be NULL.</param>
        /// <param name="lpszDevice"></param>
        /// <param name="pDevmode"></param>
        /// <param name="dwFlags">This parameter can be zero or the following value.</param>
        /// <param name="dwDesiredAccess">The access to the desktop. For a list of values, see Desktop Security and Access Rights.This parameter must include the DESKTOP_CREATEWINDOW access right, because internally CreateDesktop uses the handle to create a window.</param>
        /// <param name="lpsa"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateDesktopA(string lpszDesktop, string lpszDevice, uint pDevmode, uint dwFlags, ACCESSTIMEOUT dwDesiredAccess, LUID_AND_ATTRIBUTES lpsa);

        /// <summary>
        ///Creates a new desktop with the specified heap, associates it with the current window station of the calling process, and assigns it to the calling thread. The calling process must have an associated window station, either assigned by the system at process creation time or set by the SetProcessWindowStation function.
        /// </summary>
        /// <param name="lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).lpszDeviceThis parameter is reserved and must be NULL.pDevmodeThis parameter is reserved and must be NULL.</param>
        /// <param name="lpszDevice"></param>
        /// <param name="pDevmode"></param>
        /// <param name="dwFlags">This parameter can be zero or the following value.</param>
        /// <param name="dwDesiredAccess">The requested access to the desktop. For a list of values, see Desktop Security and Access Rights.This parameter must include the DESKTOP_CREATEWINDOW access right, because internally CreateDesktop uses the handle to create a window.</param>
        /// <param name="lpsa"></param>
        /// <param name="ulHeapSize">The size of the desktop heap, in kilobytes.pvoidThis parameter is reserved and must be NULL.If the function succeeds, the return value is a handle to the newly created desktop. If the specified desktop already exists, the function succeeds and returns a handle to the existing desktop. When you are finished using the handle, call the CloseDesktop function to close it.If the function fails, the return value is NULL. To get extended error information, call GetLastError.If the dwDesiredAccess parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.The number of desktops that can be created is limited by the size of the system desktop heap. Desktop objects use the heap to store resources. You can increase the number of desktops that can be created by increasing the size of the desktop heap or by reducing the default heap reserved for each desktop in the interactive window station. This value is specified in the SharedSection substring of the following registry value: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems\Windows. The default data for this registry value is as follows:%SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows SharedSection=1024,3072,512 Windows=On SubSystemType=Windows ServerDll=basesrv,1 ServerDll=winsrv:UserServerDllInitialization,3 ServerDll=winsrv:ConServerDllInitialization,2 ProfileControl=Off MaxRequestThreads=16The values for the SharedSection substring are described as follows:The default size of the desktop heap depends on factors such as hardware architecture. To retrieve the size of the desktop heap, call the GetUserObjectInformation function with UOI_HEAPSIZE.CloseDesktopDesktopsSECURITY_ATTRIBUTESSetProcessWindowStationSwitchDesktopWindow Station and Desktop Functions</param>
        /// <param name="pvoid"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateDesktopExA(string lpszDesktop, string lpszDevice, uint pDevmode, uint dwFlags, ACCESSTIMEOUT dwDesiredAccess, LUID_AND_ATTRIBUTES lpsa, uint ulHeapSize, nint pvoid);

        /// <summary>
        ///Creates a new desktop with the specified heap, associates it with the current window station of the calling process, and assigns it to the calling thread. The calling process must have an associated window station, either assigned by the system at process creation time or set by the SetProcessWindowStation function.
        /// </summary>
        /// <param name="lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).lpszDeviceThis parameter is reserved and must be NULL.pDevmodeThis parameter is reserved and must be NULL.</param>
        /// <param name="lpszDevice"></param>
        /// <param name="pDevmode"></param>
        /// <param name="dwFlags">This parameter can be zero or the following value.</param>
        /// <param name="dwDesiredAccess">The requested access to the desktop. For a list of values, see Desktop Security and Access Rights.This parameter must include the DESKTOP_CREATEWINDOW access right, because internally CreateDesktop uses the handle to create a window.</param>
        /// <param name="lpsa"></param>
        /// <param name="ulHeapSize">The size of the desktop heap, in kilobytes.pvoidThis parameter is reserved and must be NULL.If the function succeeds, the return value is a handle to the newly created desktop. If the specified desktop already exists, the function succeeds and returns a handle to the existing desktop. When you are finished using the handle, call the CloseDesktop function to close it.If the function fails, the return value is NULL. To get extended error information, call GetLastError.If the dwDesiredAccess parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.The number of desktops that can be created is limited by the size of the system desktop heap. Desktop objects use the heap to store resources. You can increase the number of desktops that can be created by increasing the size of the desktop heap or by reducing the default heap reserved for each desktop in the interactive window station. This value is specified in the SharedSection substring of the following registry value: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems\Windows. The default data for this registry value is as follows:%SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows SharedSection=1024,3072,512 Windows=On SubSystemType=Windows ServerDll=basesrv,1 ServerDll=winsrv:UserServerDllInitialization,3 ServerDll=winsrv:ConServerDllInitialization,2 ProfileControl=Off MaxRequestThreads=16The values for the SharedSection substring are described as follows:The default size of the desktop heap depends on factors such as hardware architecture. To retrieve the size of the desktop heap, call the GetUserObjectInformation function with UOI_HEAPSIZE.CloseDesktopDesktopsSECURITY_ATTRIBUTESSetProcessWindowStationSwitchDesktopWindow Station and Desktop Functions</param>
        /// <param name="pvoid"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateDesktopExW(string lpszDesktop, string lpszDevice, uint pDevmode, uint dwFlags, ACCESSTIMEOUT dwDesiredAccess, LUID_AND_ATTRIBUTES lpsa, uint ulHeapSize, nint pvoid);

        /// <summary>
        ///Creates a new desktop, associates it with the current window station of the calling process, and assigns it to the calling thread. The calling process must have an associated window station, either assigned by the system at process creation time or set by the SetProcessWindowStation function.
        /// </summary>
        /// <param name="lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).lpszDeviceReserved; must be NULL.pDevmodeReserved; must be NULL.</param>
        /// <param name="lpszDevice"></param>
        /// <param name="pDevmode"></param>
        /// <param name="dwFlags">This parameter can be zero or the following value.</param>
        /// <param name="dwDesiredAccess">The access to the desktop. For a list of values, see Desktop Security and Access Rights.This parameter must include the DESKTOP_CREATEWINDOW access right, because internally CreateDesktop uses the handle to create a window.</param>
        /// <param name="lpsa"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateDesktopW(string lpszDesktop, string lpszDevice, uint pDevmode, uint dwFlags, ACCESSTIMEOUT dwDesiredAccess, LUID_AND_ATTRIBUTES lpsa);

        /// <summary>
        ///Creates a modeless dialog box from a dialog box template resource. The CreateDialog macro uses the CreateDialogParam function.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void CreateDialogA();

        /// <summary>
        ///Creates a modeless dialog box from a dialog box template in memory. The CreateDialogIndirect macro uses the CreateDialogIndirectParam function.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void CreateDialogIndirectA();

        /// <summary>
        ///Creates a modeless dialog box from a dialog box template in memory. Before displaying the dialog box, the function passes an application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can use this value to initialize dialog box controls.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpTemplate">Type: LPCDLGTEMPLATEThe template CreateDialogIndirectParam uses to create the dialog box. A dialog box template consists of a header that describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box. The template can use either the standard format or the extended format.In a standard template, the header is a DLGTEMPLATE structure followed by additional variable-length arrays. The data for each control consists of a DLGITEMTEMPLATE structure followed by additional variable-length arrays.In an extended dialog box template, the header uses the DLGTEMPLATEEX format and the control definitions use the DLGITEMTEMPLATEEX format.After CreateDialogIndirectParam returns, you can free the template, which is only used to get the dialog box started.</param>
        /// <param name="hWndParent"></param>
        /// <param name="lpDialogFunc"></param>
        /// <param name="dwInitParam">Type: LPARAMThe value to pass to the dialog box in the lParam parameter of the WM_INITDIALOG message.Type: HWNDIf the function succeeds, the return value is the window handle to the dialog box.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The CreateDialogIndirectParam function uses the CreateWindowEx function to create the dialog box. CreateDialogIndirectParam then sends a WM_INITDIALOG message to the dialog box procedure. If the template specifies the DS_SETFONT or DS_SHELLFONT style, the function also sends a WM_SETFONT message to the dialog box procedure. The function displays the dialog box if the template specifies the WS_VISIBLE style. Finally, CreateDialogIndirectParam returns the window handle to the dialog box.After CreateDialogIndirectParam returns, you can use the ShowWindow function to display the dialog box (if it is not already visible). To destroy the dialog box, use the DestroyWindow function. To support keyboard navigation and other dialog box functionality, the message loop for the dialog box must call the IsDialogMessage function.In a standard dialog box template, the DLGTEMPLATE structure and each of the DLGITEMTEMPLATE structures must be aligned on DWORD boundaries. The creation data array that follows a DLGITEMTEMPLATE structure must also be aligned on a DWORD boundary. All of the other variable-length arrays in the template must be aligned on WORD boundaries.In an extended dialog box template, the DLGTEMPLATEEX header and each of the DLGITEMTEMPLATEEX control definitions must be aligned on DWORD boundaries. The creation data array, if any, that follows a DLGITEMTEMPLATEEX structure must also be aligned on a DWORD boundary. All of the other variable-length arrays in the template must be aligned on WORD boundaries.All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings.ConceptualCreateDialogCreateDialogIndirectCreateDialogParamCreateWindowExDLGITEMTEMPLATEDLGITEMTEMPLATEEXDLGTEMPLATEDLGTEMPLATEEXDestroyWindowDialog BoxesDialogProcMultiByteToWideCharOther ResourcesReferenceShowWindowWM_INITDIALOGWM_SETFONT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateDialogIndirectParamA(nint hInstance, DLGTEMPLATE lpTemplate, nint hWndParent, DLGPROC lpDialogFunc, nint dwInitParam);

        /// <summary>
        ///Creates a modeless dialog box from a dialog box template in memory. Before displaying the dialog box, the function passes an application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can use this value to initialize dialog box controls.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpTemplate">Type: LPCDLGTEMPLATEThe template CreateDialogIndirectParam uses to create the dialog box. A dialog box template consists of a header that describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box. The template can use either the standard format or the extended format.In a standard template, the header is a DLGTEMPLATE structure followed by additional variable-length arrays. The data for each control consists of a DLGITEMTEMPLATE structure followed by additional variable-length arrays.In an extended dialog box template, the header uses the DLGTEMPLATEEX format and the control definitions use the DLGITEMTEMPLATEEX format.After CreateDialogIndirectParam returns, you can free the template, which is only used to get the dialog box started.</param>
        /// <param name="hWndParent"></param>
        /// <param name="lpDialogFunc"></param>
        /// <param name="dwInitParam">Type: LPARAMThe value to pass to the dialog box in the lParam parameter of the WM_INITDIALOG message.Type: HWNDIf the function succeeds, the return value is the window handle to the dialog box.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The CreateDialogIndirectParam function uses the CreateWindowEx function to create the dialog box. CreateDialogIndirectParam then sends a WM_INITDIALOG message to the dialog box procedure. If the template specifies the DS_SETFONT or DS_SHELLFONT style, the function also sends a WM_SETFONT message to the dialog box procedure. The function displays the dialog box if the template specifies the WS_VISIBLE style. Finally, CreateDialogIndirectParam returns the window handle to the dialog box.After CreateDialogIndirectParam returns, you can use the ShowWindow function to display the dialog box (if it is not already visible). To destroy the dialog box, use the DestroyWindow function. To support keyboard navigation and other dialog box functionality, the message loop for the dialog box must call the IsDialogMessage function.In a standard dialog box template, the DLGTEMPLATE structure and each of the DLGITEMTEMPLATE structures must be aligned on DWORD boundaries. The creation data array that follows a DLGITEMTEMPLATE structure must also be aligned on a DWORD boundary. All of the other variable-length arrays in the template must be aligned on WORD boundaries.In an extended dialog box template, the DLGTEMPLATEEX header and each of the DLGITEMTEMPLATEEX control definitions must be aligned on DWORD boundaries. The creation data array, if any, that follows a DLGITEMTEMPLATEEX structure must also be aligned on a DWORD boundary. All of the other variable-length arrays in the template must be aligned on WORD boundaries.All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings.ConceptualCreateDialogCreateDialogIndirectCreateDialogParamCreateWindowExDLGITEMTEMPLATEDLGITEMTEMPLATEEXDLGTEMPLATEDLGTEMPLATEEXDestroyWindowDialog BoxesDialogProcMultiByteToWideCharOther ResourcesReferenceShowWindowWM_INITDIALOGWM_SETFONT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateDialogIndirectParamW(nint hInstance, DLGTEMPLATE lpTemplate, nint hWndParent, DLGPROC lpDialogFunc, nint dwInitParam);

        /// <summary>
        ///Creates a modeless dialog box from a dialog box template in memory. The CreateDialogIndirect macro uses the CreateDialogIndirectParam function.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void CreateDialogIndirectW();

        /// <summary>
        ///Creates a modeless dialog box from a dialog box template resource. Before displaying the dialog box, the function passes an application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can use this value to initialize dialog box controls.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpTemplateName">Type: LPCTSTRThe dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier, its high-order word must be zero and low-order word must contain the identifier. You can use the MAKEINTRESOURCE macro to create this value.</param>
        /// <param name="hWndParent"></param>
        /// <param name="lpDialogFunc"></param>
        /// <param name="dwInitParam">Type: LPARAMThe value to be passed to the dialog box procedure in the lParam parameter in the WM_INITDIALOG message.Type: HWNDIf the function succeeds, the return value is the window handle to the dialog box.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The CreateDialogParam function uses the CreateWindowEx function to create the dialog box. CreateDialogParam then sends a WM_INITDIALOG message (and a WM_SETFONT message if the template specifies the DS_SETFONT or DS_SHELLFONT style) to the dialog box procedure. The function displays the dialog box if the template specifies the WS_VISIBLE style. Finally, CreateDialogParam returns the window handle of the dialog box.After CreateDialogParam returns, the application displays the dialog box (if it is not already displayed) using the ShowWindow function. The application destroys the dialog box by using the DestroyWindow function. To support keyboard navigation and other dialog box functionality, the message loop for the dialog box must call the IsDialogMessage function.ConceptualCreateDialogCreateDialogIndirectCreateDialogIndirectParamCreateWindowExDestroyWindowDialog BoxesDialogProcIsDialogMessageMAKEINTRESOURCEReferenceShowWindowWM_INITDIALOGWM_SETFONT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateDialogParamA(nint hInstance, string lpTemplateName, nint hWndParent, DLGPROC lpDialogFunc, nint dwInitParam);

        /// <summary>
        ///Creates a modeless dialog box from a dialog box template resource. Before displaying the dialog box, the function passes an application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can use this value to initialize dialog box controls.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpTemplateName">Type: LPCTSTRThe dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier, its high-order word must be zero and low-order word must contain the identifier. You can use the MAKEINTRESOURCE macro to create this value.</param>
        /// <param name="hWndParent"></param>
        /// <param name="lpDialogFunc"></param>
        /// <param name="dwInitParam">Type: LPARAMThe value to be passed to the dialog box procedure in the lParam parameter in the WM_INITDIALOG message.Type: HWNDIf the function succeeds, the return value is the window handle to the dialog box.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The CreateDialogParam function uses the CreateWindowEx function to create the dialog box. CreateDialogParam then sends a WM_INITDIALOG message (and a WM_SETFONT message if the template specifies the DS_SETFONT or DS_SHELLFONT style) to the dialog box procedure. The function displays the dialog box if the template specifies the WS_VISIBLE style. Finally, CreateDialogParam returns the window handle of the dialog box.After CreateDialogParam returns, the application displays the dialog box (if it is not already displayed) using the ShowWindow function. The application destroys the dialog box by using the DestroyWindow function. To support keyboard navigation and other dialog box functionality, the message loop for the dialog box must call the IsDialogMessage function.ConceptualCreateDialogCreateDialogIndirectCreateDialogIndirectParamCreateWindowExDestroyWindowDialog BoxesDialogProcIsDialogMessageMAKEINTRESOURCEReferenceShowWindowWM_INITDIALOGWM_SETFONT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateDialogParamW(nint hInstance, string lpTemplateName, nint hWndParent, DLGPROC lpDialogFunc, nint dwInitParam);

        /// <summary>
        ///Creates a modeless dialog box from a dialog box template resource. The CreateDialog macro uses the CreateDialogParam function.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void CreateDialogW();

        /// <summary>
        ///Creates an icon that has the specified size, colors, and bit patterns.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="nWidth">Type: intThe width, in pixels, of the icon. See remarks.</param>
        /// <param name="nHeight">Type: intThe height, in pixels, of the icon. See remarks.</param>
        /// <param name="cPlanes">Type: BYTEThe number of planes in the XOR bitmask of the icon. See remarks.</param>
        /// <param name="cBitsPixel">Type: BYTEThe number of bits-per-pixel in the XOR bitmask of the icon.</param>
        /// <param name="lpbANDbits">Type: const BYTE*An array of bytes that contains the bit values for the AND bitmask of the icon. This bitmask describes a monochrome bitmap. See remarks.</param>
        /// <param name="lpbXORbits">Type: const BYTE*An array of bytes that contains the bit values for the XOR bitmask of the icon. This bitmask describes a monochrome or color bitmap. See remarks.Type: HICONIf the function succeeds, the return value is a handle to an icon.If the function fails, the return value is NULL. To get extended error information, call GetLastError.To determine the nominal size of the icon, use the GetSystemMetrics function, specifying the SM_CXICON or SM_CYICON value. Also, you can use the DPI-aware version of this API, see (GetSystemMetricsForDpi)(/windows/win32/api/winuser/nf-winuser-getsystemmetricsfordpi). For more information see Icon Sizes and High DPI Desktop Application Development on Windows.For more information about lpbANDbits and lpbXORbits parameters see description of lpBits parameter of CreateBitmap function.In case of monochrome icon CreateIcon applies the following truth table to the AND and XOR bitmasks:When you are finished using the icon, destroy it using the DestroyIcon function.For an example, see Creating an Icon.CreateIconIndirectIconsIcon Sizes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateIcon(nint hInstance, int nWidth, int nHeight, byte cPlanes, byte cBitsPixel, byte lpbANDbits, byte lpbXORbits);

        /// <summary>
        ///Creates an icon or cursor from resource bits describing the icon.
        /// </summary>
        /// <param name="presbits">Type: PBYTEThe DWORD-aligned buffer pointer containing the icon or cursor resource bits. These bits are typically loaded by calls to the LookupIconIdFromDirectory, LookupIconIdFromDirectoryEx, and LoadResource functions.See Cursor and Icon Resources for more info on icon and cursor resource format.</param>
        /// <param name="dwResSize">Type: DWORDThe size, in bytes, of the set of bits pointed to by the presbits parameter.</param>
        /// <param name="fIcon">Type: BOOLIndicates whether an icon or a cursor is to be created. If this parameter is TRUE, an icon is to be created. If it is FALSE, a cursor is to be created.The LOCALHEADER structure defines cursor hotspot and is the first data read from the cursor resource bits.</param>
        /// <param name="dwVer">Type: DWORDThe version number of the icon or cursor format for the resource bits pointed to by the presbits parameter. The value must be greater than or equal to 0x00020000 and less than or equal to 0x00030000. This parameter is generally set to 0x00030000.Type: HICONIf the function succeeds, the return value is a handle to the icon or cursor.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The CreateIconFromResource, CreateIconFromResourceEx, CreateIconIndirect, GetIconInfo, LookupIconIdFromDirectory, and LookupIconIdFromDirectoryEx functions allow shell applications and icon browsers to examine and use resources throughout the system.The CreateIconFromResource function calls CreateIconFromResourceEx passing LR_DEFAULTSIZE|LR_SHARED as flags.You should call DestroyIcon for icons or DestroyCursor for cursors created with CreateIconFromResource.ConceptualCreateIconFromResourceExCreateIconIndirectGetIconInfoIconsLoadResourceLookupIconIdFromDirectoryLookupIconIdFromDirectoryExReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateIconFromResource(byte presbits, uint dwResSize, bool fIcon, uint dwVer);

        /// <summary>
        ///Creates an icon or cursor from resource bits describing the icon.
        /// </summary>
        /// <param name="presbits">Type: PBYTEThe DWORD-aligned buffer pointer containing the icon (RT_ICON) or cursor (RT_CURSOR) resource bits. These bits are typically loaded by calls to the LookupIconIdFromDirectoryEx and LoadResource functions.See Cursor and Icon Resources for more info on icon and cursor resource format.</param>
        /// <param name="dwResSize">Type: DWORDThe size, in bytes, of the set of bits pointed to by the pbIconBits parameter.</param>
        /// <param name="fIcon">Type: BOOLIndicates whether an icon or a cursor is to be created. If this parameter is TRUE, an icon is to be created. If it is FALSE, a cursor is to be created.The LOCALHEADER structure defines cursor hotspot and is the first data read from the cursor resource bits.</param>
        /// <param name="dwVer">Type: DWORDThe version number of the icon or cursor format for the resource bits pointed to by the presbits parameter. The value must be greater than or equal to 0x00020000 and less than or equal to 0x00030000. This parameter is generally set to 0x00030000.</param>
        /// <param name="cxDesired">Type: intThe width, in pixels, of the icon or cursor. If this parameter is zero and the Flags parameter is LR_DEFAULTSIZE, the function uses the SM_CXICON or SM_CXCURSOR system metric value to set the width. If this parameter is zero and LR_DEFAULTSIZE is not used, the function uses the actual resource width.</param>
        /// <param name="cyDesired">Type: intThe height, in pixels, of the icon or cursor. If this parameter is zero and the Flags parameter is LR_DEFAULTSIZE, the function uses the SM_CYICON or SM_CYCURSOR system metric value to set the height. If this parameter is zero and LR_DEFAULTSIZE is not used, the function uses the actual resource height.</param>
        /// <param name="Flags">Type: UINTA combination of the following values.Type: HICONIf the function succeeds, the return value is a handle to the icon or cursor.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The CreateIconFromResource, CreateIconFromResourceEx, CreateIconIndirect, GetIconInfo, and LookupIconIdFromDirectoryEx functions allow shell applications and icon browsers to examine and use resources throughout the system.You should call DestroyIcon for icons or DestroyCursor for cursors created with CreateIconFromResourceEx.For an example, see Sharing Icon Resources.BITMAPINFOHEADERConceptualCreateIconFromResourceCreateIconIndirectDestroyIconGetIconInfoIconsLoadResourceLookupIconIdFromDirectoryExOther ResourcesReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateIconFromResourceEx(byte presbits, uint dwResSize, bool fIcon, uint dwVer, int cxDesired, int cyDesired, uint Flags);

        /// <summary>
        ///Creates an icon or cursor from an ICONINFO structure.
        /// </summary>
        /// <param name="piconinfo">Type: PICONINFOA pointer to an ICONINFO structure the function uses to create the icon or cursor.Type: HICONIf the function succeeds, the return value is a handle to the icon or cursor that is created.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The system copies the bitmaps in the ICONINFO structure before creating the icon or cursor. Because the system may temporarily select the bitmaps in a device context, the hbmMask and hbmColor members of the ICONINFO structure should not already be selected into a device context. The application must continue to manage the original bitmaps and delete them when they are no longer necessary.When you are finished using the icon, destroy it using the DestroyIcon function.For an example, see Creating a Cursor.ConceptualDestroyIconICONINFOIcons</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateIconIndirect(ICONINFO piconinfo);

        /// <summary>
        ///Creates a multiple-document interface (MDI) child window.
        /// </summary>
        /// <param name="lpClassName">Type: LPCTSTRThe window class of the MDI child window. The class name must have been registered by a call to the RegisterClassEx function.</param>
        /// <param name="lpWindowName">Type: LPCTSTRThe window name. The system displays the name in the title bar of the child window.</param>
        /// <param name="dwStyle">Type: DWORDThe style of the MDI child window. If the MDI client window is created with the MDIS_ALLCHILDSTYLES window style, this parameter can be any combination of the window styles listed in the Window Styles page. Otherwise, this parameter is limited to one or more of the following values.</param>
        /// <param name="X">Type: intThe initial horizontal position, in client coordinates, of the MDI child window. If this parameter is CW_USEDEFAULT ((int)0x80000000), the MDI child window is assigned the default horizontal position.</param>
        /// <param name="Y">Type: intThe initial vertical position, in client coordinates, of the MDI child window. If this parameter is CW_USEDEFAULT, the MDI child window is assigned the default vertical position.</param>
        /// <param name="nWidth">Type: intThe initial width, in device units, of the MDI child window. If this parameter is CW_USEDEFAULT, the MDI child window is assigned the default width.</param>
        /// <param name="nHeight">Type: intThe initial height, in device units, of the MDI child window. If this parameter is set to CW_USEDEFAULT, the MDI child window is assigned the default height.</param>
        /// <param name="hWndParent"></param>
        /// <param name="hInstance"></param>
        /// <param name="lParam">Type: LPARAMAn application-defined value.Type: HWNDIf the function succeeds, the return value is the handle to the created window.If the function fails, the return value is NULL. To get extended error information, call GetLastError.ConceptualCreateWindowMultiple Document InterfaceReferenceRegisterClassExWM_MDICREATE</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateMDIWindowA(string lpClassName, string lpWindowName, uint dwStyle, int X, int Y, int nWidth, int nHeight, nint hWndParent, nint hInstance, nint lParam);

        /// <summary>
        ///Creates a multiple-document interface (MDI) child window.
        /// </summary>
        /// <param name="lpClassName">Type: LPCTSTRThe window class of the MDI child window. The class name must have been registered by a call to the RegisterClassEx function.</param>
        /// <param name="lpWindowName">Type: LPCTSTRThe window name. The system displays the name in the title bar of the child window.</param>
        /// <param name="dwStyle">Type: DWORDThe style of the MDI child window. If the MDI client window is created with the MDIS_ALLCHILDSTYLES window style, this parameter can be any combination of the window styles listed in the Window Styles page. Otherwise, this parameter is limited to one or more of the following values.</param>
        /// <param name="X">Type: intThe initial horizontal position, in client coordinates, of the MDI child window. If this parameter is CW_USEDEFAULT ((int)0x80000000), the MDI child window is assigned the default horizontal position.</param>
        /// <param name="Y">Type: intThe initial vertical position, in client coordinates, of the MDI child window. If this parameter is CW_USEDEFAULT, the MDI child window is assigned the default vertical position.</param>
        /// <param name="nWidth">Type: intThe initial width, in device units, of the MDI child window. If this parameter is CW_USEDEFAULT, the MDI child window is assigned the default width.</param>
        /// <param name="nHeight">Type: intThe initial height, in device units, of the MDI child window. If this parameter is set to CW_USEDEFAULT, the MDI child window is assigned the default height.</param>
        /// <param name="hWndParent"></param>
        /// <param name="hInstance"></param>
        /// <param name="lParam">Type: LPARAMAn application-defined value.Type: HWNDIf the function succeeds, the return value is the handle to the created window.If the function fails, the return value is NULL. To get extended error information, call GetLastError.ConceptualCreateWindowMultiple Document InterfaceReferenceRegisterClassExWM_MDICREATE</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateMDIWindowW(string lpClassName, string lpWindowName, uint dwStyle, int X, int Y, int nWidth, int nHeight, nint hWndParent, nint hInstance, nint lParam);

        /// <summary>
        ///Creates a menu. The menu is initially empty, but it can be filled with menu items by using the InsertMenuItem, AppendMenu, and InsertMenu functions.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateMenu();

        /// <summary>
        ///Creates a drop-down menu, submenu, or shortcut menu. The menu is initially empty. You can insert or append menu items by using the InsertMenuItem function. You can also use the InsertMenu function to insert menu items and the AppendMenu function to append menu items.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreatePopupMenu();

        /// <summary>
        ///Configures the pointer injection device for the calling application, and initializes the maximum number of simultaneous pointers that the app can inject.
        /// </summary>
        /// <param name="pointerType">The pointer injection device type. Must be either PT_TOUCH or PT_PEN.</param>
        /// <param name="maxCount">The maximum number of contacts.For PT_TOUCH this value must be greater than 0 and less than or equal to MAX_TOUCH_COUNT.For PT_PEN this value must be 1.</param>
        /// <param name="mode">The contact visualization mode.If the function succeeds, the return value is a handle to the pointer injection device. Otherwise, it returns null. To retrieve extended error information, call the GetLastError function.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern EMRSETDIBITSTODEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, uint maxCount, POINTER_FEEDBACK_MODE mode);

        /// <summary>
        ///Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the CreateWindow function. For more information about creating a window and for full descriptions of the other parameters of CreateWindowEx, see CreateWindow.
        /// </summary>
        /// <param name="dwExStyle">Type: DWORDThe extended window style of the window being created. For a list of possible values, see Extended Window Styles.</param>
        /// <param name="lpClassName"></param>
        /// <param name="lpWindowName"></param>
        /// <param name="dwStyle">Type: DWORDThe style of the window being created. This parameter can be a combination of the window style values, plus the control styles indicated in the Remarks section.</param>
        /// <param name="X">Type: intThe initial horizontal position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window's client area. If x is set to CW_USEDEFAULT, the system selects the default position for the window's upper-left corner and ignores the y parameter. CW_USEDEFAULT is valid only for overlapped windows; if it is specified for a pop-up or child window, the x and y parameters are set to zero.</param>
        /// <param name="Y">Type: intThe initial vertical position of the window. For an overlapped or pop-up window, the y parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates. For a child window, y is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left corner of the parent window's client area. For a list box y is the initial y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's client area.If an overlapped window is created with the WS_VISIBLE style bit set and the x parameter is set to CW_USEDEFAULT, then the y parameter determines how the window is shown. If the y parameter is CW_USEDEFAULT, then the window manager calls ShowWindow with the SW_SHOW flag after the window has been created. If the y parameter is some other value, then the window manager calls ShowWindow with that value as the nCmdShow parameter.</param>
        /// <param name="nWidth">Type: intThe width, in device units, of the window. For overlapped windows, nWidth is the window's width, in screen coordinates, or CW_USEDEFAULT. If nWidth is CW_USEDEFAULT, the system selects a default width and height for the window; the default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial y-coordinate to the top of the icon area. CW_USEDEFAULT is valid only for overlapped windows; if CW_USEDEFAULT is specified for a pop-up or child window, the nWidth and nHeight parameter are set to zero.</param>
        /// <param name="nHeight">Type: intThe height, in device units, of the window. For overlapped windows, nHeight is the window's height, in screen coordinates. If the nWidth parameter is set to CW_USEDEFAULT, the system ignores nHeight.</param>
        /// <param name="hWndParent"></param>
        /// <param name="hMenu"></param>
        /// <param name="hInstance"></param>
        /// <param name="lpParam"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateWindowExA(uint dwExStyle, string lpClassName, string lpWindowName, uint dwStyle, int X, int Y, int nWidth, int nHeight, nint hWndParent, nint hMenu, nint hInstance, nint lpParam);

        /// <summary>
        ///Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the CreateWindow function. For more information about creating a window and for full descriptions of the other parameters of CreateWindowEx, see CreateWindow.
        /// </summary>
        /// <param name="dwExStyle">Type: DWORDThe extended window style of the window being created. For a list of possible values, see Extended Window Styles.</param>
        /// <param name="lpClassName"></param>
        /// <param name="lpWindowName"></param>
        /// <param name="dwStyle">Type: DWORDThe style of the window being created. This parameter can be a combination of the window style values, plus the control styles indicated in the Remarks section.</param>
        /// <param name="X">Type: intThe initial horizontal position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window's client area. If x is set to CW_USEDEFAULT, the system selects the default position for the window's upper-left corner and ignores the y parameter. CW_USEDEFAULT is valid only for overlapped windows; if it is specified for a pop-up or child window, the x and y parameters are set to zero.</param>
        /// <param name="Y">Type: intThe initial vertical position of the window. For an overlapped or pop-up window, the y parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates. For a child window, y is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left corner of the parent window's client area. For a list box y is the initial y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's client area.If an overlapped window is created with the WS_VISIBLE style bit set and the x parameter is set to CW_USEDEFAULT, then the y parameter determines how the window is shown. If the y parameter is CW_USEDEFAULT, then the window manager calls ShowWindow with the SW_SHOW flag after the window has been created. If the y parameter is some other value, then the window manager calls ShowWindow with that value as the nCmdShow parameter.</param>
        /// <param name="nWidth">Type: intThe width, in device units, of the window. For overlapped windows, nWidth is the window's width, in screen coordinates, or CW_USEDEFAULT. If nWidth is CW_USEDEFAULT, the system selects a default width and height for the window; the default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial y-coordinate to the top of the icon area. CW_USEDEFAULT is valid only for overlapped windows; if CW_USEDEFAULT is specified for a pop-up or child window, the nWidth and nHeight parameter are set to zero.</param>
        /// <param name="nHeight">Type: intThe height, in device units, of the window. For overlapped windows, nHeight is the window's height, in screen coordinates. If the nWidth parameter is set to CW_USEDEFAULT, the system ignores nHeight.</param>
        /// <param name="hWndParent"></param>
        /// <param name="hMenu"></param>
        /// <param name="hInstance"></param>
        /// <param name="lpParam"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint CreateWindowExW(uint dwExStyle, string lpClassName, string lpWindowName, uint dwStyle, int X, int Y, int nWidth, int nHeight, nint hWndParent, nint hMenu, nint hInstance, nint lpParam);

        /// <summary>
        ///Creates a window station object, associates it with the calling process, and assigns it to the current session.
        /// </summary>
        /// <param name="lpwinsta"></param>
        /// <param name="dwFlags"></param>
        /// <param name="dwDesiredAccess">The type of access the returned handle has to the window station. In addition, you can specify any of the standard access rights, such as READ_CONTROL or WRITE_DAC, and a combination of the window station-specific access rights. For more information, see Window Station Security and Access Rights.</param>
        /// <param name="lpsa"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int CreateWindowStationA(string lpwinsta, uint dwFlags, ACCESSTIMEOUT dwDesiredAccess, LUID_AND_ATTRIBUTES lpsa);

        /// <summary>
        ///Creates a window station object, associates it with the calling process, and assigns it to the current session.
        /// </summary>
        /// <param name="lpwinsta"></param>
        /// <param name="dwFlags"></param>
        /// <param name="dwDesiredAccess">The type of access the returned handle has to the window station. In addition, you can specify any of the standard access rights, such as READ_CONTROL or WRITE_DAC, and a combination of the window station-specific access rights. For more information, see Window Station Security and Access Rights.</param>
        /// <param name="lpsa"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int CreateWindowStationW(string lpwinsta, uint dwFlags, ACCESSTIMEOUT dwDesiredAccess, LUID_AND_ATTRIBUTES lpsa);

        /// <summary>
        ///Calls the default dialog box window procedure to provide default processing for any window messages that a dialog box with a private window class does not process.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box.</param>
        /// <param name="Msg">Type: UINTThe message.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: LRESULTThe return value specifies the result of the message processing and depends on the message sent.The DefDlgProc function is the window procedure for the predefined class of dialog box. This procedure provides internal processing for the dialog box by forwarding messages to the dialog box procedure and carrying out default processing for any messages that the dialog box procedure returns as FALSE. Applications that create custom window procedures for their custom dialog boxes often use DefDlgProc instead of the DefWindowProc function to carry out default message processing.Applications create custom dialog box classes by filling a WNDCLASS structure with appropriate information and registering the class with the RegisterClass function. Some applications fill the structure by using the GetClassInfo function, specifying the name of the predefined dialog box. In such cases, the applications modify at least the lpszClassName member before registering. In all cases, the cbWndExtra member of WNDCLASS for a custom dialog box class must be set to at least DLGWINDOWEXTRA.The DefDlgProc function must not be called by a dialog box procedure; doing so results in recursive execution.ConceptualDefWindowProc Dialog Boxes GetClassInfoReferenceRegisterClass WNDCLASS</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DefDlgProcA(nint hDlg, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Calls the default dialog box window procedure to provide default processing for any window messages that a dialog box with a private window class does not process.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box.</param>
        /// <param name="Msg">Type: UINTThe message.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: LRESULTThe return value specifies the result of the message processing and depends on the message sent.The DefDlgProc function is the window procedure for the predefined class of dialog box. This procedure provides internal processing for the dialog box by forwarding messages to the dialog box procedure and carrying out default processing for any messages that the dialog box procedure returns as FALSE. Applications that create custom window procedures for their custom dialog boxes often use DefDlgProc instead of the DefWindowProc function to carry out default message processing.Applications create custom dialog box classes by filling a WNDCLASS structure with appropriate information and registering the class with the RegisterClass function. Some applications fill the structure by using the GetClassInfo function, specifying the name of the predefined dialog box. In such cases, the applications modify at least the lpszClassName member before registering. In all cases, the cbWndExtra member of WNDCLASS for a custom dialog box class must be set to at least DLGWINDOWEXTRA.The DefDlgProc function must not be called by a dialog box procedure; doing so results in recursive execution.ConceptualDefWindowProcDialog BoxesGetClassInfoReferenceRegisterClassWNDCLASS</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DefDlgProcW(nint hDlg, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Updates the specified multiple-window – position structure for the specified window. The function then returns a handle to the updated structure. The EndDeferWindowPos function uses the information in this structure to change the position and size of a number of windows simultaneously. The BeginDeferWindowPos function creates the structure.
        /// </summary>
        /// <param name="hWinPosInfo">Type: HDWPA handle to a multiple-window – position structure that contains size and position information for one or more windows. This structure is returned by BeginDeferWindowPos or by the most recent call to DeferWindowPos.</param>
        /// <param name="hWnd">Type: HWNDA handle to the window for which update information is stored in the structure. All windows in a multiple-window – position structure must have the same parent.</param>
        /// <param name="hWndInsertAfter"></param>
        /// <param name="x">Type: intThe x-coordinate of the window's upper-left corner.</param>
        /// <param name="y">Type: intThe y-coordinate of the window's upper-left corner.</param>
        /// <param name="cx">Type: intThe window's new width, in pixels.</param>
        /// <param name="cy">Type: intThe window's new height, in pixels.</param>
        /// <param name="uFlags">Type: UINTA combination of the following values that affect the size and position of the window.Type: HDWPThe return value identifies the updated multiple-window – position structure. The handle returned by this function may differ from the handle passed to the function. The new handle that this function returns should be passed during the next call to the DeferWindowPos or EndDeferWindowPos function.If insufficient system resources are available for the function to succeed, the return value is NULL. To get extended error information, call GetLastError.If a call to DeferWindowPos fails, the application should abandon the window-positioning operation and not call EndDeferWindowPos.If SWP_NOZORDER is not specified, the system places the window identified by the hWnd parameter in the position following the window identified by the hWndInsertAfter parameter. If hWndInsertAfter is NULL or HWND_TOP, the system places the hWnd window at the top of the Z order. If hWndInsertAfter is set to HWND_BOTTOM, the system places the hWnd window at the bottom of the Z order.All coordinates for child windows are relative to the upper-left corner of the parent window's client area.A window can be made a topmost window either by setting hWndInsertAfter to the HWND_TOPMOST flag and ensuring that the SWP_NOZORDER flag is not set, or by setting the window's position in the Z order so that it is above any existing topmost windows. When a non-topmost window is made topmost, its owned windows are also made topmost. Its owners, however, are not changed.If neither the SWP_NOACTIVATE nor SWP_NOZORDER flag is specified (that is, when the application requests that a window be simultaneously activated and its position in the Z order changed), the value specified in hWndInsertAfter is used only in the following circumstances:A topmost window is no longer topmost if it is repositioned to the bottom (HWND_BOTTOM) of the Z order or after any non-topmost window. When a topmost window is made non-topmost, its owners and its owned windows are also made non-topmost windows.A non-topmost window may own a topmost window, but not vice versa. Any window (for example, a dialog box) owned by a topmost window is itself made a topmost window to ensure that all owned windows stay above their owner.BeginDeferWindowPosConceptualEndDeferWindowPosReferenceShowWindowWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DeferWindowPos(nint hWinPosInfo, nint hWnd, nint hWndInsertAfter, int x, int y, int cx, int cy, uint uFlags);

        /// <summary>
        ///Provides default processing for any window messages that the window procedure of a multiple-document interface (MDI) frame window does not process. All window messages that are not explicitly processed by the window procedure must be passed to the DefFrameProc function, not the DefWindowProc function.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the MDI frame window.</param>
        /// <param name="hWndMDIClient">Type: HWNDA handle to the MDI client window.</param>
        /// <param name="uMsg">Type: UINTThe message to be processed.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: LRESULTThe return value specifies the result of the message processing and depends on the message. If the hWndMDIClient parameter is NULL, the return value is the same as for the DefWindowProc function.When an application's window procedure does not handle a message, it typically passes the message to the DefWindowProc function to process the message. MDI applications use the DefFrameProc and DefMDIChildProc functions instead of DefWindowProc to provide default message processing. All messages that an application would usually pass to DefWindowProc (such as nonclient messages and the WM_SETTEXT message) should be passed to DefFrameProc instead. The DefFrameProc function also handles the following messages.ConceptualDefMDIChildProcDefWindowProcMultiple Document InterfaceReferenceWM_SETTEXT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DefFrameProcA(nint hWnd, nint hWndMDIClient, uint uMsg, nint wParam, nint lParam);

        /// <summary>
        ///Provides default processing for any window messages that the window procedure of a multiple-document interface (MDI) frame window does not process. All window messages that are not explicitly processed by the window procedure must be passed to the DefFrameProc function, not the DefWindowProc function.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the MDI frame window.</param>
        /// <param name="hWndMDIClient">Type: HWNDA handle to the MDI client window.</param>
        /// <param name="uMsg">Type: UINTThe message to be processed.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: LRESULTThe return value specifies the result of the message processing and depends on the message. If the hWndMDIClient parameter is NULL, the return value is the same as for the DefWindowProc function.When an application's window procedure does not handle a message, it typically passes the message to the DefWindowProc function to process the message. MDI applications use the DefFrameProc and DefMDIChildProc functions instead of DefWindowProc to provide default message processing. All messages that an application would usually pass to DefWindowProc (such as nonclient messages and the WM_SETTEXT message) should be passed to DefFrameProc instead. The DefFrameProc function also handles the following messages.ConceptualDefMDIChildProcDefWindowProcMultiple Document InterfaceReferenceWM_SETTEXT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DefFrameProcW(nint hWnd, nint hWndMDIClient, uint uMsg, nint wParam, nint lParam);

        /// <summary>
        ///Provides default processing for any window message that the window procedure of a multiple-document interface (MDI) child window does not process. A window message not processed by the window procedure must be passed to the DefMDIChildProc function, not to the DefWindowProc function.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the MDI child window.</param>
        /// <param name="uMsg">Type: UINTThe message to be processed.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: LRESULTThe return value specifies the result of the message processing and depends on the message.The DefMDIChildProc function assumes that the parent window of the MDI child window identified by the hWnd parameter was created with the MDICLIENT class.When an application's window procedure does not handle a message, it typically passes the message to the DefWindowProc function to process the message. MDI applications use the DefFrameProc and DefMDIChildProc functions instead of DefWindowProc to provide default message processing. All messages that an application would usually pass to DefWindowProc (such as nonclient messages and the WM_SETTEXT message) should be passed to DefMDIChildProc instead. In addition, DefMDIChildProc also handles the following messages.ConceptualDefFrameProcDefWindowProcMultiple Document InterfaceReferenceWM_CHILDACTIVATEWM_GETMINMAXINFOWM_MENUCHARWM_MOVEWM_SETFOCUSWM_SETTEXTWM_SIZEWM_SYSCOMMAND</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DefMDIChildProcA(nint hWnd, uint uMsg, nint wParam, nint lParam);

        /// <summary>
        ///Provides default processing for any window message that the window procedure of a multiple-document interface (MDI) child window does not process. A window message not processed by the window procedure must be passed to the DefMDIChildProc function, not to the DefWindowProc function.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the MDI child window.</param>
        /// <param name="uMsg">Type: UINTThe message to be processed.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: LRESULTThe return value specifies the result of the message processing and depends on the message.The DefMDIChildProc function assumes that the parent window of the MDI child window identified by the hWnd parameter was created with the MDICLIENT class.When an application's window procedure does not handle a message, it typically passes the message to the DefWindowProc function to process the message. MDI applications use the DefFrameProc and DefMDIChildProc functions instead of DefWindowProc to provide default message processing. All messages that an application would usually pass to DefWindowProc (such as nonclient messages and the WM_SETTEXT message) should be passed to DefMDIChildProc instead. In addition, DefMDIChildProc also handles the following messages.ConceptualDefFrameProcDefWindowProcMultiple Document InterfaceReferenceWM_CHILDACTIVATEWM_GETMINMAXINFOWM_MENUCHARWM_MOVEWM_SETFOCUSWM_SETTEXTWM_SIZEWM_SYSCOMMAND</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DefMDIChildProcW(nint hWnd, uint uMsg, nint wParam, nint lParam);

        /// <summary>
        ///Unlike DefWindowProcA and DefWindowProcW, this function doesn't do any processing.
        /// </summary>
        /// <param name="paRawInput">Type: PRAWINPUT*Ignored.</param>
        /// <param name="nInput">Type: INTIgnored.</param>
        /// <param name="cbSizeHeader">Type: UINTThe size, in bytes, of the RAWINPUTHEADER structure.Type: LRESULTIf successful, the function returns 0. Otherwise it returns -1.ConceptualRAWINPUTRAWINPUTHEADERRaw Input</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DefRawInputProc(POINT paRawInput, int nInput, uint cbSizeHeader);

        /// <summary>
        ///Calls the default window procedure to provide default processing for any window messages that an application does not process. This function ensures that every message is processed. DefWindowProc is called with the same parameters received by the window procedure.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window procedure that received the message.</param>
        /// <param name="Msg">Type: UINTThe message.</param>
        /// <param name="wParam">Type: WPARAMAdditional message information. The content of this parameter depends on the value of the Msg parameter.</param>
        /// <param name="lParam">Type: LPARAMAdditional message information. The content of this parameter depends on the value of the Msg parameter.Type: LRESULTThe return value is the result of the message processing and depends on the message.CallWindowProcConceptualDefDlgProcReferenceWindow ProceduresWindowProc</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DefWindowProcA(nint hWnd, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Calls the default window procedure to provide default processing for any window messages that an application does not process. This function ensures that every message is processed. DefWindowProc is called with the same parameters received by the window procedure.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window procedure that received the message.</param>
        /// <param name="Msg">Type: UINTThe message.</param>
        /// <param name="wParam">Type: WPARAMAdditional message information. The content of this parameter depends on the value of the Msg parameter.</param>
        /// <param name="lParam">Type: LPARAMAdditional message information. The content of this parameter depends on the value of the Msg parameter.Type: LRESULTThe return value is the result of the message processing and depends on the message.CallWindowProcConceptualDefDlgProcReferenceWindow ProceduresWindowProc</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DefWindowProcW(nint hWnd, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Deletes an item from the specified menu. If the menu item opens a menu or submenu, this function destroys the handle to the menu or submenu and frees the memory used by the menu or submenu.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu to be changed.</param>
        /// <param name="uPosition">Type: UINTThe menu item to be deleted, as determined by the uFlags parameter.</param>
        /// <param name="uFlags">Type: UINTIndicates how the uPosition parameter is interpreted. This parameter must be one of the following values.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.For an example, see Example of a Clipboard Viewer.ConceptualDrawMenuBarMenusReferenceRemoveMenu</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DeleteMenu(nint hMenu, uint uPosition, uint uFlags);

        /// <summary>
        ///[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window to be unregistered. The window was registered with a call to the RegisterShellHookWindow function.Type: BOOLTRUE if the function succeeds; FALSE if the function fails.This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server 2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.ConceptualReferenceRegisterShellHookWindowWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DeregisterShellHookWindow(nint hwnd);

        /// <summary>
        ///Destroys an accelerator table.
        /// </summary>
        /// <param name="hAccel">Type: HACCELA handle to the accelerator table to be destroyed. This handle must have been created by a call to the CreateAcceleratorTable or LoadAccelerators function.Type: BOOLIf the function succeeds, the return value is nonzero. However, if the table has been loaded more than one call to LoadAccelerators, the function will return a nonzero value only when DestroyAcceleratorTable has been called an equal number of times.If the function fails, the return value is zero.ConceptualCopyAcceleratorTableCreateAcceleratorTableKeyboard AcceleratorsLoadAcceleratorsReferenceTranslateAccelerator</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DestroyAcceleratorTable(ACCEL hAccel);

        /// <summary>
        ///Destroys the caret's current shape, frees the caret from the window, and removes the caret from the screen.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DestroyCaret();

        /// <summary>
        ///Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.
        /// </summary>
        /// <param name="hCursor">Type: HCURSORA handle to the cursor to be destroyed. The cursor must not be in use.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The DestroyCursor function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared cursor is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared cursor:ConceptualCopyCursorCopyImageCreateCursorCursorsLoadCursorLoadCursorFromFileLoadImageReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DestroyCursor(nint hCursor);

        /// <summary>
        ///Destroys an icon and frees any memory the icon occupied.
        /// </summary>
        /// <param name="hIcon">Type: HICONA handle to the icon to be destroyed. The icon must not be in use.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.It is only necessary to call DestroyIcon for icons and cursors created with the following functions: CreateIconFromResourceEx (if called without the LR_SHARED flag), CreateIconIndirect, and CopyIcon. Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared icon.ConceptualCopyIconCreateIconFromResourceCreateIconFromResourceExCreateIconIndirectIconsReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DestroyIcon(nint hIcon);

        /// <summary>
        ///Destroys the specified menu and frees any memory that the menu occupies.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu to be destroyed.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Before closing, an application must use the DestroyMenu function to destroy a menu not assigned to a window. A menu that is assigned to a window is automatically destroyed when the application closes.DestroyMenu is recursive, that is, it will destroy the menu and all its submenus.For an example, see Displaying a Shortcut Menu.ConceptualCreateMenuDeleteMenuMenusReferenceRemoveMenuSetMenuItemInfo</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DestroyMenu(nint hMenu);

        /// <summary>
        ///Destroys the specified pointer injection device.
        /// </summary>
        /// <param name="device">A handle to the pointer injection device.None</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void DestroySyntheticPointerDevice(EMRSETDIBITSTODEVICE device);

        /// <summary>
        ///Destroys the specified window. The function sends WM_DESTROY and WM_NCDESTROY messages to the window to deactivate it and remove the keyboard focus from it. The function also destroys the window's menu, flushes the thread message queue, destroys timers, removes clipboard ownership, and breaks the clipboard viewer chain (if the window is at the top of the viewer chain).
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to be destroyed.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.A thread cannot use DestroyWindow to destroy a window created by a different thread.If the window being destroyed is a child window that does not have the WS_EX_NOPARENTNOTIFY style, a WM_PARENTNOTIFY message is sent to the parent.For an example, see Destroying a Window.ConceptualCreateDialogCreateWindowCreateWindowExReferenceWM_DESTROYWM_NCDESTROYWM_PARENTNOTIFYWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DestroyWindow(nint hWnd);

        /// <summary>
        ///Creates a modal dialog box from a dialog box template resource. DialogBox does not return control until the specified callback function terminates the modal dialog box by calling the EndDialog function.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void DialogBoxA();

        /// <summary>
        ///Creates a modal dialog box from a dialog box template in memory. DialogBoxIndirect does not return control until the specified callback function terminates the modal dialog box by calling the EndDialog function.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void DialogBoxIndirectA();

        /// <summary>
        ///Creates a modal dialog box from a dialog box template in memory. Before displaying the dialog box, the function passes an application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can use this value to initialize dialog box controls.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="hDialogTemplate">Type: LPCDLGTEMPLATEThe template that DialogBoxIndirectParam uses to create the dialog box. A dialog box template consists of a header that describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box. The template can use either the standard format or the extended format.In a standard template for a dialog box, the header is a DLGTEMPLATE structure followed by additional variable-length arrays. The data for each control consists of a DLGITEMTEMPLATE structure followed by additional variable-length arrays.In an extended template for a dialog box, the header uses the DLGTEMPLATEEX format and the control definitions use the DLGITEMTEMPLATEEX format.</param>
        /// <param name="hWndParent"></param>
        /// <param name="lpDialogFunc"></param>
        /// <param name="dwInitParam">Type: LPARAMThe value to pass to the dialog box in the lParam parameter of the WM_INITDIALOG message.Type: INT_PTRIf the function succeeds, the return value is the nResult parameter specified in the call to the EndDialog function that was used to terminate the dialog box.If the function fails because the hWndParent parameter is invalid, the return value is zero. The function returns zero in this case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is –1. To get extended error information, call GetLastError.The DialogBoxIndirectParam function uses the CreateWindowEx function to create the dialog box. DialogBoxIndirectParam then sends a WM_INITDIALOG message to the dialog box procedure. If the template specifies the DS_SETFONT or DS_SHELLFONT style, the function also sends a WM_SETFONT message to the dialog box procedure. The function displays the dialog box (regardless of whether the template specifies the WS_VISIBLE style), disables the owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box.When the dialog box procedure calls the EndDialog function, DialogBoxIndirectParam destroys the dialog box, ends the message loop, enables the owner window (if previously enabled), and returns the nResult parameter specified by the dialog box procedure when it called EndDialog.In a standard dialog box template, the DLGTEMPLATE structure and each of the DLGITEMTEMPLATE structures must be aligned on DWORD boundaries. The creation data array that follows a DLGITEMTEMPLATE structure must also be aligned on a DWORD boundary. All of the other variable-length arrays in the template must be aligned on WORD boundaries.In an extended dialog box template, the DLGTEMPLATEEX header and each of the DLGITEMTEMPLATEEX control definitions must be aligned on DWORD boundaries. The creation data array, if any, that follows a DLGITEMTEMPLATEEX structure must also be aligned on a DWORD boundary. All of the other variable-length arrays in the template must be aligned on WORD boundaries.All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings.ConceptualCreateWindowExDLGITEMTEMPLATEDLGITEMTEMPLATEEXDLGTEMPLATEDLGTEMPLATEEXDialog BoxesDialogBoxDialogBoxIndirectDialogBoxParamDialogProcEndDialogReferenceWM_INITDIALOGWM_SETFONT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DialogBoxIndirectParamA(nint hInstance, DLGTEMPLATE hDialogTemplate, nint hWndParent, DLGPROC lpDialogFunc, nint dwInitParam);

        /// <summary>
        ///Creates a modal dialog box from a dialog box template in memory. Before displaying the dialog box, the function passes an application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can use this value to initialize dialog box controls.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="hDialogTemplate">Type: LPCDLGTEMPLATEThe template that DialogBoxIndirectParam uses to create the dialog box. A dialog box template consists of a header that describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box. The template can use either the standard format or the extended format.In a standard template for a dialog box, the header is a DLGTEMPLATE structure followed by additional variable-length arrays. The data for each control consists of a DLGITEMTEMPLATE structure followed by additional variable-length arrays.In an extended template for a dialog box, the header uses the DLGTEMPLATEEX format and the control definitions use the DLGITEMTEMPLATEEX format.</param>
        /// <param name="hWndParent"></param>
        /// <param name="lpDialogFunc"></param>
        /// <param name="dwInitParam">Type: LPARAMThe value to pass to the dialog box in the lParam parameter of the WM_INITDIALOG message.Type: INT_PTRIf the function succeeds, the return value is the nResult parameter specified in the call to the EndDialog function that was used to terminate the dialog box.If the function fails because the hWndParent parameter is invalid, the return value is zero. The function returns zero in this case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is –1. To get extended error information, call GetLastError.The DialogBoxIndirectParam function uses the CreateWindowEx function to create the dialog box. DialogBoxIndirectParam then sends a WM_INITDIALOG message to the dialog box procedure. If the template specifies the DS_SETFONT or DS_SHELLFONT style, the function also sends a WM_SETFONT message to the dialog box procedure. The function displays the dialog box (regardless of whether the template specifies the WS_VISIBLE style), disables the owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box.When the dialog box procedure calls the EndDialog function, DialogBoxIndirectParam destroys the dialog box, ends the message loop, enables the owner window (if previously enabled), and returns the nResult parameter specified by the dialog box procedure when it called EndDialog.In a standard dialog box template, the DLGTEMPLATE structure and each of the DLGITEMTEMPLATE structures must be aligned on DWORD boundaries. The creation data array that follows a DLGITEMTEMPLATE structure must also be aligned on a DWORD boundary. All of the other variable-length arrays in the template must be aligned on WORD boundaries.In an extended dialog box template, the DLGTEMPLATEEX header and each of the DLGITEMTEMPLATEEX control definitions must be aligned on DWORD boundaries. The creation data array, if any, that follows a DLGITEMTEMPLATEEX structure must also be aligned on a DWORD boundary. All of the other variable-length arrays in the template must be aligned on WORD boundaries.All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings.ConceptualCreateWindowExDLGITEMTEMPLATEDLGITEMTEMPLATEEXDLGTEMPLATEDLGTEMPLATEEXDialog BoxesDialogBoxDialogBoxIndirectDialogBoxParamDialogProcEndDialogReferenceWM_INITDIALOGWM_SETFONT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DialogBoxIndirectParamW(nint hInstance, DLGTEMPLATE hDialogTemplate, nint hWndParent, DLGPROC lpDialogFunc, nint dwInitParam);

        /// <summary>
        ///Creates a modal dialog box from a dialog box template in memory. DialogBoxIndirect does not return control until the specified callback function terminates the modal dialog box by calling the EndDialog function.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void DialogBoxIndirectW();

        /// <summary>
        ///Creates a modal dialog box from a dialog box template resource. Before displaying the dialog box, the function passes an application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can use this value to initialize dialog box controls.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpTemplateName">Type: LPCTSTRThe dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier, its high-order word must be zero and its low-order word must contain the identifier. You can use the MAKEINTRESOURCE macro to create this value.</param>
        /// <param name="hWndParent"></param>
        /// <param name="lpDialogFunc"></param>
        /// <param name="dwInitParam">Type: LPARAMThe value to pass to the dialog box in the lParam parameter of the WM_INITDIALOG message.Type: INT_PTRIf the function succeeds, the return value is the value of the nResult parameter specified in the call to the EndDialog function used to terminate the dialog box.If the function fails because the hWndParent parameter is invalid, the return value is zero. The function returns zero in this case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is –1. To get extended error information, call GetLastError.The DialogBoxParam function uses the CreateWindowEx function to create the dialog box. DialogBoxParam then sends a WM_INITDIALOG message (and a WM_SETFONT message if the template specifies the DS_SETFONT or DS_SHELLFONT style) to the dialog box procedure. The function displays the dialog box (regardless of whether the template specifies the WS_VISIBLE style), disables the owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box.When the dialog box procedure calls the EndDialog function, DialogBoxParam destroys the dialog box, ends the message loop, enables the owner window (if previously enabled), and returns the nResult parameter specified by the dialog box procedure when it called EndDialog.ConceptualCreateWindowExDialog BoxesDialogBoxDialogBoxIndirectDialogBoxIndirectParamDialogProcEndDialogMAKEINTRESOURCEReferenceWM_INITDIALOGWM_SETFONT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DialogBoxParamA(nint hInstance, string lpTemplateName, nint hWndParent, DLGPROC lpDialogFunc, nint dwInitParam);

        /// <summary>
        ///Creates a modal dialog box from a dialog box template resource. Before displaying the dialog box, the function passes an application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can use this value to initialize dialog box controls.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpTemplateName">Type: LPCTSTRThe dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier, its high-order word must be zero and its low-order word must contain the identifier. You can use the MAKEINTRESOURCE macro to create this value.</param>
        /// <param name="hWndParent"></param>
        /// <param name="lpDialogFunc"></param>
        /// <param name="dwInitParam">Type: LPARAMThe value to pass to the dialog box in the lParam parameter of the WM_INITDIALOG message.Type: INT_PTRIf the function succeeds, the return value is the value of the nResult parameter specified in the call to the EndDialog function used to terminate the dialog box.If the function fails because the hWndParent parameter is invalid, the return value is zero. The function returns zero in this case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is –1. To get extended error information, call GetLastError.The DialogBoxParam function uses the CreateWindowEx function to create the dialog box. DialogBoxParam then sends a WM_INITDIALOG message (and a WM_SETFONT message if the template specifies the DS_SETFONT or DS_SHELLFONT style) to the dialog box procedure. The function displays the dialog box (regardless of whether the template specifies the WS_VISIBLE style), disables the owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box.When the dialog box procedure calls the EndDialog function, DialogBoxParam destroys the dialog box, ends the message loop, enables the owner window (if previously enabled), and returns the nResult parameter specified by the dialog box procedure when it called EndDialog.ConceptualCreateWindowExDialog BoxesDialogBoxDialogBoxIndirectDialogBoxIndirectParamDialogProcEndDialogMAKEINTRESOURCEReferenceWM_INITDIALOGWM_SETFONT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DialogBoxParamW(nint hInstance, string lpTemplateName, nint hWndParent, DLGPROC lpDialogFunc, nint dwInitParam);

        /// <summary>
        ///Creates a modal dialog box from a dialog box template resource. DialogBox does not return control until the specified callback function terminates the modal dialog box by calling the EndDialog function.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void DialogBoxW();

        /// <summary>
        ///Disables the window ghosting feature for the calling GUI process. Window ghosting is a Windows Manager feature that lets the user minimize, move, or close the main window of an application that is not responding.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void DisableProcessWindowsGhosting();

        /// <summary>
        ///Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function.
        /// </summary>
        /// <param name="lpMsg">Type: const MSG*A pointer to a structure that contains the message.Type: LRESULTThe return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored.The MSG structure must contain valid message values. If the lpmsg parameter points to a WM_TIMER message and the lParam parameter of the WM_TIMER message is not NULL, lParam points to a function that is called instead of the window procedure.Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call IsDialogMessage. For more information, see Dialog Box Keyboard Interface.For an example, see Creating a Message Loop.ConceptualGetMessageIsDialogMessageMSGMessages and Message QueuesPeekMessageReferenceTranslateMessageWM_TIMER</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DispatchMessage(MSG lpMsg);

        /// <summary>
        ///Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function.
        /// </summary>
        /// <param name="lpMsg">Type: const MSG*A pointer to a structure that contains the message.Type: LRESULTThe return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored.The MSG structure must contain valid message values. If the lpmsg parameter points to a WM_TIMER message and the lParam parameter of the WM_TIMER message is not NULL, lParam points to a function that is called instead of the window procedure.Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call IsDialogMessage. For more information, see Dialog Box Keyboard Interface.For an example, see Creating a Message Loop.ConceptualGetMessageIsDialogMessageMSGMessages and Message QueuesPeekMessageReferenceTranslateMessageWM_TIMER</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DispatchMessageA(MSG lpMsg);

        /// <summary>
        ///Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function.
        /// </summary>
        /// <param name="lpMsg">Type: const MSG*A pointer to a structure that contains the message.Type: LRESULTThe return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored.The MSG structure must contain valid message values. If the lpmsg parameter points to a WM_TIMER message and the lParam parameter of the WM_TIMER message is not NULL, lParam points to a function that is called instead of the window procedure.Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call IsDialogMessage. For more information, see Dialog Box Keyboard Interface.For an example, see Creating a Message Loop.ConceptualGetMessageIsDialogMessageMSGMessages and Message QueuesPeekMessageReferenceTranslateMessageWM_TIMER</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint DispatchMessageW(MSG lpMsg);

        /// <summary>
        ///The DisplayConfigGetDeviceInfo function retrieves display configuration information about the device.
        /// </summary>
        /// <param name="requestPacket">A pointer to a DISPLAYCONFIG_DEVICE_INFO_HEADER structure. This structure contains information about the request, which includes the packet type in the type member. The type and size of additional data that DisplayConfigGetDeviceInfo returns after the header structure depend on the packet type.The function returns one of the following return codes.Use the DisplayConfigGetDeviceInfo function to obtain additional information about a source or target for an adapter, such as the display name, the preferred display mode, and source device name.The caller can call DisplayConfigGetDeviceInfo to obtain more friendly names to display in the user interface. The caller can obtain names for the adapter, the source, and the target. The caller can also call DisplayConfigGetDeviceInfo to obtain the best resolution of the connected display device.See QueryDisplayConfig for an example of DisplayConfigGetDeviceInfo.DISPLAYCONFIG_DEVICE_INFO_HEADERDISPLAYCONFIG_TARGET_DEVICE_NAMEDISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGSDisplayConfigSetDeviceInfo</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int DisplayConfigGetDeviceInfo(out DISPLAYCONFIG_DEVICE_INFO_HEADER requestPacket);

        /// <summary>
        ///The DisplayConfigSetDeviceInfo function sets the properties of a target.
        /// </summary>
        /// <param name="setPacket">A pointer to a DISPLAYCONFIG_DEVICE_INFO_HEADER structure that contains information to set for the device. The type and size of additional data that DisplayConfigSetDeviceInfo uses for the configuration comes after the header structure. This additional data depends on the packet type, as specified by the type member of DISPLAYCONFIG_DEVICE_INFO_HEADER. For example, if the caller wants to change the boot persistence, that caller allocates and fills a DISPLAYCONFIG_SET_TARGET_PERSISTENCE structure and passes a pointer to this structure in setPacket. Note that the first member of the DISPLAYCONFIG_SET_TARGET_PERSISTENCE structure is the DISPLAYCONFIG_DEVICE_INFO_HEADER.The function returns one of the following return codes.DisplayConfigSetDeviceInfo can currently only be used to start and stop boot persisted force projection on an analog target. For more information about boot persistence, see Forced Versus Connected Targets.DisplayConfigSetDeviceInfo can only be used to set DISPLAYCONFIG_DEVICE_INFO_SET_XXX type of information. DisplayConfigSetDeviceInfo fails if the type member of DISPLAYCONFIG_DEVICE_INFO_HEADER is set to one of the DISPLAYCONFIG_DEVICE_INFO_GET_XXX values.DISPLAYCONFIG_DEVICE_INFO_HEADERDisplayConfigGetDeviceInfo</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int DisplayConfigSetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER setPacket);

        /// <summary>
        ///Replaces the contents of a list box with the names of the subdirectories and files in a specified directory. You can filter the list of names by specifying a set of file attributes. The list can optionally include mapped drives.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the list box.</param>
        /// <param name="lpPathSpec">Type: LPTSTRA pointer to a buffer containing a null-terminated string that specifies an absolute path, relative path, or filename. An absolute path can begin with a drive letter (for example, d:) or a UNC name (for example, \<i>machinename\sharename).The function splits the string into a directory and a filename. The function searches the directory for names that match the filename. If the string does not specify a directory, the function searches the current directory.If the string includes a filename, the filename must contain at least one wildcard character (? or *). If the string does not include a filename, the function behaves as if you had specified the asterisk wildcard character (*) as the filename. All names in the specified directory that match the filename and have the attributes specified by the uFileType parameter are added to the list box.</param>
        /// <param name="nIDListBox">Type: intThe identifier of a list box in the hDlg dialog box. If this parameter is zero, DlgDirList does not try to fill a list box.</param>
        /// <param name="nIDStaticPath">Type: intThe identifier of a static control in the hDlg dialog box. DlgDirList sets the text of this control to display the current drive and directory. This parameter can be zero if you do not want to display the current drive and directory.</param>
        /// <param name="uFileType">Type: UINTSpecifies the attributes of the files or directories to be added to the list box. This parameter can be one or more of the following values.Type: intIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. For example, if the string specified by lpPathSpec is not a valid path, the function fails. To get extended error information, call .If lpPathSpec specifies a directory, DlgDirListComboBox changes the current directory to the specified directory before filling the list box. The text of the static control identified by the nIDStaticPath parameter is set to the name of the new current directory.DlgDirList sends the LB_RESETCONTENT and LB_DIR messages to the list box.If uFileType includes the DDL_DIRECTORY flag and lpPathSpec specifies a first-level directory, such as C:\TEMP, the list box will always include a ".." entry for the root directory. This is true even if the root directory has hidden or system attributes and the DDL_HIDDEN and DDL_SYSTEM flags are not specified. The root directory of an NTFS volume has hidden and system attributes.The directory listing displays long filenames, if any.For examples, see the following topics: Creating a Directory Listing in a Single-selection List Box and Creating a Multiple-selection List Box.DlgDirListComboBoxDlgDirSelectComboBoxExDlgDirSelectExReference</param>
        /// <remarks>
        /// To get extended error information, call .
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int DlgDirListA(nint hDlg, out string lpPathSpec, int nIDListBox, int nIDStaticPath, uint uFileType);

        /// <summary>
        ///Replaces the contents of a combo box with the names of the subdirectories and files in a specified directory. You can filter the list of names by specifying a set of file attributes. The list of names can include mapped drive letters.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the combo box.</param>
        /// <param name="lpPathSpec">Type: LPTSTRA pointer to a buffer containing a null-terminated string that specifies an absolute path, relative path, or file name. An absolute path can begin with a drive letter (for example, d:) or a UNC name (for example, \\machinename\sharename).The function splits the string into a directory and a file name. The function searches the directory for names that match the file name. If the string does not specify a directory, the function searches the current directory.If the string includes a file name, the file name must contain at least one wildcard character (? or ). If the string does not include a file name, the function behaves as if you had specified the asterisk wildcard character () as the file name. All names in the specified directory that match the file name and have the attributes specified by the uFiletype parameter are added to the list displayed in the combo box.</param>
        /// <param name="nIDComboBox">Type: intThe identifier of a combo box in the hDlg dialog box. If this parameter is zero, DlgDirListComboBox does not try to fill a combo box.</param>
        /// <param name="nIDStaticPath">Type: intThe identifier of a static control in the hDlg dialog box. DlgDirListComboBox sets the text of this control to display the current drive and directory. This parameter can be zero if you do not want to display the current drive and directory.</param>
        /// <param name="uFiletype">Type: UINTA set of bit flags that specifies the attributes of the files or directories to be added to the combo box. This parameter can be a combination of the following values.Type: intIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. For example, if the string specified by lpPathSpec is not a valid path, the function fails. To get extended error information, call GetLastError.If lpPathSpec specifies a directory, DlgDirListComboBox changes the current directory to the specified directory before filling the combo box. The text of the static control identified by the nIDStaticPath parameter is set to the name of the new current directory.DlgDirListComboBox sends the CB_RESETCONTENT and CB_DIR messages to the combo box.Microsoft Windows NT 4.0 and later: If uFiletype includes the DDL_DIRECTORY flag and lpPathSpec specifies a first-level directory, such as C:\TEMP, the combo box will always include a ".." entry for the root directory. This is true even if the root directory has hidden or system attributes and the DDL_HIDDEN and DDL_SYSTEM flags are not specified. The root directory of an NTFS volume has hidden and system attributes.Security Warning:  Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes having lpPathSpec indicate a non-writable buffer, or a buffer without a null-termination. You should review the Security Considerations: Microsoft Windows Controls before continuing.Microsoft Windows NT 4.0 and later: The list displays long file names, if any.Windows 95 or later: The list displays short file names (the 8.3 form). You can use the SHGetFileInfo or GetFullPathName functions to get the corresponding long file name.Windows 95 or later: DlgDirListComboBoxW is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in Microsoft Layer for Unicode on Windows Me/98/95 Systems.DlgDirListDlgDirSelectComboBoxExReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int DlgDirListComboBoxA(nint hDlg, out string lpPathSpec, int nIDComboBox, int nIDStaticPath, uint uFiletype);

        /// <summary>
        ///Replaces the contents of a combo box with the names of the subdirectories and files in a specified directory. You can filter the list of names by specifying a set of file attributes. The list of names can include mapped drive letters.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the combo box.</param>
        /// <param name="lpPathSpec">Type: LPTSTRA pointer to a buffer containing a null-terminated string that specifies an absolute path, relative path, or file name. An absolute path can begin with a drive letter (for example, d:) or a UNC name (for example, \\machinename\sharename).The function splits the string into a directory and a file name. The function searches the directory for names that match the file name. If the string does not specify a directory, the function searches the current directory.If the string includes a file name, the file name must contain at least one wildcard character (? or ). If the string does not include a file name, the function behaves as if you had specified the asterisk wildcard character () as the file name. All names in the specified directory that match the file name and have the attributes specified by the uFiletype parameter are added to the list displayed in the combo box.</param>
        /// <param name="nIDComboBox">Type: intThe identifier of a combo box in the hDlg dialog box. If this parameter is zero, DlgDirListComboBox does not try to fill a combo box.</param>
        /// <param name="nIDStaticPath">Type: intThe identifier of a static control in the hDlg dialog box. DlgDirListComboBox sets the text of this control to display the current drive and directory. This parameter can be zero if you do not want to display the current drive and directory.</param>
        /// <param name="uFiletype">Type: UINTA set of bit flags that specifies the attributes of the files or directories to be added to the combo box. This parameter can be a combination of the following values.Type: intIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. For example, if the string specified by lpPathSpec is not a valid path, the function fails. To get extended error information, call GetLastError.If lpPathSpec specifies a directory, DlgDirListComboBox changes the current directory to the specified directory before filling the combo box. The text of the static control identified by the nIDStaticPath parameter is set to the name of the new current directory.DlgDirListComboBox sends the CB_RESETCONTENT and CB_DIR messages to the combo box.Microsoft Windows NT 4.0 and later: If uFiletype includes the DDL_DIRECTORY flag and lpPathSpec specifies a first-level directory, such as C:\TEMP, the combo box will always include a ".." entry for the root directory. This is true even if the root directory has hidden or system attributes and the DDL_HIDDEN and DDL_SYSTEM flags are not specified. The root directory of an NTFS volume has hidden and system attributes.Security Warning:  Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes having lpPathSpec indicate a non-writable buffer, or a buffer without a null-termination. You should review the Security Considerations: Microsoft Windows Controls before continuing.Microsoft Windows NT 4.0 and later: The list displays long file names, if any.Windows 95 or later: The list displays short file names (the 8.3 form). You can use the SHGetFileInfo or GetFullPathName functions to get the corresponding long file name.Windows 95 or later: DlgDirListComboBoxW is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in Microsoft Layer for Unicode on Windows Me/98/95 Systems.DlgDirListDlgDirSelectComboBoxExReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int DlgDirListComboBoxW(nint hDlg, out string lpPathSpec, int nIDComboBox, int nIDStaticPath, uint uFiletype);

        /// <summary>
        ///Replaces the contents of a list box with the names of the subdirectories and files in a specified directory. You can filter the list of names by specifying a set of file attributes. The list can optionally include mapped drives.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the list box.</param>
        /// <param name="lpPathSpec">Type: LPTSTRA pointer to a buffer containing a null-terminated string that specifies an absolute path, relative path, or filename. An absolute path can begin with a drive letter (for example, d:) or a UNC name (for example, \ machinename sharename).The function splits the string into a directory and a filename. The function searches the directory for names that match the filename. If the string does not specify a directory, the function searches the current directory.If the string includes a filename, the filename must contain at least one wildcard character (? or ). If the string does not include a filename, the function behaves as if you had specified the asterisk wildcard character () as the filename. All names in the specified directory that match the filename and have the attributes specified by the uFileType parameter are added to the list box.</param>
        /// <param name="nIDListBox">Type: intThe identifier of a list box in the hDlg dialog box. If this parameter is zero, DlgDirList does not try to fill a list box.</param>
        /// <param name="nIDStaticPath">Type: intThe identifier of a static control in the hDlg dialog box. DlgDirList sets the text of this control to display the current drive and directory. This parameter can be zero if you do not want to display the current drive and directory.</param>
        /// <param name="uFileType">Type: UINTSpecifies the attributes of the files or directories to be added to the list box. This parameter can be one or more of the following values.Type: intIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. For example, if the string specified by lpPathSpec is not a valid path, the function fails. To get extended error information, call .If lpPathSpec specifies a directory, DlgDirListComboBox changes the current directory to the specified directory before filling the list box. The text of the static control identified by the nIDStaticPath parameter is set to the name of the new current directory.DlgDirList sends the LB_RESETCONTENT and LB_DIR messages to the list box.If uFileType includes the DDL_DIRECTORY flag and lpPathSpec specifies a first-level directory, such as C:\TEMP, the list box will always include a ".." entry for the root directory. This is true even if the root directory has hidden or system attributes and the DDL_HIDDEN and DDL_SYSTEM flags are not specified. The root directory of an NTFS volume has hidden and system attributes.The directory listing displays long filenames, if any.For examples, see the following topics: Creating a Directory Listing in a Single-selection List Box and Creating a Multiple-selection List Box.DlgDirListComboBoxDlgDirSelectComboBoxExDlgDirSelectExReference</param>
        /// <remarks>
        /// To get extended error information, call .
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int DlgDirListW(nint hDlg, out string lpPathSpec, int nIDListBox, int nIDStaticPath, uint uFileType);

        /// <summary>
        ///Retrieves the current selection from a combo box filled by using the DlgDirListComboBox function. The selection is interpreted as a drive letter, a file, or a directory name.
        /// </summary>
        /// <param name="hwndDlg">Type: HWNDA handle to the dialog box that contains the combo box.</param>
        /// <param name="lpString"></param>
        /// <param name="cchOut">Type: intThe length, in characters, of the buffer pointed to by the lpString parameter.</param>
        /// <param name="idComboBox">Type: intThe integer identifier of the combo box control in the dialog box.Type: BOOLIf the current selection is a directory name, the return value is nonzero.If the current selection is not a directory name, the return value is zero. To get extended error information, call GetLastError.If the current selection specifies a directory name or drive letter, the DlgDirSelectComboBoxEx function removes the enclosing square brackets (and hyphens for drive letters) so the name or letter is ready to be inserted into a new path or file name. If there is no selection, the contents of the buffer pointed to by lpString do not change.The DlgDirSelectComboBoxEx function does not allow more than one file name to be returned from a combo box.If the string is as long or longer than the buffer, the buffer contains the truncated string with a terminating null character.DlgDirSelectComboBoxEx sends CB_GETCURSEL and CB_GETLBTEXT messages to the combo box.You can use this function with all three types of combo boxes (CBS_SIMPLE, CBS_DROPDOWN, and CBS_DROPDOWNLIST).Security Warning:  Improper use of this function can cause problems for your application. For instance, the nCount parameter should be set properly for both ANSI and Unicode versions. Failure to do so could lead to a buffer overflow. You should review Security Considerations: Microsoft Windows Controls before continuing.Windows 95 or later: DlgDirSelectComboBoxExW is supported by the Microsoft Layer for Unicode (MSLU). To use this, you must add certain files to your application, as outlined in Microsoft Layer for Unicode on Windows Me/98/95 Systems.CB_GETCURSELCB_GETLBTEXTDlgDirListComboBoxReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DlgDirSelectComboBoxExA(nint hwndDlg, out string lpString, int cchOut, int idComboBox);

        /// <summary>
        ///Retrieves the current selection from a combo box filled by using the DlgDirListComboBox function. The selection is interpreted as a drive letter, a file, or a directory name.
        /// </summary>
        /// <param name="hwndDlg">Type: HWNDA handle to the dialog box that contains the combo box.</param>
        /// <param name="lpString"></param>
        /// <param name="cchOut">Type: intThe length, in characters, of the buffer pointed to by the lpString parameter.</param>
        /// <param name="idComboBox">Type: intThe integer identifier of the combo box control in the dialog box.Type: BOOLIf the current selection is a directory name, the return value is nonzero.If the current selection is not a directory name, the return value is zero. To get extended error information, call GetLastError.If the current selection specifies a directory name or drive letter, the DlgDirSelectComboBoxEx function removes the enclosing square brackets (and hyphens for drive letters) so the name or letter is ready to be inserted into a new path or file name. If there is no selection, the contents of the buffer pointed to by lpString do not change.The DlgDirSelectComboBoxEx function does not allow more than one file name to be returned from a combo box.If the string is as long or longer than the buffer, the buffer contains the truncated string with a terminating null character.DlgDirSelectComboBoxEx sends CB_GETCURSEL and CB_GETLBTEXT messages to the combo box.You can use this function with all three types of combo boxes (CBS_SIMPLE, CBS_DROPDOWN, and CBS_DROPDOWNLIST).Security Warning:  Improper use of this function can cause problems for your application. For instance, the nCount parameter should be set properly for both ANSI and Unicode versions. Failure to do so could lead to a buffer overflow. You should review Security Considerations: Microsoft Windows Controls before continuing.Windows 95 or later: DlgDirSelectComboBoxExW is supported by the Microsoft Layer for Unicode (MSLU). To use this, you must add certain files to your application, as outlined in Microsoft Layer for Unicode on Windows Me/98/95 Systems.CB_GETCURSELCB_GETLBTEXTDlgDirListComboBoxReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DlgDirSelectComboBoxExW(nint hwndDlg, out string lpString, int cchOut, int idComboBox);

        /// <summary>
        ///Retrieves the current selection from a single-selection list box. It assumes that the list box has been filled by the DlgDirList function and that the selection is a drive letter, filename, or directory name.
        /// </summary>
        /// <param name="hwndDlg">Type: HWNDA handle to the dialog box that contains the list box.</param>
        /// <param name="lpString"></param>
        /// <param name="chCount">Type: intThe length, in TCHARs, of the buffer pointed to by lpString.</param>
        /// <param name="idListBox">Type: intThe identifier of a list box in the dialog box.Type: BOOLIf the current selection is a directory name, the return value is nonzero.If the current selection is not a directory name, the return value is zero. To get extended error information, call GetLastError.The DlgDirSelectEx function copies the selection to the buffer pointed to by the lpString parameter. If the current selection is a directory name or drive letter, DlgDirSelectEx removes the enclosing square brackets (and hyphens, for drive letters), so that the name or letter is ready to be inserted into a new path. If there is no selection, lpString does not change.If the string is as long or longer than the buffer, the buffer will contain the truncated string with a terminating null character.DlgDirSelectEx sends LB_GETCURSEL and LB_GETTEXT messages to the list box. The function does not allow more than one filename to be returned from a list box. The list box must not be a multiple-selection list box. If it is, this function does not return a zero value and lpString remains unchanged.Windows 95 or later: DlgDirSelectExW is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in Microsoft Layer for Unicode on Windows Me/98/95 Systems.For an example, see Creating a Directory Listing in a Single-selection List Box.DlgDirListDlgDirListComboBoxDlgDirSelectComboBoxExLB_GETCURSELLB_GETTEXTReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DlgDirSelectExA(nint hwndDlg, out string lpString, int chCount, int idListBox);

        /// <summary>
        ///Retrieves the current selection from a single-selection list box. It assumes that the list box has been filled by the DlgDirList function and that the selection is a drive letter, filename, or directory name.
        /// </summary>
        /// <param name="hwndDlg">Type: HWNDA handle to the dialog box that contains the list box.</param>
        /// <param name="lpString"></param>
        /// <param name="chCount">Type: intThe length, in TCHARs, of the buffer pointed to by lpString.</param>
        /// <param name="idListBox">Type: intThe identifier of a list box in the dialog box.Type: BOOLIf the current selection is a directory name, the return value is nonzero.If the current selection is not a directory name, the return value is zero. To get extended error information, call GetLastError.The DlgDirSelectEx function copies the selection to the buffer pointed to by the lpString parameter. If the current selection is a directory name or drive letter, DlgDirSelectEx removes the enclosing square brackets (and hyphens, for drive letters), so that the name or letter is ready to be inserted into a new path. If there is no selection, lpString does not change. If the string is as long or longer than the buffer, the buffer will contain the truncated string with a terminating null character.DlgDirSelectEx sends LB_GETCURSEL and LB_GETTEXT messages to the list box. The function does not allow more than one filename to be returned from a list box. The list box must not be a multiple-selection list box. If it is, this function does not return a zero value and lpString remains unchanged.Windows 95 or later: DlgDirSelectExW is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in Microsoft Layer for Unicode on Windows Me/98/95 Systems.For an example, see Creating a Directory Listing in a Single-selection List Box.DlgDirListDlgDirListComboBoxDlgDirSelectComboBoxExLB_GETCURSELLB_GETTEXTReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DlgDirSelectExW(nint hwndDlg, out string lpString, int chCount, int idListBox);

        /// <summary>
        ///Captures the mouse and tracks its movement until the user releases the left button, presses the ESC key, or moves the mouse outside the drag rectangle around the specified point. The width and height of the drag rectangle are specified by the SM_CXDRAG and SM_CYDRAG values returned by the GetSystemMetrics function.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window receiving mouse input.</param>
        /// <param name="pt">Type: POINTInitial position of the mouse, in screen coordinates. The function determines the coordinates of the drag rectangle by using this point.Type: BOOLIf the user moved the mouse outside of the drag rectangle while holding down the left button, the return value is nonzero.If the user did not move the mouse outside of the drag rectangle while holding down the left button, the return value is zero.The system metrics for the drag rectangle are configurable, allowing for larger or smaller drag rectangles.ConceptualGetSystemMetricsMouse InputPOINTReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DragDetect(nint hwnd, POINT pt);

        /// <summary>
        ///Animates the caption of a window to indicate the opening of an icon or the minimizing or maximizing of a window.
        /// </summary>
        /// <param name="hwnd">A handle to the window whose caption should be animated on the screen. The animation will be clipped to the parent of this window.</param>
        /// <param name="idAni">The type of animation. This must be IDANI_CAPTION. With the IDANI_CAPTION animation type, the window caption will animate from the position specified by lprcFrom to the position specified by lprcTo. The effect is similar to minimizing or maximizing a window.lprcFromA pointer to a RECT structure specifying the location and size of the icon or minimized window. Coordinates are relative to the clipping window hwnd.lprcToA pointer to a RECT structure specifying the location and size of the restored window. Coordinates are relative to the clipping window hwnd.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.Painting and Drawing FunctionsPainting and Drawing OverviewRECT</param>
        /// <param name="lprcFrom"></param>
        /// <param name="lprcTo"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DrawAnimatedRects(nint hwnd, int idAni, RECT lprcFrom, RECT lprcTo);

        /// <summary>
        ///The DrawCaption function draws a window caption.
        /// </summary>
        /// <param name="hwnd">A handle to a window that supplies text and an icon for the window caption.</param>
        /// <param name="hdc">A handle to a device context. The function draws the window caption into this device context.</param>
        /// <param name="lprect">A pointer to a RECT structure that specifies the bounding rectangle for the window caption in logical coordinates.</param>
        /// <param name="flags">The drawing options. This parameter can be zero or more of the following values.If DC_SMALLCAP is specified, the function draws a normal window caption.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.Painting and Drawing FunctionsPainting and Drawing OverviewRECT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DrawCaption(nint hwnd, nint hdc, RECT lprect, uint flags);

        /// <summary>
        ///The DrawEdge function draws one or more edges of rectangle.
        /// </summary>
        /// <param name="hdc">A handle to the device context.</param>
        /// <param name="qrc">A pointer to a RECT structure that contains the logical coordinates of the rectangle.</param>
        /// <param name="edge">The type of inner and outer edges to draw. This parameter must be a combination of one inner-border flag and one outer-border flag. The inner-border flags are as follows.The outer-border flags are as follows.Alternatively, the edge parameter can specify one of the following flags.</param>
        /// <param name="grfFlags">The type of border. This parameter can be a combination of the following values.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.Painting and Drawing FunctionsPainting and Drawing OverviewRECT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DrawEdge(nint hdc, out RECT qrc, uint edge, uint grfFlags);

        /// <summary>
        ///The DrawFocusRect function draws a rectangle in the style used to indicate that the rectangle has the focus.
        /// </summary>
        /// <param name="hDC">A handle to the device context.</param>
        /// <param name="lprc">A pointer to a RECT structure that specifies the logical coordinates of the rectangle.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.DrawFocusRect works only in MM_TEXT mode.Because DrawFocusRect is an XOR function, calling it a second time with the same rectangle removes the rectangle from the screen.This function draws a rectangle that cannot be scrolled. To scroll an area containing a rectangle drawn by this function, call DrawFocusRect to remove the rectangle from the screen, scroll the area, and then call DrawFocusRect again to draw the rectangle in the new position.Windows XP: The focus rectangle can now be thicker than 1 pixel, so it is more visible for high-resolution, high-density displays and accessibility needs. This is handled by the SPI_SETFOCUSBORDERWIDTH and SPI_SETFOCUSBORDERHEIGHT in SystemParametersInfo.For an example, see "Creating an Owner-Drawn List Box" in Using List Boxes.FrameRectPainting and Drawing FunctionsPainting and Drawing OverviewRECT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DrawFocusRect(nint hDC, RECT lprc);

        /// <summary>
        ///The DrawFrameControl function draws a frame control of the specified type and style.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DrawFrameControl(nint hdc, RECT lprc, uint uType, uint uState);

        /// <summary>
        ///Draws an icon or cursor into the specified device context.
        /// </summary>
        /// <param name="hDC">Type: HDCA handle to the device context into which the icon or cursor will be drawn.</param>
        /// <param name="X">Type: intThe logical x-coordinate of the upper-left corner of the icon.</param>
        /// <param name="Y">Type: intThe logical y-coordinate of the upper-left corner of the icon.</param>
        /// <param name="hIcon">Type: HICONA handle to the icon to be drawn.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.DrawIcon places the icon's upper-left corner at the location specified by the X and Y parameters. The location is subject to the current mapping mode of the device context.DrawIcon draws the icon or cursor using the width and height specified by the system metric values for icons; for more information, see GetSystemMetrics.The DrawIcon function calls DrawIconEx passing DI_NORMAL|DI_DEFAULTSIZE as flags.For an example, see Displaying an Icon.ConceptualCreateIconDrawIconExIconsLoadIconReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DrawIcon(nint hDC, int X, int Y, nint hIcon);

        /// <summary>
        ///Draws an icon or cursor into the specified device context, performing the specified raster operations, and stretching or compressing the icon or cursor as specified.
        /// </summary>
        /// <param name="hdc">Type: HDCA handle to the device context into which the icon or cursor will be drawn.</param>
        /// <param name="xLeft">Type: intThe logical x-coordinate of the upper-left corner of the icon or cursor.</param>
        /// <param name="yTop">Type: intThe logical y-coordinate of the upper-left corner of the icon or cursor.</param>
        /// <param name="hIcon">Type: HICONA handle to the icon or cursor to be drawn. This parameter can identify an animated cursor.</param>
        /// <param name="cxWidth">Type: intThe logical width of the icon or cursor. If this parameter is zero and the diFlags parameter is DI_DEFAULTSIZE, the function uses the SM_CXICON system metric value to set the width. If this parameter is zero and DI_DEFAULTSIZE is not used, the function uses the actual resource width.</param>
        /// <param name="cyWidth">Type: intThe logical height of the icon or cursor. If this parameter is zero and the diFlags parameter is DI_DEFAULTSIZE, the function uses the SM_CYICON system metric value to set the width. If this parameter is zero and DI_DEFAULTSIZE is not used, the function uses the actual resource height.</param>
        /// <param name="istepIfAniCur">Type: UINTThe index of the frame to draw, if hIcon identifies an animated cursor. This parameter is ignored if hIcon does not identify an animated cursor.</param>
        /// <param name="hbrFlickerFreeDraw"></param>
        /// <param name="diFlags">Type: UINTThe drawing flags. This parameter can be one of the following values.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The DrawIconEx function places the icon's upper-left corner at the location specified by the xLeft and yTop parameters. The location is subject to the current mapping mode of the device context.If only one of the DI_IMAGE and DI_MASK flags is set, then the corresponding bitmap is drawn with the SRCCOPY raster operation code.If both the DI_IMAGE and DI_MASK flags are set:To duplicate DrawIcon (hDC, X, Y, hIcon), call DrawIconEx as follows:ConceptualCopyImageDrawIconIconsLoadImageReferenceBitBltAlphaBlendBLENDFUNCTION</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DrawIconEx(nint hdc, int xLeft, int yTop, nint hIcon, int cxWidth, int cyWidth, uint istepIfAniCur, nint hbrFlickerFreeDraw, uint diFlags);

        /// <summary>
        ///Redraws the menu bar of the specified window. If the menu bar changes after the system has created the window, this function must be called to draw the changed menu bar.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose menu bar is to be redrawn.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.ConceptualDeleteMenuInsertMenuItemMenusReferenceRemoveMenuSetMenuItemInfo</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DrawMenuBar(nint hWnd);

        /// <summary>
        ///The DrawState function displays an image and applies a visual effect to indicate a state, such as a disabled or default state.
        /// </summary>
        /// <param name="hdc">A handle to the device context to draw in.</param>
        /// <param name="hbrFore">A handle to the brush used to draw the image, if the state specified by the fuFlags parameter is DSS_MONO. This parameter is ignored for other states.</param>
        /// <param name="qfnCallBack">A pointer to an application-defined callback function used to render the image. This parameter is required if the image type in fuFlags is DST_COMPLEX. It is optional and can be NULL if the image type is DST_TEXT. For all other image types, this parameter is ignored. For more information about the callback function, see the DrawStateProc function.</param>
        /// <param name="lData">Information about the image. The meaning of this parameter depends on the image type.</param>
        /// <param name="wData">Information about the image. The meaning of this parameter depends on the image type. It is, however, zero extended for use with the DrawStateProc function.</param>
        /// <param name="x">The horizontal location, in device units, at which to draw the image.</param>
        /// <param name="y">The vertical location, in device units, at which to draw the image.</param>
        /// <param name="cx">The width of the image, in device units. This parameter is required if the image type is DST_COMPLEX. Otherwise, it can be zero to calculate the width of the image.</param>
        /// <param name="cy">The height of the image, in device units. This parameter is required if the image type is DST_COMPLEX. Otherwise, it can be zero to calculate the height of the image.</param>
        /// <param name="uFlags">The image type and state. This parameter can be one of the following type values.This parameter can also be one of the following state values.For all states except DSS_NORMAL, the image is converted to monochrome before the visual effect is applied.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.DrawStateProcPainting and Drawing FunctionsPainting and Drawing Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DrawStateA(nint hdc, nint hbrFore, DRAWSTATEPROC qfnCallBack, nint lData, nint wData, int x, int y, int cx, int cy, uint uFlags);

        /// <summary>
        ///The DrawState function displays an image and applies a visual effect to indicate a state, such as a disabled or default state.
        /// </summary>
        /// <param name="hdc">A handle to the device context to draw in.</param>
        /// <param name="hbrFore">A handle to the brush used to draw the image, if the state specified by the fuFlags parameter is DSS_MONO. This parameter is ignored for other states.</param>
        /// <param name="qfnCallBack">A pointer to an application-defined callback function used to render the image. This parameter is required if the image type in fuFlags is DST_COMPLEX. It is optional and can be NULL if the image type is DST_TEXT. For all other image types, this parameter is ignored. For more information about the callback function, see the DrawStateProc function.</param>
        /// <param name="lData">Information about the image. The meaning of this parameter depends on the image type.</param>
        /// <param name="wData">Information about the image. The meaning of this parameter depends on the image type. It is, however, zero extended for use with the DrawStateProc function.</param>
        /// <param name="x">The horizontal location, in device units, at which to draw the image.</param>
        /// <param name="y">The vertical location, in device units, at which to draw the image.</param>
        /// <param name="cx">The width of the image, in device units. This parameter is required if the image type is DST_COMPLEX. Otherwise, it can be zero to calculate the width of the image.</param>
        /// <param name="cy">The height of the image, in device units. This parameter is required if the image type is DST_COMPLEX. Otherwise, it can be zero to calculate the height of the image.</param>
        /// <param name="uFlags">The image type and state. This parameter can be one of the following type values.This parameter can also be one of the following state values.For all states except DSS_NORMAL, the image is converted to monochrome before the visual effect is applied.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.DrawStateProcPainting and Drawing FunctionsPainting and Drawing Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DrawStateW(nint hdc, nint hbrFore, DRAWSTATEPROC qfnCallBack, nint lData, nint wData, int x, int y, int cx, int cy, uint uFlags);

        /// <summary>
        ///The DrawText function draws formatted text in the specified rectangle. It formats the text according to the specified method (expanding tabs, justifying characters, breaking lines, and so forth).
        /// </summary>
        /// <param name="hdc">A handle to the device context.</param>
        /// <param name="lpchText">A pointer to the string that specifies the text to be drawn. If the nCount parameter is -1, the string must be null-terminated.If uFormat includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer containing the string should be large enough to accommodate these extra characters.</param>
        /// <param name="cchText">The length, in characters, of the string. If nCount is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawText computes the character count automatically.</param>
        /// <param name="lprc">A pointer to a RECT structure that contains the rectangle (in logical coordinates) in which the text is to be formatted.</param>
        /// <param name="format">The method of formatting the text. This parameter can be one or more of the following values.If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from lpRect->top to the bottom of the drawn text.If the function fails, the return value is zero.The DrawText function uses the device context's selected font, text color, and background color to draw the text. Unless the DT_NOCLIP format is used, DrawText clips the text so that it does not appear outside the specified rectangle. Note that text with significant overhang may be clipped, for example, an initial "W" in the text string or text that is in italics. All formatting is assumed to have multiple lines unless the DT_SINGLELINE format is specified.If the selected font is too large for the specified rectangle, the DrawText function does not attempt to substitute a smaller font.The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags.DrawTextExFont and Text FunctionsFonts and Text OverviewGrayStringRECTTabbedTextOutTextOut</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int DrawText(nint hdc, out string lpchText, int cchText, out RECT lprc, uint format);

        /// <summary>
        ///The DrawText function draws formatted text in the specified rectangle. It formats the text according to the specified method (expanding tabs, justifying characters, breaking lines, and so forth).
        /// </summary>
        /// <param name="hdc">A handle to the device context.</param>
        /// <param name="lpchText">A pointer to the string that specifies the text to be drawn. If the cchText parameter is -1, the string must be null-terminated.If uFormat includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer containing the string should be large enough to accommodate these extra characters.</param>
        /// <param name="cchText">The length, in characters, of the string. If cchText is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawText computes the character count automatically.</param>
        /// <param name="lprc">A pointer to a RECT structure that contains the rectangle (in logical coordinates) in which the text is to be formatted.</param>
        /// <param name="format">The method of formatting the text. This parameter can be one or more of the following values.If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from lpRect->top to the bottom of the drawn textIf the function fails, the return value is zero.The DrawText function uses the device context's selected font, text color, and background color to draw the text. Unless the DT_NOCLIP format is used, DrawText clips the text so that it does not appear outside the specified rectangle. Note that text with significant overhang may be clipped, for example, an initial "W" in the text string or text that is in italics. All formatting is assumed to have multiple lines unless the DT_SINGLELINE format is specified.If the selected font is too large for the specified rectangle, the DrawText function does not attempt to substitute a smaller font.The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags.DrawTextExFont and Text FunctionsFonts and Text OverviewGrayStringRECTTabbedTextOutTextOut</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int DrawTextA(nint hdc, out string lpchText, int cchText, out RECT lprc, uint format);

        /// <summary>
        ///The DrawTextEx function draws formatted text in the specified rectangle.
        /// </summary>
        /// <param name="hdc">A handle to the device context in which to draw.</param>
        /// <param name="lpchText">A pointer to the string that contains the text to draw. If the cchText parameter is -1, the string must be null-terminated.If dwDTFormat includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer containing the string should be large enough to accommodate these extra characters.</param>
        /// <param name="cchText">The length of the string pointed to by lpchText. If cchText is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawTextEx computes the character count automatically.</param>
        /// <param name="lprc">A pointer to a RECT structure that contains the rectangle, in logical coordinates, in which the text is to be formatted.</param>
        /// <param name="format">The formatting options. This parameter can be one or more of the following values.</param>
        /// <param name="lpdtp">A pointer to a DRAWTEXTPARAMS structure that specifies additional formatting options. This parameter can be NULL.If the function succeeds, the return value is the text height in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from lprc->top to the bottom of the drawn textIf the function fails, the return value is zero.The DrawTextEx function supports only fonts whose escapement and orientation are both zero.The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags.DRAWTEXTPARAMSDrawTextFont and Text FunctionsFonts and Text Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int DrawTextExA(nint hdc, out string lpchText, int cchText, out RECT lprc, uint format, DRAWTEXTPARAMS lpdtp);

        /// <summary>
        ///The DrawTextEx function draws formatted text in the specified rectangle.
        /// </summary>
        /// <param name="hdc">A handle to the device context in which to draw.</param>
        /// <param name="lpchText">A pointer to the string that contains the text to draw. If the cchText parameter is -1, the string must be null-terminated.If dwDTFormat includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer containing the string should be large enough to accommodate these extra characters.</param>
        /// <param name="cchText">The length of the string pointed to by lpchText. If cchText is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawTextEx computes the character count automatically.</param>
        /// <param name="lprc">A pointer to a RECT structure that contains the rectangle, in logical coordinates, in which the text is to be formatted.</param>
        /// <param name="format">The formatting options. This parameter can be one or more of the following values.</param>
        /// <param name="lpdtp">A pointer to a DRAWTEXTPARAMS structure that specifies additional formatting options. This parameter can be NULL.If the function succeeds, the return value is the text height in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from lprc->top to the bottom of the drawn text.If the function fails, the return value is zero.The DrawTextEx function supports only fonts whose escapement and orientation are both zero.The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags.DRAWTEXTPARAMSDrawTextFont and Text FunctionsFonts and Text Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int DrawTextExW(nint hdc, out string lpchText, int cchText, out RECT lprc, uint format, DRAWTEXTPARAMS lpdtp);

        /// <summary>
        ///The DrawText function draws formatted text in the specified rectangle. It formats the text according to the specified method (expanding tabs, justifying characters, breaking lines, and so forth).
        /// </summary>
        /// <param name="hdc">A handle to the device context.</param>
        /// <param name="lpchText">A pointer to the string that specifies the text to be drawn. If the nCount parameter is -1, the string must be null-terminated.If uFormat includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer containing the string should be large enough to accommodate these extra characters.</param>
        /// <param name="cchText">The length, in characters, of the string. If nCount is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawText computes the character count automatically.</param>
        /// <param name="lprc">A pointer to a RECT structure that contains the rectangle (in logical coordinates) in which the text is to be formatted.</param>
        /// <param name="format">The method of formatting the text. This parameter can be one or more of the following values.If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from lpRect->top to the bottom of the drawn textIf the function fails, the return value is zero.The DrawText function uses the device context's selected font, text color, and background color to draw the text. Unless the DT_NOCLIP format is used, DrawText clips the text so that it does not appear outside the specified rectangle. Note that text with significant overhang may be clipped, for example, an initial "W" in the text string or text that is in italics. All formatting is assumed to have multiple lines unless the DT_SINGLELINE format is specified.If the selected font is too large for the specified rectangle, the DrawText function does not attempt to substitute a smaller font.The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags.DrawTextExFont and Text FunctionsFonts and Text OverviewGrayStringRECTTabbedTextOutTextOut</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int DrawTextW(nint hdc, out string lpchText, int cchText, out RECT lprc, uint format);

        /// <summary>
        ///Empties the clipboard and frees handles to data in the clipboard. The function then assigns ownership of the clipboard to the window that currently has the clipboard open.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EmptyClipboard();

        /// <summary>
        ///Enables, disables, or grays the specified menu item.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu.</param>
        /// <param name="uIDEnableItem">Type: UINTThe menu item to be enabled, disabled, or grayed, as determined by the uEnable parameter. This parameter specifies an item in a menu bar, menu, or submenu.</param>
        /// <param name="uEnable">Type: UINTControls the interpretation of the uIDEnableItem parameter and indicate whether the menu item is enabled, disabled, or grayed. This parameter must be a combination of the following values.Type: BOOLThe return value specifies the previous state of the menu item (it is either MF_DISABLED, MF_ENABLED, or MF_GRAYED). If the menu item does not exist, the return value is -1.An application must use the MF_BYPOSITION flag to specify the correct menu handle. If the menu handle to the menu bar is specified, the top-level menu item (an item in the menu bar) is affected. To set the state of an item in a drop-down menu or submenu by position, an application must specify a handle to the drop-down menu or submenu.When an application specifies the MF_BYCOMMAND flag, the system checks all items that open submenus in the menu identified by the specified menu handle. Therefore, unless duplicate menu items are present, specifying the menu handle to the menu bar is sufficient.The InsertMenu, InsertMenuItem, LoadMenuIndirect, ModifyMenu, and SetMenuItemInfo functions can also set the state (enabled, disabled, or grayed) of a menu item.When you change a window menu, the menu bar is not immediately updated. To force the update, call DrawMenuBar.ConceptualDrawMenuBarGetMenuItemIDInsertMenuInsertMenuItemLoadMenuIndirectMenusModifyMenuReferenceSetMenuItemInfoWM_SYSCOMMAND</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnableMenuItem(nint hMenu, uint uIDEnableItem, uint uEnable);

        /// <summary>
        ///Enables the mouse to act as a pointer input device and send WM_POINTER messages.
        /// </summary>
        /// <param name="fEnable">TRUE to turn on mouse input support in WM_POINTER.If the function succeeds, the return value is non-zero.If the function fails, the return value is zero. To get extended error information, call GetLastError.This function can be called only once in the context of a process lifetime. Prior to the first call, Windows Store apps run with mouse-in-pointer enabled, as do any desktop applications that consume mshtml.dll. All other desktop applications run with mouse-in-pointer disabled.On the first call in the process lifetime, the state is changed as specified and the call succeeds.On subsequent calls, the state will not change. If the current state is not equal to the specified state, the call fails.Call IsMouseInPointerEnabled to verify the mouse-in-pointer state.FunctionsIsMouseInPointerEnabledWM_POINTER</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnableMouseInPointer(bool fEnable);

        /// <summary>
        ///In high-DPI displays, enables automatic display scaling of the non-client area portions of the specified top-level window. Must be called during the initialization of that window.
        /// </summary>
        /// <param name="hwnd">The window that should have automatic scaling enabled.If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.Calling this function will enable non-client scaling for an individual top-level window with DPI_AWARENESS_CONTEXT of DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE. If instead you are not using per-window awareness, and your entire process is running in DPI_AWARENESS_PER_MONITOR_AWARE mode, calling this function will enable non-client scaling in top-level windows in your process.If neither of those are true, or if you call this method from any other window, then it will fail and return a value of zero.Non-client scaling for top-level windows is not enabled by default. You must call this API to enable it for each individual top-level window for which you wish to have the non-client area scale automatically. Once you do, there is no way to disable it. Enabling non-client scaling means that all the areas drawn by the system for the window will automatically scale in response to DPI changes on the window. That includes areas like the caption bar, the scrollbars, and the menu bar. You want to call EnableNonClientDpiScaling when you want the operating system to be responsible for rendering these areas automatically at the correct size based on the DPI of the monitor.Calling this function enables non-client scaling for top-level windows only. Child windows are unaffected.This function must be called from WM_NCCREATE during the initialization of a new window. An example call might look like this:</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnableNonClientDpiScaling(nint hwnd);

        /// <summary>
        ///The EnableScrollBar function enables or disables one or both scroll bar arrows.
        /// </summary>
        /// <param name="hWnd">Type: HWNDHandle to a window or a scroll bar control, depending on the value of the wSBflags parameter.</param>
        /// <param name="wSBflags">Type: UINTSpecifies the scroll bar type. This parameter can be one of the following values.</param>
        /// <param name="wArrows">Type: UINTSpecifies whether the scroll bar arrows are enabled or disabled and indicates which arrows are enabled or disabled. This parameter can be one of the following values.Type: BOOLIf the arrows are enabled or disabled as specified, the return value is nonzero.If the arrows are already in the requested state or an error occurs, the return value is zero. To get extended error information, call GetLastError.</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnableScrollBar(nint hWnd, uint wSBflags, uint wArrows);

        /// <summary>
        ///Enables or disables mouse and keyboard input to the specified window or control. When input is disabled, the window does not receive input such as mouse clicks and key presses. When input is enabled, the window receives all input.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to be enabled or disabled.</param>
        /// <param name="bEnable">Type: BOOLIndicates whether to enable or disable the window. If this parameter is TRUE, the window is enabled. If the parameter is FALSE, the window is disabled.Type: BOOLIf the window was previously disabled, the return value is nonzero.If the window was not previously disabled, the return value is zero.If the window is being disabled, the system sends a WM_CANCELMODE message. If the enabled state of a window is changing, the system sends a WM_ENABLE message after the WM_CANCELMODE message. (These messages are sent before EnableWindow returns.) If a window is already disabled, its child windows are implicitly disabled, although they are not sent a WM_ENABLE message.A window must be enabled before it can be activated. For example, if an application is displaying a modeless dialog box and has disabled its main window, the application must enable the main window before destroying the dialog box. Otherwise, another window will receive the keyboard focus and be activated. If a child window is disabled, it is ignored when the system tries to determine which window should receive mouse messages.By default, a window is enabled when it is created. To create a window that is initially disabled, an application can specify the WS_DISABLED style in the CreateWindow or CreateWindowEx function. After a window has been created, an application can use EnableWindow to enable or disable the window.An application can use this function to enable or disable a control in a dialog box. A disabled control cannot receive the keyboard focus, nor can a user gain access to it.ConceptualCreateWindowCreateWindowExIsWindowEnabledKeyboard InputReferenceWM_ENABLE</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnableWindow(nint hWnd, bool bEnable);

        /// <summary>
        ///Simultaneously updates the position and size of one or more windows in a single screen-refreshing cycle.
        /// </summary>
        /// <param name="hWinPosInfo">Type: HDWPA handle to a multiple-window – position structure that contains size and position information for one or more windows. This internal structure is returned by the BeginDeferWindowPos function or by the most recent call to the DeferWindowPos function.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The EndDeferWindowPos function sends the WM_WINDOWPOSCHANGING and WM_WINDOWPOSCHANGED messages to each window identified in the internal structure.BeginDeferWindowPosConceptualDeferWindowPosReferenceWM_WINDOWPOSCHANGEDWM_WINDOWPOSCHANGINGWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EndDeferWindowPos(nint hWinPosInfo);

        /// <summary>
        ///Destroys a modal dialog box, causing the system to end any processing for the dialog box.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box to be destroyed.</param>
        /// <param name="nResult">Type: INT_PTRThe value to be returned to the application from the function that created the dialog box.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Dialog boxes created by the DialogBox, DialogBoxParam, DialogBoxIndirect, and DialogBoxIndirectParam functions must be destroyed using the EndDialog function. An application calls EndDialog from within the dialog box procedure; the function must not be used for any other purpose.A dialog box procedure can call EndDialog at any time, even during the processing of the WM_INITDIALOG message. If your application calls the function while WM_INITDIALOG is being processed, the dialog box is destroyed before it is shown and before the input focus is set.EndDialog does not destroy the dialog box immediately. Instead, it sets a flag and allows the dialog box procedure to return control to the system. The system checks the flag before attempting to retrieve the next message from the application queue. If the flag is set, the system ends the message loop, destroys the dialog box, and uses the value in nResult as the return value from the function that created the dialog box.ConceptualDialog BoxesDialogBoxDialogBoxIndirectDialogBoxIndirectParamDialogBoxParamReferenceWM_INITDIALOG</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EndDialog(nint hDlg, nint nResult);

        /// <summary>
        ///Ends the calling thread's active menu.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EndMenu();

        /// <summary>
        ///The EndPaint function marks the end of painting in the specified window. This function is required for each call to the BeginPaint function, but only after painting is complete.
        /// </summary>
        /// <param name="hWnd">Handle to the window that has been repainted.</param>
        /// <param name="lpPaint">Pointer to a PAINTSTRUCT structure that contains the painting information retrieved by BeginPaint.The return value is always nonzero.If the caret was hidden by BeginPaint, EndPaint restores the caret to the screen.EndPaint releases the display device context that BeginPaint retrieved.For an example, see Drawing in the Client Area.BeginPaintPAINTSTRUCTPainting and Drawing FunctionsPainting and Drawing Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EndPaint(nint hWnd, PAINTSTRUCT lpPaint);

        /// <summary>
        ///[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to be closed.</param>
        /// <param name="fShutDown">Type: BOOLIgnored. Must be FALSE.</param>
        /// <param name="fForce">Type: BOOLA TRUE for this parameter will force the destruction of the window if an initial attempt fails to gently close the window using WM_CLOSE. With a FALSE for this parameter, only the close with WM_CLOSE is attempted.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is FALSE. To get extended error information, call GetLastError.This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server 2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.CloseWindowConceptualDestroyWindowReferenceWM_CLOSEWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EndTask(nint hWnd, bool fShutDown, bool fForce);

        /// <summary>
        ///Enumerates the child windows that belong to the specified parent window by passing the handle to each child window, in turn, to an application-defined callback function. EnumChildWindows continues until the last child window is enumerated or the callback function returns FALSE.
        /// </summary>
        /// <param name="hWndParent"></param>
        /// <param name="lpEnumFunc">Type: WNDENUMPROCA pointer to an application-defined callback function. For more information, see EnumChildProc.</param>
        /// <param name="lParam">Type: LPARAMAn application-defined value to be passed to the callback function.Type: BOOLThe return value is not used.If a child window has created child windows of its own, EnumChildWindows enumerates those windows as well.A child window that is moved or repositioned in the Z order during the enumeration process will be properly enumerated. The function does not enumerate a child window that is destroyed before being enumerated or that is created during the enumeration process.ConceptualEnumChildProcEnumThreadWindowsEnumWindowsGetWindowReferenceWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumChildWindows(nint hWndParent, MFENUMPROC lpEnumFunc, nint lParam);

        /// <summary>
        ///Enumerates the data formats currently available on the clipboard.
        /// </summary>
        /// <param name="format">Type: UINTA clipboard format that is known to be available.To start an enumeration of clipboard formats, set format to zero. When format is zero, the function retrieves the first available clipboard format. For subsequent calls during an enumeration, set format to the result of the previous EnumClipboardFormats call.Type: UINTIf the function succeeds, the return value is the clipboard format that follows the specified format, namely the next available clipboard format.If the function fails, the return value is zero. To get extended error information, call GetLastError. If the clipboard is not open, the function fails.If there are no more clipboard formats to enumerate, the return value is zero. In this case, the GetLastError function returns the value ERROR_SUCCESS. This lets you distinguish between function failure and the end of enumeration.You must open the clipboard before enumerating its formats. Use the OpenClipboard function to open the clipboard. The EnumClipboardFormats function fails if the clipboard is not open.The EnumClipboardFormats function enumerates formats in the order that they were placed on the clipboard. If you are copying information to the clipboard, add clipboard objects in order from the most descriptive clipboard format to the least descriptive clipboard format. If you are pasting information from the clipboard, retrieve the first clipboard format that you can handle. That will be the most descriptive clipboard format that you can handle.The system provides automatic type conversions for certain clipboard formats. In the case of such a format, this function enumerates the specified format, then enumerates the formats to which it can be converted. For more information, see Standard Clipboard Formats and Synthesized Clipboard Formats.For an example, see Example of a Clipboard Viewer.ClipboardConceptualCountClipboardFormatsOpenClipboardReferenceRegisterClipboardFormat</param>
        /// <remarks>
        /// To get extended error information, call GetLastError. If the clipboard is not open, the function fails.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint EnumClipboardFormats(uint format);

        /// <summary>
        ///Enumerates all desktops associated with the specified window station of the calling process. The function passes the name of each desktop, in turn, to an application-defined callback function.
        /// </summary>
        /// <param name="hwinsta"></param>
        /// <param name="lpEnumFunc">A pointer to an application-defined EnumDesktopProc callback function.</param>
        /// <param name="lParam">An application-defined value to be passed to the callback function.If the function succeeds, it returns the nonzero value returned by the callback function that was pointed to by lpEnumFunc.If the function is unable to perform the enumeration, the return value is zero. Call GetLastError to get extended error information.If the callback function fails, the return value is zero. The callback function can call SetLastError to set an error code for the caller to retrieve by calling GetLastError.The EnumDesktops function enumerates only those desktops for which the calling process has the DESKTOP_ENUMERATE access right. For more information, see Desktop Security and Access Rights.The EnumDesktops function repeatedly invokes the lpEnumFunc callback function until the last desktop is enumerated or the callback function returns FALSE.CreateWindowStationDesktopsEnumDesktopProcGetProcessWindowStationOpenWindowStationWindow Station and Desktop Functions</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumDesktopsA(int hwinsta, PROPENUMPROCA lpEnumFunc, nint lParam);

        /// <summary>
        ///Enumerates all desktops associated with the specified window station of the calling process. The function passes the name of each desktop, in turn, to an application-defined callback function.
        /// </summary>
        /// <param name="hwinsta"></param>
        /// <param name="lpEnumFunc">A pointer to an application-defined EnumDesktopProc callback function.</param>
        /// <param name="lParam">An application-defined value to be passed to the callback function.If the function succeeds, it returns the nonzero value returned by the callback function that was pointed to by lpEnumFunc.If the function is unable to perform the enumeration, the return value is zero. Call GetLastError to get extended error information.If the callback function fails, the return value is zero. The callback function can call SetLastError to set an error code for the caller to retrieve by calling GetLastError.The EnumDesktops function enumerates only those desktops for which the calling process has the DESKTOP_ENUMERATE access right. For more information, see Desktop Security and Access Rights.The EnumDesktops function repeatedly invokes the lpEnumFunc callback function until the last desktop is enumerated or the callback function returns FALSE.CreateWindowStationDesktopsEnumDesktopProcGetProcessWindowStationOpenWindowStationWindow Station and Desktop Functions</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumDesktopsW(int hwinsta, PROPENUMPROCW lpEnumFunc, nint lParam);

        /// <summary>
        ///Enumerates all top-level windows associated with the specified desktop. It passes the handle to each window, in turn, to an application-defined callback function.
        /// </summary>
        /// <param name="hDesktop"></param>
        /// <param name="lpfn">A pointer to an application-defined EnumWindowsProc callback function.</param>
        /// <param name="lParam">An application-defined value to be passed to the callback function.If the function fails or is unable to perform the enumeration, the return value is zero.To get extended error information, call GetLastError.You must ensure that the callback function sets SetLastError if it fails.Windows Server 2003 and Windows XP/2000:  If there are no windows on the desktop, GetLastError returns ERROR_INVALID_HANDLE.The EnumDesktopWindows function repeatedly invokes the lpfn callback function until the last top-level window is enumerated or the callback function returns FALSE.CreateDesktopDesktopsEnumWindowsProcGetThreadDesktopOpenDesktopWindow Station and Desktop Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumDesktopWindows(nint hDesktop, MFENUMPROC lpfn, nint lParam);

        /// <summary>
        ///The EnumDisplayDevices function lets you obtain information about the display devices in the current session.
        /// </summary>
        /// <param name="lpDevice">A pointer to the device name. If NULL, function returns information for the display adapter(s) on the machine, based on iDevNum.For more information, see Remarks.</param>
        /// <param name="iDevNum">An index value that specifies the display device of interest.The operating system identifies each display device in the current session with an index value. The index values are consecutive integers, starting at 0. If the current session has three display devices, for example, they are specified by the index values 0, 1, and 2.</param>
        /// <param name="lpDisplayDevice"></param>
        /// <param name="dwFlags">Set this flag to EDD_GET_DEVICE_INTERFACE_NAME (0x00000001) to retrieve the device interface name for GUID_DEVINTERFACE_MONITOR, which is registered by the operating system on a per monitor basis. The value is placed in the DeviceID member of the DISPLAY_DEVICE structure returned in lpDisplayDevice. The resulting device interface name can be used with SetupAPI functions and serves as a link between GDI monitor devices and SetupAPI monitor devices.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. The function fails if iDevNum is greater than the largest device index.To query all display devices in the current session, call this function in a loop, starting with iDevNum set to 0, and incrementing iDevNum until the function fails. To select all display devices in the desktop, use only the display devices that have the DISPLAY_DEVICE_ATTACHED_TO_DESKTOP flag in the DISPLAY_DEVICE structure.To get information on the display adapter, call EnumDisplayDevices with lpDevice set to NULL. For example, DISPLAY_DEVICE.DeviceString contains the adapter name.To obtain information on a display monitor, first call EnumDisplayDevices with lpDevice set to NULL. Then call EnumDisplayDevices with lpDevice set to DISPLAY_DEVICE.DeviceName from the first call to EnumDisplayDevices and with iDevNum set to zero. Then DISPLAY_DEVICE.DeviceString is the monitor name.To query all monitor devices associated with an adapter, call EnumDisplayDevices in a loop with lpDevice set to the adapter name, iDevNum set to start at 0, and iDevNum set to increment until the function fails. Note that DISPLAY_DEVICE.DeviceName changes with each call for monitor information, so you must save the adapter name. The function fails when there are no more monitors for the adapter.ChangeDisplaySettingsChangeDisplaySettingsExCreateDCDEVMODEDISPLAY_DEVICEDevice Context FunctionsDevice Contexts OverviewEnumDisplaySettings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumDisplayDevicesA(string lpDevice, uint iDevNum, out DISPLAY_DEVICEA lpDisplayDevice, uint dwFlags);

        /// <summary>
        ///The EnumDisplayDevices function lets you obtain information about the display devices in the current session.
        /// </summary>
        /// <param name="lpDevice">A pointer to the device name. If NULL, function returns information for the display adapter(s) on the machine, based on iDevNum.For more information, see Remarks.</param>
        /// <param name="iDevNum">An index value that specifies the display device of interest.The operating system identifies each display device in the current session with an index value. The index values are consecutive integers, starting at 0. If the current session has three display devices, for example, they are specified by the index values 0, 1, and 2.</param>
        /// <param name="lpDisplayDevice"></param>
        /// <param name="dwFlags">Set this flag to EDD_GET_DEVICE_INTERFACE_NAME (0x00000001) to retrieve the device interface name for GUID_DEVINTERFACE_MONITOR, which is registered by the operating system on a per monitor basis. The value is placed in the DeviceID member of the DISPLAY_DEVICE structure returned in lpDisplayDevice. The resulting device interface name can be used with SetupAPI functions and serves as a link between GDI monitor devices and SetupAPI monitor devices.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. The function fails if iDevNum is greater than the largest device index.To query all display devices in the current session, call this function in a loop, starting with iDevNum set to 0, and incrementing iDevNum until the function fails. To select all display devices in the desktop, use only the display devices that have the DISPLAY_DEVICE_ATTACHED_TO_DESKTOP flag in the DISPLAY_DEVICE structure.To get information on the display adapter, call EnumDisplayDevices with lpDevice set to NULL. For example, DISPLAY_DEVICE.DeviceString contains the adapter name.To obtain information on a display monitor, first call EnumDisplayDevices with lpDevice set to NULL. Then call EnumDisplayDevices with lpDevice set to DISPLAY_DEVICE.DeviceName from the first call to EnumDisplayDevices and with iDevNum set to zero. Then DISPLAY_DEVICE.DeviceString is the monitor name.To query all monitor devices associated with an adapter, call EnumDisplayDevices in a loop with lpDevice set to the adapter name, iDevNum set to start at 0, and iDevNum set to increment until the function fails. Note that DISPLAY_DEVICE.DeviceName changes with each call for monitor information, so you must save the adapter name. The function fails when there are no more monitors for the adapter.ChangeDisplaySettingsChangeDisplaySettingsExCreateDCDEVMODEDISPLAY_DEVICEDevice Context FunctionsDevice Contexts OverviewEnumDisplaySettings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumDisplayDevicesW(string lpDevice, uint iDevNum, out DISPLAY_DEVICEW lpDisplayDevice, uint dwFlags);

        /// <summary>
        ///The EnumDisplayMonitors function enumerates display monitors (including invisible pseudo-monitors associated with the mirroring drivers) that intersect a region formed by the intersection of a specified clipping rectangle and the visible region of a device context. EnumDisplayMonitors calls an application-defined MonitorEnumProc callback function once for each monitor that is enumerated. Note that GetSystemMetrics (SM_CMONITORS) counts only the display monitors.
        /// </summary>
        /// <param name="hdc">A handle to a display device context that defines the visible region of interest.If this parameter is NULL, the hdcMonitor parameter passed to the callback function will be NULL, and the visible region of interest is the virtual screen that encompasses all the displays on the desktop.</param>
        /// <param name="lprcClip">A pointer to a RECT structure that specifies a clipping rectangle. The region of interest is the intersection of the clipping rectangle with the visible region specified by hdc.If hdc is non-NULL, the coordinates of the clipping rectangle are relative to the origin of the hdc. If hdc is NULL, the coordinates are virtual-screen coordinates.This parameter can be NULL if you don't want to clip the region specified by hdc.</param>
        /// <param name="lpfnEnum">A pointer to a MonitorEnumProc application-defined callback function.</param>
        /// <param name="dwData">Application-defined data that EnumDisplayMonitors passes directly to the MonitorEnumProc function.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.There are two reasons to call the EnumDisplayMonitors function:You do not need to use the EnumDisplayMonitors function when a window spans display monitors that have different color formats. You can continue to paint under the assumption that the entire screen has the color properties of the primary monitor. Your windows will look fine. EnumDisplayMonitors just lets you make them look better.Setting the hdc parameter to NULL lets you use the EnumDisplayMonitors function to obtain a handle and position rectangle for one or more display monitors. The following table shows how the four combinations of NULL and non-NULLhdc and lprcClip values affect the behavior of the EnumDisplayMonitors function.To paint in response to a WM_PAINT message, using the capabilities of each monitor, you can use code like this in a window procedure:To paint the top half of a window using the capabilities of each monitor, you can use code like this:To paint the entire virtual screen optimally for each display monitor, you can use code like this:To retrieve information about all of the display monitors, use code like this:GetSystemMetricsMonitorEnumProcMultiple Display Monitors FunctionsMultiple Display Monitors Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumDisplayMonitors(nint hdc, RECT lprcClip, MONITORENUMPROC lpfnEnum, nint dwData);

        /// <summary>
        ///The EnumDisplaySettings function retrieves information about one of the graphics modes for a display device. To retrieve information for all the graphics modes of a display device, make a series of calls to this function.
        /// </summary>
        /// <param name="lpszDeviceName">A pointer to a null-terminated string that specifies the display device about whose graphics mode the function will obtain information.This parameter is either NULL or a DISPLAY_DEVICE.DeviceName returned from EnumDisplayDevices. A NULL value specifies the current display device on the computer on which the calling thread is running.</param>
        /// <param name="iModeNum">The type of information to be retrieved. This value can be a graphics mode index or one of the following values.Graphics mode indexes start at zero. To obtain information for all of a display device's graphics modes, make a series of calls to EnumDisplaySettings, as follows: Set iModeNum to zero for the first call, and increment iModeNum by one for each subsequent call. Continue calling the function until the return value is zero.When you call EnumDisplaySettings with iModeNum set to zero, the operating system initializes and caches information about the display device. When you call EnumDisplaySettings with iModeNum set to a nonzero value, the function returns the information that was cached the last time the function was called with iModeNum set to zero.</param>
        /// <param name="lpDevMode"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumDisplaySettingsA(string lpszDeviceName, uint iModeNum, out uint lpDevMode);

        /// <summary>
        ///The EnumDisplaySettingsEx function retrieves information about one of the graphics modes for a display device. To retrieve information for all the graphics modes for a display device, make a series of calls to this function.
        /// </summary>
        /// <param name="lpszDeviceName">A pointer to a null-terminated string that specifies the display device about which graphics mode the function will obtain information.This parameter is either NULL or a DISPLAY_DEVICE.DeviceName returned from EnumDisplayDevices. A NULL value specifies the current display device on the computer that the calling thread is running on.</param>
        /// <param name="iModeNum">Indicates the type of information to be retrieved. This value can be a graphics mode index or one of the following values.Graphics mode indexes start at zero. To obtain information for all of a display device's graphics modes, make a series of calls to EnumDisplaySettingsEx, as follows: Set iModeNum to zero for the first call, and increment iModeNum by one for each subsequent call. Continue calling the function until the return value is zero.When you call EnumDisplaySettingsEx with iModeNum set to zero, the operating system initializes and caches information about the display device. When you call EnumDisplaySettingsEx with iModeNum set to a nonzero value, the function returns the information that was cached the last time the function was called with iModeNum set to zero.</param>
        /// <param name="lpDevMode"></param>
        /// <param name="dwFlags">This parameter can be the following value.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.The function fails if iModeNum is greater than the index of the display device's last graphics mode. As noted in the description of the iModeNum parameter, you can use this behavior to enumerate all of a display device's graphics modes.ChangeDisplaySettingsChangeDisplaySettingsExCreateDCCreateDesktopDEVMODEDISPLAY_DEVICEDevice Context FunctionsDevice Contexts OverviewEnumDisplayDevicesEnumDisplaySettings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumDisplaySettingsExA(string lpszDeviceName, uint iModeNum, out uint lpDevMode, uint dwFlags);

        /// <summary>
        ///The EnumDisplaySettingsEx function retrieves information about one of the graphics modes for a display device. To retrieve information for all the graphics modes for a display device, make a series of calls to this function.
        /// </summary>
        /// <param name="lpszDeviceName">A pointer to a null-terminated string that specifies the display device about which graphics mode the function will obtain information.This parameter is either NULL or a DISPLAY_DEVICE. DeviceName returned from EnumDisplayDevices. A NULL value specifies the current display device on the computer that the calling thread is running on.</param>
        /// <param name="iModeNum">Indicates the type of information to be retrieved. This value can be a graphics mode index or one of the following values.Graphics mode indexes start at zero. To obtain information for all of a display device's graphics modes, make a series of calls to EnumDisplaySettingsEx, as follows: Set iModeNum to zero for the first call, and increment iModeNum by one for each subsequent call. Continue calling the function until the return value is zero.When you call EnumDisplaySettingsEx with iModeNum set to zero, the operating system initializes and caches information about the display device. When you call EnumDisplaySettingsEx with iModeNum set to a nonzero value, the function returns the information that was cached the last time the function was called with iModeNum set to zero.</param>
        /// <param name="lpDevMode"></param>
        /// <param name="dwFlags">This parameter can be the following value.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.The function fails if iModeNum is greater than the index of the display device's last graphics mode. As noted in the description of the iModeNum parameter, you can use this behavior to enumerate all of a display device's graphics modes.ChangeDisplaySettingsChangeDisplaySettingsExCreateDCCreateDesktopDEVMODEDISPLAY_DEVICEDevice Context FunctionsDevice Contexts OverviewEnumDisplayDevicesEnumDisplaySettings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumDisplaySettingsExW(string lpszDeviceName, uint iModeNum, out uint lpDevMode, uint dwFlags);

        /// <summary>
        ///The EnumDisplaySettings function retrieves information about one of the graphics modes for a display device. To retrieve information for all the graphics modes of a display device, make a series of calls to this function.
        /// </summary>
        /// <param name="lpszDeviceName">A pointer to a null-terminated string that specifies the display device about whose graphics mode the function will obtain information.This parameter is either NULL or a DISPLAY_DEVICE.DeviceName returned from EnumDisplayDevices. A NULL value specifies the current display device on the computer on which the calling thread is running.</param>
        /// <param name="iModeNum">The type of information to be retrieved. This value can be a graphics mode index or one of the following values.Graphics mode indexes start at zero. To obtain information for all of a display device's graphics modes, make a series of calls to EnumDisplaySettings, as follows: Set iModeNum to zero for the first call, and increment iModeNum by one for each subsequent call. Continue calling the function until the return value is zero.When you call EnumDisplaySettings with iModeNum set to zero, the operating system initializes and caches information about the display device. When you call EnumDisplaySettings with iModeNum set to a nonzero value, the function returns the information that was cached the last time the function was called with iModeNum set to zero.</param>
        /// <param name="lpDevMode"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumDisplaySettingsW(string lpszDeviceName, uint iModeNum, out uint lpDevMode);

        /// <summary>
        ///Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function. EnumProps continues until the last entry is enumerated or the callback function returns FALSE.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose property list is to be enumerated.</param>
        /// <param name="lpEnumFunc">Type: PROPENUMPROCA pointer to the callback function. For more information about the callback function, see the PropEnumProc function.Type: intThe return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for enumeration.An application can remove only those properties it has added. It must not remove properties added by other applications or by the system itself.ConceptualEnumPropsExPropEnumProcReferenceWindow Properties</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int EnumPropsA(nint hWnd, PROPENUMPROCA lpEnumFunc);

        /// <summary>
        ///Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function. EnumPropsEx continues until the last entry is enumerated or the callback function returns FALSE.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose property list is to be enumerated.</param>
        /// <param name="lpEnumFunc">Type: PROPENUMPROCEXA pointer to the callback function. For more information about the callback function, see the PropEnumProcEx function.</param>
        /// <param name="lParam">Type: LPARAMApplication-defined data to be passed to the callback function.Type: intThe return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for enumeration.An application can remove only those properties it has added. It must not remove properties added by other applications or by the system itself.For an example, see Listing Window Properties for a Given Window.ConceptualPropEnumProcExReferenceWindow Properties</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int EnumPropsExA(nint hWnd, PROPENUMPROCEXA lpEnumFunc, nint lParam);

        /// <summary>
        ///Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function. EnumPropsEx continues until the last entry is enumerated or the callback function returns FALSE.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose property list is to be enumerated.</param>
        /// <param name="lpEnumFunc">Type: PROPENUMPROCEXA pointer to the callback function. For more information about the callback function, see the PropEnumProcEx function.</param>
        /// <param name="lParam">Type: LPARAMApplication-defined data to be passed to the callback function.Type: intThe return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for enumeration.An application can remove only those properties it has added. It must not remove properties added by other applications or by the system itself.For an example, see Listing Window Properties for a Given Window.ConceptualPropEnumProcExReferenceWindow Properties</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int EnumPropsExW(nint hWnd, PROPENUMPROCEXW lpEnumFunc, nint lParam);

        /// <summary>
        ///Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function. EnumProps continues until the last entry is enumerated or the callback function returns FALSE.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose property list is to be enumerated.</param>
        /// <param name="lpEnumFunc">Type: PROPENUMPROCA pointer to the callback function. For more information about the callback function, see the PropEnumProc function.Type: intThe return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for enumeration.An application can remove only those properties it has added. It must not remove properties added by other applications or by the system itself.ConceptualEnumPropsExPropEnumProcReferenceWindow Properties</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int EnumPropsW(nint hWnd, PROPENUMPROCW lpEnumFunc);

        /// <summary>
        ///Enumerates all nonchild windows associated with a thread by passing the handle to each window, in turn, to an application-defined callback function. EnumThreadWindows continues until the last window is enumerated or the callback function returns FALSE. To enumerate child windows of a particular window, use the EnumChildWindows function.
        /// </summary>
        /// <param name="dwThreadId">Type: DWORDThe identifier of the thread whose windows are to be enumerated.</param>
        /// <param name="lpfn">Type: WNDENUMPROCA pointer to an application-defined callback function. For more information, see EnumThreadWndProc.</param>
        /// <param name="lParam">Type: LPARAMAn application-defined value to be passed to the callback function.Type: BOOLIf the callback function returns TRUE for all windows in the thread specified by dwThreadId, the return value is TRUE. If the callback function returns FALSE on any enumerated window, or if there are no windows found in the thread specified by dwThreadId, the return value is FALSE.ConceptualEnumChildWindowsEnumThreadWndProcEnumWindowsReferenceWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumThreadWindows(uint dwThreadId, MFENUMPROC lpfn, nint lParam);

        /// <summary>
        ///Enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE.
        /// </summary>
        /// <param name="lpEnumFunc">Type: WNDENUMPROCA pointer to an application-defined callback function. For more information, see EnumWindowsProc.</param>
        /// <param name="lParam">Type: LPARAMAn application-defined value to be passed to the callback function.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.If EnumWindowsProc returns zero, the return value is also zero. In this case, the callback function should call SetLastError to obtain a meaningful error code to be returned to the caller of EnumWindows.The EnumWindows function does not enumerate child windows, with the exception of a few top-level windows owned by the system that have the WS_CHILD style.This function is more reliable than calling the GetWindow function in a loop. An application that calls GetWindow to perform this task risks being caught in an infinite loop or referencing a handle to a window that has been destroyed.ConceptualEnumChildWindowsEnumWindowsProcGetWindowReferenceWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumWindows(MFENUMPROC lpEnumFunc, nint lParam);

        /// <summary>
        ///Enumerates all window stations in the current session. The function passes the name of each window station, in turn, to an application-defined callback function.
        /// </summary>
        /// <param name="lpEnumFunc">A pointer to an application-defined EnumWindowStationProc callback function.</param>
        /// <param name="lParam">An application-defined value to be passed to the callback function.If the function succeeds, it returns the nonzero value returned by the callback function that was pointed to by lpEnumFunc.If the function is unable to perform the enumeration, the return value is zero. Call GetLastError to get extended error information.If the callback function fails, the return value is zero. The callback function can call SetLastError to set an error code for the caller to retrieve by calling GetLastError.The EnumWindowStations function enumerates only those window stations for which the calling process has the WINSTA_ENUMERATE access right. For more information, see Window Station Security and Access Rights.EnumWindowStations repeatedly invokes the lpEnumFunc callback function until the last window station is enumerated or the callback function returns FALSE.EnumWindowStationProcWindow Station and Desktop FunctionsWindow Stations</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumWindowStationsA(ICMENUMPROCA lpEnumFunc, nint lParam);

        /// <summary>
        ///Enumerates all window stations in the current session. The function passes the name of each window station, in turn, to an application-defined callback function.
        /// </summary>
        /// <param name="lpEnumFunc">A pointer to an application-defined EnumWindowStationProc callback function.</param>
        /// <param name="lParam">An application-defined value to be passed to the callback function.If the function succeeds, it returns the nonzero value returned by the callback function that was pointed to by lpEnumFunc.If the function is unable to perform the enumeration, the return value is zero. Call GetLastError to get extended error information.If the callback function fails, the return value is zero. The callback function can call SetLastError to set an error code for the caller to retrieve by calling GetLastError.The EnumWindowStations function enumerates only those window stations for which the calling process has the WINSTA_ENUMERATE access right. For more information, see Window Station Security and Access Rights.EnumWindowStations repeatedly invokes the lpEnumFunc callback function until the last window station is enumerated or the callback function returns FALSE.EnumWindowStationProcWindow Station and Desktop FunctionsWindow Stations</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EnumWindowStationsW(ICMENUMPROCW lpEnumFunc, nint lParam);

        /// <summary>
        ///The EqualRect function determines whether the two specified rectangles are equal by comparing the coordinates of their upper-left and lower-right corners.
        /// </summary>
        /// <param name="lprc1">Pointer to a RECT structure that contains the logical coordinates of the first rectangle.</param>
        /// <param name="lprc2">Pointer to a RECT structure that contains the logical coordinates of the second rectangle.If the two rectangles are identical, the return value is nonzero.If the two rectangles are not identical, the return value is zero.The EqualRect function does not treat empty rectangles as equal if their coordinates are different.Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure.IsRectEmptyPtInRectRECTRectangle FunctionsRectangles Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EqualRect(RECT lprc1, RECT lprc2);

        /// <summary>
        ///Returns the score of a polygon as the probable touch target (compared to all other polygons that intersect the touch contact area) and an adjusted touch point within the polygon.
        /// </summary>
        /// <param name="numVertices"></param>
        /// <param name="controlPolygon">The array of x-y screen coordinates that define the shape of the UI element.The numVertices parameter specifies the number of coordinates.</param>
        /// <param name="pHitTestingInput">The TOUCH_HIT_TESTING_INPUT structure that holds the data for the touch contact area.</param>
        /// <param name="pProximityEval"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EvaluateProximityToPolygon(int numVertices, POINT controlPolygon, TOUCH_HIT_TESTING_INPUT pHitTestingInput, out TOUCH_HIT_TESTING_PROXIMITY_EVALUATION pProximityEval);

        /// <summary>
        ///Returns the score of a rectangle as the probable touch target, compared to all other rectangles that intersect the touch contact area, and an adjusted touch point within the rectangle.
        /// </summary>
        /// <param name="controlBoundingBox">The RECT structure that defines the bounding box of the UI element.</param>
        /// <param name="pHitTestingInput">The TOUCH_HIT_TESTING_INPUT structure that holds the data for the touch contact area.</param>
        /// <param name="pProximityEval"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool EvaluateProximityToRect(RECT controlBoundingBox, TOUCH_HIT_TESTING_INPUT pHitTestingInput, out TOUCH_HIT_TESTING_PROXIMITY_EVALUATION pProximityEval);

        /// <summary>
        ///The ExcludeUpdateRgn function prevents drawing within invalid areas of a window by excluding an updated region in the window from a clipping region.
        /// </summary>
        /// <param name="hDC">Handle to the device context associated with the clipping region.</param>
        /// <param name="hWnd">Handle to the window to update.The return value specifies the complexity of the excluded region; it can be any one of the following values.BeginPaintGetUpdateRectGetUpdateRgnPainting and Drawing FunctionsPainting and Drawing OverviewUpdateWindow</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ExcludeUpdateRgn(nint hDC, nint hWnd);

        /// <summary>
        ///Logs off the interactive user, shuts down the system, or shuts down and restarts the system. It sends the WM_QUERYENDSESSION message to all applications to determine if they can be terminated.
        /// </summary>
        /// <param name="uFlags">The shutdown type. This parameter must include one of the following values.This parameter can optionally include one of the following values.</param>
        /// <param name="dwReason">The reason for initiating the shutdown. This parameter must be one of the system shutdown reason codes.If this parameter is zero, the SHTDN_REASON_FLAG_PLANNED reason code will not be set and therefore the default action is an undefined shutdown that is logged as "No title for this reason could be found". By default, it is also an unplanned shutdown. Depending on how the system is configured, an unplanned shutdown triggers the creation of a file that contains the system state information, which can delay shutdown. Therefore, do not use zero for this parameter.If the function succeeds, the return value is nonzero. Because the function executes asynchronously, a nonzero return value indicates that the shutdown has been initiated. It does not indicate whether the shutdown will succeed. It is possible that the system, the user, or another application will abort the shutdown.If the function fails, the return value is zero. To get extended error information, call GetLastError.The ExitWindowsEx function returns as soon as it has initiated the shutdown process. The shutdown or logoff then proceeds asynchronously. The function is designed to stop all processes in the caller's logon session. Therefore, if you are not the interactive user, the function can succeed without actually shutting down the computer. If you are not the interactive user, use the InitiateSystemShutdown or InitiateSystemShutdownEx function.A non-zero return value does not mean the logoff was or will be successful. The shutdown is an asynchronous process, and it can occur long after the API call has returned, or not at all. Even if the timeout value is zero, the shutdown can still be aborted by applications, services, or even the system. The non-zero return value indicates that the validation of the rights and parameters was successful and that the system accepted the shutdown request.When this function is called, the caller must specify whether or not applications with unsaved changes should be forcibly closed. If the caller chooses not to force these applications to close and an application with unsaved changes is running on the console session, the shutdown will remain in progress until the user logged into the console session aborts the shutdown, saves changes, closes the application, or forces the application to close. During this period, the shutdown may not be aborted except by the console user, and another shutdown may not be initiated.Calling this function with the value of the uFlags parameter set to EWX_FORCE avoids this situation. Remember that doing this may result in loss of data.To set a shutdown priority for an application relative to other applications in the system, use the SetProcessShutdownParameters function.During a shutdown or log-off operation, running applications are allowed a specific amount of time to respond to the shutdown request. If this time expires before all applications have stopped, the system displays a user interface that allows the user to forcibly shut down the system or to cancel the shutdown request. If the EWX_FORCE value is specified, the system forces running applications to stop when the time expires.If the EWX_FORCEIFHUNG value is specified, the system forces hung applications to close and does not display the dialog box.Console processes receive a separate notification message, CTRL_SHUTDOWN_EVENT or CTRL_LOGOFF_EVENT, as the situation warrants. A console process routes these messages to its HandlerRoutine function. ExitWindowsEx sends these notification messages asynchronously; thus, an application cannot assume that the console notification messages have been handled when a call to ExitWindowsEx returns.To shut down or restart the system, the calling process must use the AdjustTokenPrivileges function to enable the SE_SHUTDOWN_NAME privilege. For more information, see Running with Special Privileges.For an example, see How to Shut Down the System.AdjustTokenPrivilegesHandlerRoutineLogging OffSetProcessShutdownParametersShutting DownSystem Shutdown Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ExitWindowsEx(uint uFlags, uint dwReason);

        /// <summary>
        ///The FillRect function fills a rectangle by using the specified brush. This function includes the left and top borders, but excludes the right and bottom borders of the rectangle.
        /// </summary>
        /// <param name="hDC">A handle to the device context.</param>
        /// <param name="lprc">A pointer to a RECT structure that contains the logical coordinates of the rectangle to be filled.</param>
        /// <param name="hbr">A handle to the brush used to fill the rectangle.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.The brush identified by the hbr parameter may be either a handle to a logical brush or a color value. If specifying a handle to a logical brush, call one of the following functions to obtain the handle: CreateHatchBrush, CreatePatternBrush, or CreateSolidBrush. Additionally, you may retrieve a handle to one of the stock brushes by using the GetStockObject function. If specifying a color value for the hbr parameter, it must be one of the standard system colors (the value 1 must be added to the chosen color). For example:For a list of all the standard system colors, see GetSysColor.When filling the specified rectangle, FillRect does not include the rectangle's right and bottom sides. GDI fills a rectangle up to, but not including, the right column and bottom row, regardless of the current mapping mode.For an example, see Using Rectangles.CreateHatchBrushCreatePatternBrushCreateSolidBrushFilled Shape FunctionsFilled Shapes OverviewGetStockObjectRECT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int FillRect(nint hDC, RECT lprc, nint hbr);

        /// <summary>
        ///Retrieves a handle to the top-level window whose class name and window name match the specified strings. This function does not search child windows. This function does not perform a case-sensitive search.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint FindWindowA(string lpClassName, string lpWindowName);

        /// <summary>
        ///Retrieves a handle to a window whose class name and window name match the specified strings. The function searches child windows, beginning with the one following the specified child window. This function does not perform a case-sensitive search.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint FindWindowExA(nint hWndParent, nint hWndChildAfter, string lpszClass, string lpszWindow);

        /// <summary>
        ///Retrieves a handle to a window whose class name and window name match the specified strings. The function searches child windows, beginning with the one following the specified child window. This function does not perform a case-sensitive search.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint FindWindowExW(nint hWndParent, nint hWndChildAfter, string lpszClass, string lpszWindow);

        /// <summary>
        ///Retrieves a handle to the top-level window whose class name and window name match the specified strings. This function does not search child windows. This function does not perform a case-sensitive search.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint FindWindowW(string lpClassName, string lpWindowName);

        /// <summary>
        ///Flashes the specified window one time. It does not change the active state of the window.
        /// </summary>
        /// <param name="hWnd">A handle to the window to be flashed. The window can be either open or minimized.</param>
        /// <param name="bInvert">If this parameter is TRUE, the window is flashed from one state to the other. If it is FALSE, the window is returned to its original state (either active or inactive).When an application is minimized and this parameter is TRUE, the taskbar window button flashes active/inactive. If it is FALSE, the taskbar window button flashes inactive, meaning that it does not change colors. It flashes, as if it were being redrawn, but it does not provide the visual invert clue to the user.The return value specifies the window's state before the call to the FlashWindow function. If the window caption was drawn as active before the call, the return value is nonzero. Otherwise, the return value is zero.Flashing a window means changing the appearance of its caption bar as if the window were changing from inactive to active status, or vice versa. (An inactive caption bar changes to an active caption bar; an active caption bar changes to an inactive caption bar.)Typically, a window is flashed to inform the user that the window requires attention but that it does not currently have the keyboard focus.The FlashWindow function flashes the window only once; for repeated flashing, the application should create a system timer.Error Handling FunctionsNotifying the User</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool FlashWindow(nint hWnd, bool bInvert);

        /// <summary>
        ///Flashes the specified window. It does not change the active state of the window.
        /// </summary>
        /// <param name="pfwi">A pointer to a FLASHWINFO structure.The return value specifies the window's state before the call to the FlashWindowEx function. If the window caption was drawn as active before the call, the return value is nonzero. Otherwise, the return value is zero.Typically, you flash a window to inform the user that the window requires attention but does not currently have the keyboard focus. When a window flashes, it appears to change from inactive to active status. An inactive caption bar changes to an active caption bar; an active caption bar changes to an inactive caption bar.Error Handling FunctionsFLASHWINFONotifying the User</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool FlashWindowEx(FLASHWINFO pfwi);

        /// <summary>
        ///The FrameRect function draws a border around the specified rectangle by using the specified brush. The width and height of the border are always one logical unit.
        /// </summary>
        /// <param name="hDC">A handle to the device context in which the border is drawn.</param>
        /// <param name="lprc">A pointer to a RECT structure that contains the logical coordinates of the upper-left and lower-right corners of the rectangle.</param>
        /// <param name="hbr">A handle to the brush used to draw the border.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.The brush identified by the hbr parameter must have been created by using the CreateHatchBrush, CreatePatternBrush, or CreateSolidBrush function, or retrieved by using the GetStockObject function.If the bottom member of the RECT structure is less than the top member, or if the right member is less than the left member, the function does not draw the rectangle.CreateHatchBrushCreatePatternBrushCreateSolidBrushFilled Shape FunctionsFilled Shapes OverviewGetStockObjectRECT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int FrameRect(nint hDC, RECT lprc, nint hbr);

        /// <summary>
        ///Retrieves the window handle to the active window attached to the calling thread's message queue.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetActiveWindow();

        /// <summary>
        ///Retrieves status information for the specified window if it is the application-switching (ALT+TAB) window.
        /// </summary>
        /// <param name="hwnd"></param>
        /// <param name="iItem">Type: intThe index of the icon in the application-switching window. If the pszItemText parameter is not NULL, the name of the item is copied to the pszItemText string. If this parameter is –1, the name of the item is not copied.</param>
        /// <param name="pati">Type: PALTTABINFOA pointer to an ALTTABINFO structure to receive the status information. Note that you must set the csSize member to sizeof(ALTTABINFO) before calling this function.</param>
        /// <param name="pszItemText"></param>
        /// <param name="cchItemText">Type: UINTThe size, in characters, of the pszItemText buffer.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The application-switching window enables you to switch to the most recently used application window. To display the application-switching window, press ALT+TAB. To select an application from the list, continue to hold ALT down and press TAB to move through the list. Add SHIFT to reverse direction through the list.ALTTABINFOConceptualReferenceWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetAltTabInfoA(nint hwnd, int iItem, out ALTTABINFO pati, out string pszItemText, uint cchItemText);

        /// <summary>
        ///Retrieves status information for the specified window if it is the application-switching (ALT+TAB) window.
        /// </summary>
        /// <param name="hwnd"></param>
        /// <param name="iItem">Type: intThe index of the icon in the application-switching window. If the pszItemText parameter is not NULL, the name of the item is copied to the pszItemText string. If this parameter is –1, the name of the item is not copied.</param>
        /// <param name="pati">Type: PALTTABINFOA pointer to an ALTTABINFO structure to receive the status information. Note that you must set the csSize member to sizeof(ALTTABINFO) before calling this function.</param>
        /// <param name="pszItemText"></param>
        /// <param name="cchItemText">Type: UINTThe size, in characters, of the pszItemText buffer.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The application-switching window enables you to switch to the most recently used application window. To display the application-switching window, press ALT+TAB. To select an application from the list, continue to hold ALT down and press TAB to move through the list. Add SHIFT to reverse direction through the list.ALTTABINFOConceptualReferenceWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetAltTabInfoW(nint hwnd, int iItem, out ALTTABINFO pati, out string pszItemText, uint cchItemText);

        /// <summary>
        ///Retrieves the handle to the ancestor of the specified window.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window whose ancestor is to be retrieved. If this parameter is the desktop window, the function returns NULL.</param>
        /// <param name="gaFlags">Type: UINTThe ancestor to be retrieved. This parameter can be one of the following values.Type: HWNDThe return value is the handle to the ancestor window.ConceptualGetParentReferenceWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetAncestor(nint hwnd, uint gaFlags);

        /// <summary>
        ///Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.
        /// </summary>
        /// <param name="vKey">Type: intThe virtual-key code. For more information, see Virtual Key Codes.You can use left- and right-distinguishing constants to specify certain keys. See the Remarks section for further information.Type: SHORTIf the function succeeds, the return value specifies whether the key was pressed since the last call to GetAsyncKeyState, and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to GetAsyncKeyState. However, you should not rely on this last behavior; for more information, see the Remarks.The return value is zero for the following cases:The GetAsyncKeyState function works with mouse buttons. However, it checks on the state of the physical mouse buttons, not on the logical mouse buttons that the physical buttons are mapped to. For example, the call GetAsyncKeyState(VK_LBUTTON) always returns the state of the left physical mouse button, regardless of whether it is mapped to the left or right logical mouse button. You can determine the system's current mapping of physical mouse buttons to logical mouse buttons by calling GetSystemMetrics(SM_SWAPBUTTON).which returns TRUE if the mouse buttons have been swapped.Although the least significant bit of the return value indicates whether the key has been pressed since the last query, due to the preemptive multitasking nature of Windows, another application can call GetAsyncKeyState and receive the "recently pressed" bit instead of your application. The behavior of the least significant bit of the return value is retained strictly for compatibility with 16-bit Windows applications (which are non-preemptive) and should not be relied upon.You can use the virtual-key code constants VK_SHIFT, VK_CONTROL, and VK_MENU as values for the vKey parameter. This gives the state of the SHIFT, CTRL, or ALT keys without distinguishing between left and right.You can use the following virtual-key code constants as values for vKey to distinguish between the left and right instances of those keys.These left- and right-distinguishing constants are only available when you call the GetKeyboardState, SetKeyboardState, GetAsyncKeyState, GetKeyState, and MapVirtualKey functions.Example from Windows Classic Samples on GitHub.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short GetAsyncKeyState(int vKey);

        /// <summary>
        ///Retrieves an AR_STATE value containing the state of screen auto-rotation for the system, for example whether auto-rotation is supported, and whether it is enabled by the user. GetAutoRotationState provides a robust and diverse way of querying for auto-rotation state, and more. For example, if you want your app to behave differently when multiple monitors are attached then you can determine that from the AR_STATE returned.
        /// </summary>

        [DllImport("Kernel.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetAutoRotationState(out AR_STATE pState);

        /// <summary>
        ///Retrieves the DPI_AWARENESS value from a DPI_AWARENESS_CONTEXT.
        /// </summary>
        /// <param name="value">The DPI_AWARENESS_CONTEXT you want to examine.The DPI_AWARENESS. If the provided value is null or invalid, this method will return DPI_AWARENESS_INVALID.A DPI_AWARENESS_CONTEXT contains multiple pieces of information. For example, it includes both the current and the inherited DPI_AWARENESS. This method retrieves the DPI_AWARENESS from the structure.DPI_AWARENESS</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern DPI_AWARENESS GetAwarenessFromDpiAwarenessContext(DPI_AWARENESS value);

        /// <summary>
        ///Retrieves a handle to the window (if any) that has captured the mouse. Only one window at a time can capture the mouse; this window receives mouse input whether or not the cursor is within its borders.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetCapture();

        /// <summary>
        ///Retrieves the time required to invert the caret's pixels. The user can set this value.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetCaretBlinkTime();

        /// <summary>
        ///Copies the caret's position to the specified POINT structure.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetCaretPos(out POINT lpPoint);

        /// <summary>
        ///[GetCIMSSM may be altered or unavailable in the future. Instead, use GetCurrentInputMessageSource.]
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetCIMSSM(out INPUT_MESSAGE_SOURCE inputMessageSource);

        /// <summary>
        ///Retrieves information about a window class.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpClassName">Type: LPCTSTRThe class name. The name must be that of a preregistered class or a class registered by a previous call to the RegisterClass or RegisterClassEx function.Alternatively, this parameter can be an atom. If so, it must be a class atom created by a previous call to RegisterClass or RegisterClassEx. The atom must be in the low-order word of lpClassName; the high-order word must be zero.</param>
        /// <param name="lpWndClass"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetClassInfoA(nint hInstance, string lpClassName, out WNDCLASSA lpWndClass);

        /// <summary>
        ///Retrieves information about a window class, including a handle to the small icon associated with the window class. The GetClassInfo function does not retrieve a handle to the small icon.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpszClass">Type: LPCTSTRThe class name. The name must be that of a preregistered class or a class registered by a previous call to the RegisterClass or RegisterClassEx function. Alternatively, this parameter can be a class atom created by a previous call to RegisterClass or RegisterClassEx. The atom must be in the low-order word of lpszClass; the high-order word must be zero.</param>
        /// <param name="lpwcx"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetClassInfoExA(nint hInstance, string lpszClass, out WNDCLASSEXA lpwcx);

        /// <summary>
        ///Retrieves information about a window class, including a handle to the small icon associated with the window class. The GetClassInfo function does not retrieve a handle to the small icon.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpszClass">Type: LPCTSTRThe class name. The name must be that of a preregistered class or a class registered by a previous call to the RegisterClass or RegisterClassEx function. Alternatively, this parameter can be a class atom created by a previous call to RegisterClass or RegisterClassEx. The atom must be in the low-order word of lpszClass; the high-order word must be zero.</param>
        /// <param name="lpwcx"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetClassInfoExW(nint hInstance, string lpszClass, out WNDCLASSEXW lpwcx);

        /// <summary>
        ///Retrieves information about a window class.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpClassName">Type: LPCTSTRThe class name. The name must be that of a preregistered class or a class registered by a previous call to the RegisterClass or RegisterClassEx function.Alternatively, this parameter can be an atom. If so, it must be a class atom created by a previous call to RegisterClass or RegisterClassEx. The atom must be in the low-order word of lpClassName; the high-order word must be zero.</param>
        /// <param name="lpWndClass"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetClassInfoW(nint hInstance, string lpClassName, out WNDCLASSW lpWndClass);

        /// <summary>
        ///Retrieves the specified 32-bit (DWORD) value from the WNDCLASSEX structure associated with the specified window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe value to be retrieved. To retrieve a value from the extra class memory, specify the positive, zero-based byte offset of the value to be retrieved. Valid values are in the range zero through the number of bytes of extra class memory, minus four; for example, if you specified 12 or more bytes of extra class memory, a value of 8 would be an index to the third integer. To retrieve any other value from the WNDCLASSEX structure, specify one of the following values.Type: DWORDIf the function succeeds, the return value is the requested value.If the function fails, the return value is zero. To get extended error information, call GetLastError.Reserve extra class memory by specifying a nonzero value in the cbClsExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.ConceptualGetClassLongPtrGetWindowLongReferenceRegisterClassExSetClassLongWNDCLASSEXWindow Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetClassLongA(nint hWnd, int nIndex);

        /// <summary>
        ///Retrieves the specified value from the WNDCLASSEX structure associated with the specified window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe value to be retrieved. To retrieve a value from the extra class memory, specify the positive, zero-based byte offset of the value to be retrieved. Valid values are in the range zero through the number of bytes of extra class memory, minus eight; for example, if you specified 24 or more bytes of extra class memory, a value of 16 would be an index to the third integer. To retrieve any other value from the WNDCLASSEX structure, specify one of the following values.Type: ULONG_PTRIf the function succeeds, the return value is the requested value.If the function fails, the return value is zero. To get extended error information, call GetLastError.Reserve extra class memory by specifying a nonzero value in the cbClsExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.ConceptualGetWindowLongPtrReferenceRegisterClassExSetClassLongPtrWNDCLASSEXWindow Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetClassLongPtrA(nint hWnd, int nIndex);

        /// <summary>
        ///Retrieves the specified value from the WNDCLASSEX structure associated with the specified window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe value to be retrieved. To retrieve a value from the extra class memory, specify the positive, zero-based byte offset of the value to be retrieved. Valid values are in the range zero through the number of bytes of extra class memory, minus eight; for example, if you specified 24 or more bytes of extra class memory, a value of 16 would be an index to the third integer. To retrieve any other value from the WNDCLASSEX structure, specify one of the following values.Type: ULONG_PTRIf the function succeeds, the return value is the requested value.If the function fails, the return value is zero. To get extended error information, call GetLastError.Reserve extra class memory by specifying a nonzero value in the cbClsExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.ConceptualGetWindowLongPtrReferenceRegisterClassExSetClassLongPtrWNDCLASSEXWindow Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetClassLongPtrW(nint hWnd, int nIndex);

        /// <summary>
        ///Retrieves the specified 32-bit (DWORD) value from the WNDCLASSEX structure associated with the specified window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe value to be retrieved. To retrieve a value from the extra class memory, specify the positive, zero-based byte offset of the value to be retrieved. Valid values are in the range zero through the number of bytes of extra class memory, minus four; for example, if you specified 12 or more bytes of extra class memory, a value of 8 would be an index to the third integer. To retrieve any other value from the WNDCLASSEX structure, specify one of the following values.Type: DWORDIf the function succeeds, the return value is the requested value.If the function fails, the return value is zero. To get extended error information, call GetLastError.Reserve extra class memory by specifying a nonzero value in the cbClsExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.ConceptualGetClassLongPtrGetWindowLongReferenceRegisterClassExSetClassLongWNDCLASSEXWindow Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetClassLongW(nint hWnd, int nIndex);

        /// <summary>
        ///Retrieves the name of the class to which the specified window belongs.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="lpClassName"></param>
        /// <param name="nMaxCount">Type: intThe length of the lpClassName buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the class name string is truncated to nMaxCount-1 characters.Type: intIf the function succeeds, the return value is the number of characters copied to the buffer, not including the terminating null character.If the function fails, the return value is zero. To get extended error information, call GetLastError function.FindWindowA function, GetClassInfoA function, GetClassLongA function, GetClassWord function, Window Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetClassName(nint hWnd, out string lpClassName, int nMaxCount);

        /// <summary>
        ///Retrieves the name of the class to which the specified window belongs.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="lpClassName"></param>
        /// <param name="nMaxCount">Type: intThe length of the lpClassName buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the class name string is truncated to nMaxCount-1 characters.Type: intIf the function succeeds, the return value is the number of characters copied to the buffer, not including the terminating null character.If the function fails, the return value is zero. To get extended error information, call GetLastError.ConceptualFindWindowGetClassInfoGetClassLongGetClassWordReferenceWindow Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetClassNameA(nint hWnd, out string lpClassName, int nMaxCount);

        /// <summary>
        ///Retrieves the name of the class to which the specified window belongs.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="lpClassName"></param>
        /// <param name="nMaxCount">Type: intThe length of the lpClassName buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the class name string is truncated to nMaxCount-1 characters.Type: intIf the function succeeds, the return value is the number of characters copied to the buffer, not including the terminating null character.If the function fails, the return value is zero. To get extended error information, call GetLastError.ConceptualFindWindowGetClassInfoGetClassLongGetClassWordReferenceWindow Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetClassNameW(nint hWnd, out string lpClassName, int nMaxCount);

        /// <summary>
        ///Retrieves the 16-bit (WORD) value at the specified offset into the extra class memory for the window class to which the specified window belongs.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe zero-based byte offset of the value to be retrieved. Valid values are in the range zero through the number of bytes of class memory, minus two; for example, if you specified 10 or more bytes of extra class memory, a value of eight would be an index to the fifth 16-bit integer. There is an additional valid value as shown in the following table.Type: WORDIf the function succeeds, the return value is the requested 16-bit value.If the function fails, the return value is zero. To get extended error information, call GetLastError.Reserve extra class memory by specifying a nonzero value in the cbClsExtra member of the WNDCLASS structure used with the RegisterClass function.ConceptualGetClassLongReferenceRegisterClassRegisterClassExSetClassWordWNDCLASSWindow Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short GetClassWord(nint hWnd, int nIndex);

        /// <summary>
        ///Retrieves the coordinates of a window's client area. The client coordinates specify the upper-left and lower-right corners of the client area. Because client coordinates are relative to the upper-left corner of a window's client area, the coordinates of the upper-left corner are (0,0).
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose client coordinates are to be retrieved.</param>
        /// <param name="lpRect"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetClientRect(nint hWnd, out RECT lpRect);

        /// <summary>
        ///Retrieves data from the clipboard in a specified format. The clipboard must have been opened previously.
        /// </summary>
        /// <param name="uFormat">Type: UINTA clipboard format. For a description of the standard clipboard formats, see Standard Clipboard Formats.Type: HANDLEIf the function succeeds, the return value is the handle to a clipboard object in the specified format.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The clipboard controls the handle that the GetClipboardData function returns, not the application. The application should copy the data immediately. The application must not free the handle nor leave it locked. The application must not use the handle after the EmptyClipboard or CloseClipboard function is called, or after the SetClipboardData function is called with the same clipboard format.The system performs implicit data format conversions between certain clipboard formats when an application calls the GetClipboardData function. For example, if the CF_OEMTEXT format is on the clipboard, a window can retrieve data in the CF_TEXT format. The format on the clipboard is converted to the requested format on demand. For more information, see Synthesized Clipboard Formats.For an example, see Copying Information to the Clipboard.ClipboardCloseClipboardConceptualEmptyClipboardEnumClipboardFormatsReferenceSetClipboardData</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetClipboardData(uint uFormat);

        /// <summary>
        ///Retrieves from the clipboard the name of the specified registered format. The function copies the name to the specified buffer.
        /// </summary>
        /// <param name="format">Type: UINTThe type of format to be retrieved. This parameter must not specify any of the predefined clipboard formats.</param>
        /// <param name="lpszFormatName"></param>
        /// <param name="cchMaxCount">Type: intThe maximum length, in characters, of the string to be copied to the buffer. If the name exceeds this limit, it is truncated.Type: intIf the function succeeds, the return value is the length, in characters, of the string copied to the buffer.If the function fails, the return value is zero, indicating that the requested format does not exist or is predefined. To get extended error information, call GetLastError.For an example, see Example of a Clipboard Viewer.ClipboardConceptualEnumClipboardFormatsReferenceRegisterClipboardFormat</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetClipboardFormatNameA(uint format, out string lpszFormatName, int cchMaxCount);

        /// <summary>
        ///Retrieves from the clipboard the name of the specified registered format. The function copies the name to the specified buffer.
        /// </summary>
        /// <param name="format">Type: UINTThe type of format to be retrieved. This parameter must not specify any of the predefined clipboard formats.</param>
        /// <param name="lpszFormatName"></param>
        /// <param name="cchMaxCount">Type: intThe maximum length, in characters, of the string to be copied to the buffer. If the name exceeds this limit, it is truncated.Type: intIf the function succeeds, the return value is the length, in characters, of the string copied to the buffer.If the function fails, the return value is zero, indicating that the requested format does not exist or is predefined. To get extended error information, call GetLastError.For an example, see Example of a Clipboard Viewer.ClipboardConceptualEnumClipboardFormatsReferenceRegisterClipboardFormat</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetClipboardFormatNameW(uint format, out string lpszFormatName, int cchMaxCount);

        /// <summary>
        ///Retrieves the window handle of the current owner of the clipboard.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetClipboardOwner();

        /// <summary>
        ///Retrieves the clipboard sequence number for the current window station.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetClipboardSequenceNumber();

        /// <summary>
        ///Retrieves the handle to the first window in the clipboard viewer chain.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetClipboardViewer();

        /// <summary>
        ///Retrieves the screen coordinates of the rectangular area to which the cursor is confined.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetClipCursor(out RECT lpRect);

        /// <summary>
        ///Retrieves information about the specified combo box.
        /// </summary>
        /// <param name="hwndCombo">Type: HWNDA handle to the combo box.</param>
        /// <param name="pcbi"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetComboBoxInfo(nint hwndCombo, out COMBOBOXINFO pcbi);

        /// <summary>
        ///Retrieves the source of the input message.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetCurrentInputMessageSource(out INPUT_MESSAGE_SOURCE inputMessageSource);

        /// <summary>
        ///Retrieves a handle to the current cursor.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetCursor();

        /// <summary>
        ///Retrieves information about the global cursor.
        /// </summary>
        /// <param name="pci">Type: PCURSORINFOA pointer to a CURSORINFO structure that receives the information. Note that you must set the cbSize member to sizeof(CURSORINFO) before calling this function.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.CURSORINFOConceptualCursorsGetGUIThreadInfoReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetCursorInfo(out CURSORINFO pci);

        /// <summary>
        ///Retrieves the position of the mouse cursor, in screen coordinates.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetCursorPos(out POINT lpPoint);

        /// <summary>
        ///The GetDC function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen. You can use the returned handle in subsequent GDI functions to draw in the DC. The device context is an opaque data structure, whose values are used internally by GDI.
        /// </summary>
        /// <param name="hWnd">A handle to the window whose DC is to be retrieved. If this value is NULL, GetDC retrieves the DC for the entire screen.If the function succeeds, the return value is a handle to the DC for the specified window's client area.If the function fails, the return value is NULL.The GetDC function retrieves a common, class, or private DC depending on the class style of the specified window. For class and private DCs, GetDC leaves the previously assigned attributes unchanged. However, for common DCs, GetDC assigns default attributes to the DC each time it is retrieved. For example, the default font is System, which is a bitmap font. Because of this, the handle to a common DC returned by GetDC does not tell you what font, color, or brush was used when the window was drawn. To determine the font, call GetTextFace.Note that the handle to the DC can only be used by a single thread at any one time.After painting with a common DC, the ReleaseDC function must be called to release the DC. Class and private DCs do not have to be released. ReleaseDC must be called from the same thread that called GetDC. The number of DCs is limited only by available memory.For an example, see Drawing with the Mouse.Device Context FunctionsDevice Contexts OverviewGetDCExGetTextFaceGetWindowDCReleaseDCWindowFromDC</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetDC(nint hWnd);

        /// <summary>
        ///The GetDCEx function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen. You can use the returned handle in subsequent GDI functions to draw in the DC. The device context is an opaque data structure, whose values are used internally by GDI.
        /// </summary>
        /// <param name="hWnd">A handle to the window whose DC is to be retrieved. If this value is NULL, GetDCEx retrieves the DC for the entire screen.</param>
        /// <param name="hrgnClip">A clipping region that may be combined with the visible region of the DC. If the value of flags is DCX_INTERSECTRGN or DCX_EXCLUDERGN, then the operating system assumes ownership of the region and will automatically delete it when it is no longer needed. In this case, the application should not use or delete the region after a successful call to GetDCEx.</param>
        /// <param name="flags">Specifies how the DC is created. This parameter can be one or more of the following values.If the function succeeds, the return value is the handle to the DC for the specified window.If the function fails, the return value is NULL. An invalid value for the hWnd parameter will cause the function to fail.Unless the display DC belongs to a window class, the ReleaseDC function must be called to release the DC after painting. Also, ReleaseDC must be called from the same thread that called GetDCEx. The number of DCs is limited only by available memory.The function returns a handle to a DC that belongs to the window's class if CS_CLASSDC, CS_OWNDC or CS_PARENTDC was specified as a style in the WNDCLASS structure when the class was registered.BeginPaintDevice Context FunctionsDevice Contexts OverviewGetWindowDCReleaseDCWNDCLASS</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetDCEx(nint hWnd, nint hrgnClip, uint flags);

        /// <summary>
        ///Retrieves a handle to the desktop window. The desktop window covers the entire screen. The desktop window is the area on top of which other windows are painted.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetDesktopWindow();

        /// <summary>
        ///Retrieves the system's dialog base units, which are the average width and height of characters in the system font. For dialog boxes that use the system font, you can use these values to convert between dialog template units, as specified in dialog box templates, and pixels. For dialog boxes that do not use the system font, the conversion from dialog template units to pixels depends on the font used by the dialog box.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetDialogBaseUnits();

        /// <summary>
        ///Retrieves and per-monitor DPI scaling behavior overrides of a child window in a dialog.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(nint hWnd);

        /// <summary>
        ///Returns the flags that might have been set on a given dialog by an earlier call to SetDialogDpiChangeBehavior.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(nint hDlg);

        /// <summary>
        ///Retrieves the screen auto-rotation preferences for the current process.
        /// </summary>

        [DllImport("Kernel.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetDisplayAutoRotationPreferences(out ORIENTATION_PREFERENCE pOrientation);

        /// <summary>
        ///Retrieves the screen auto-rotation preferences for the process indicated by the dwProcessId parameter.
        /// </summary>
        /// <param name="dwProcessId">The process to get preference settings for.</param>
        /// <param name="pOrientation"></param>
        /// <param name="fRotateScreen"></param>

        [DllImport("Kernel.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetDisplayAutoRotationPreferencesByProcessId(uint dwProcessId, out ORIENTATION_PREFERENCE pOrientation, out bool fRotateScreen);

        /// <summary>
        ///The GetDisplayConfigBufferSizes function retrieves the size of the buffers that are required to call the QueryDisplayConfig function.
        /// </summary>
        /// <param name="flags">The type of information to retrieve. The value for the Flags parameter must be one of the following values.The caller requests the table sizes to hold all the possible path combinations.The caller requests the table sizes to hold only active paths.The caller requests the table sizes to hold the active paths as defined in the persistence database for the currently connected monitors.</param>
        /// <param name="numPathArrayElements"></param>
        /// <param name="numModeInfoArrayElements"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetDisplayConfigBufferSizes(int flags, out int numPathArrayElements, out int numModeInfoArrayElements);

        /// <summary>
        ///Retrieves the identifier of the specified control.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the control.Type: intIf the function succeeds, the return value is the identifier of the control.If the function fails, the return value is zero. An invalid value for the hwndCtl parameter, for example, will cause the function to fail. To get extended error information, call GetLastError.GetDlgCtrlID accepts child window handles as well as handles of controls in dialog boxes. An application sets the identifier for a child window when it creates the window by assigning the identifier value to the hmenu parameter when calling the CreateWindow or CreateWindowEx function.Although GetDlgCtrlID may return a value if hwndCtl is a handle to a top-level window, top-level windows cannot have identifiers and such a return value is never valid.For an example, see Initializing a Dialog Box.ConceptualCreateWindowCreateWindowExDialog BoxesGetDlgItemReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetDlgCtrlID(nint hWnd);

        /// <summary>
        ///Retrieves a handle to a control in the specified dialog box.
        /// </summary>
        /// <param name="hDlg"></param>
        /// <param name="nIDDlgItem">Type: intThe identifier of the control to be retrieved.Type: HWNDIf the function succeeds, the return value is the window handle of the specified control.If the function fails, the return value is NULL, indicating an invalid dialog box handle or a nonexistent control. To get extended error information, call GetLastError.You can use the GetDlgItem function with any parent-child window pair, not just with dialog boxes. As long as the hDlg parameter specifies a parent window and the child window has a unique identifier (as specified by the hMenu parameter in the CreateWindow or CreateWindowEx function that created the child window), GetDlgItem returns a valid handle to the child window.For an example, see Initializing a Dialog Box.ConceptualCreateWindowCreateWindowExDialog BoxesGetDlgItemIntGetDlgItemTextReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetDlgItem(nint hDlg, int nIDDlgItem);

        /// <summary>
        ///Translates the text of a specified control in a dialog box into an integer value.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the control of interest.</param>
        /// <param name="nIDDlgItem">Type: intThe identifier of the control whose text is to be translated.</param>
        /// <param name="lpTranslated"></param>
        /// <param name="bSigned">Type: BOOLIndicates whether the function should examine the text for a minus sign at the beginning and return a signed integer value if it finds one (TRUE specifies this should be done, FALSE that it should not).Type: UINTIf the function succeeds, the variable pointed to by lpTranslated is set to TRUE, and the return value is the translated value of the control text.If the function fails, the variable pointed to by lpTranslated is set to FALSE, and the return value is zero. Note that, because zero is a possible translated value, a return value of zero does not by itself indicate failure.If lpTranslated is NULL, the function returns no information about success or failure.Note that, if the bSigned parameter is TRUE and there is a minus sign (–) at the beginning of the text, GetDlgItemInt translates the text into a signed integer value. Otherwise, the function creates an unsigned integer value. To obtain the proper value in this case, cast the return value to an int type.To get extended error information, call GetLastError.The GetDlgItemInt function retrieves the text of the specified control by sending the control a WM_GETTEXT message. The function translates the retrieved text by stripping any extra spaces at the beginning of the text and then converting the decimal digits. The function stops translating when it reaches the end of the text or encounters a nonnumeric character.The GetDlgItemInt function returns zero if the translated value is greater than INT_MAX (for signed numbers) or UINT_MAX (for unsigned numbers).For an example, see Creating a Modeless Dialog Box.ConceptualDialog BoxesGetDlgCtrlIDGetDlgItemGetDlgItemTextReferenceSetDlgItemInt</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetDlgItemInt(nint hDlg, int nIDDlgItem, out bool lpTranslated, bool bSigned);

        /// <summary>
        ///Retrieves the title or text associated with a control in a dialog box.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the control.</param>
        /// <param name="nIDDlgItem">Type: intThe identifier of the control whose title or text is to be retrieved.</param>
        /// <param name="lpString"></param>
        /// <param name="cchMax">Type: intThe maximum length, in characters, of the string to be copied to the buffer pointed to by lpString. If the length of the string, including the null character, exceeds the limit, the string is truncated.Type: UINTIf the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null character.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the string is as long or longer than the buffer, the buffer will contain the truncated string with a terminating null character.The GetDlgItemText function sends a WM_GETTEXT message to the control.For an example, see Creating a Modal Dialog Box.ConceptualDialog BoxesGetDlgItemIntReferenceSetDlgItemIntSetDlgItemTextWM_GETTEXT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetDlgItemTextA(nint hDlg, int nIDDlgItem, out string lpString, int cchMax);

        /// <summary>
        ///Retrieves the title or text associated with a control in a dialog box.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the control.</param>
        /// <param name="nIDDlgItem">Type: intThe identifier of the control whose title or text is to be retrieved.</param>
        /// <param name="lpString"></param>
        /// <param name="cchMax">Type: intThe maximum length, in characters, of the string to be copied to the buffer pointed to by lpString. If the length of the string, including the null character, exceeds the limit, the string is truncated.Type: UINTIf the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null character.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the string is as long or longer than the buffer, the buffer will contain the truncated string with a terminating null character.The GetDlgItemText function sends a WM_GETTEXT message to the control.For an example, see Creating a Modal Dialog Box.ConceptualDialog BoxesGetDlgItemIntReferenceSetDlgItemIntSetDlgItemTextWM_GETTEXT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetDlgItemTextW(nint hDlg, int nIDDlgItem, out string lpString, int cchMax);

        /// <summary>
        ///Retrieves the current double-click time for the mouse. A double-click is a series of two clicks of the mouse button, the second occurring within a specified time after the first. The double-click time is the maximum number of milliseconds that may occur between the first and second click of a double-click. The maximum double-click time is 5000 milliseconds.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetDoubleClickTime();

        /// <summary>
        ///Gets a DPI_AWARENESS_CONTEXT handle for the specified process.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern DPI_AWARENESS GetDpiAwarenessContextForProcess(nint hProcess);

        /// <summary>
        ///Returns the system DPI.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetDpiForSystem();

        /// <summary>
        ///Returns the dots per inch (dpi) value for the specified window.
        /// </summary>
        /// <param name="hwnd">The window that you want to get information about.The DPI for the window, which depends on the DPI_AWARENESS of the window. See the Remarks section for more information. An invalid hwnd value will result in a return value of 0.The following table indicates the return value of GetDpiForWindow based on the DPI_AWARENESS of the provided hwnd.See Create a simple Direct2D application.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetDpiForWindow(nint hwnd);

        /// <summary>
        ///Retrieves the DPI from a given DPI_AWARENESS_CONTEXT handle. This enables you to determine the DPI of a thread without needed to examine a window created within that thread.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetDpiFromDpiAwarenessContext(DPI_AWARENESS value);

        /// <summary>
        ///Retrieves the handle to the window that has the keyboard focus, if the window is attached to the calling thread's message queue.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetFocus();

        /// <summary>
        ///Retrieves a handle to the foreground window (the window with which the user is currently working). The system assigns a slightly higher priority to the thread that creates the foreground window than it does to other threads.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetForegroundWindow();

        /// <summary>
        ///Retrieves the configuration for which Windows Touch gesture messages are sent from a window.
        /// </summary>
        /// <param name="hwnd">A handle to the window to get the gesture configuration from.</param>
        /// <param name="dwReserved">This value is reserved and must be set to 0.</param>
        /// <param name="dwFlags">A gesture command flag value indicating options for retrieving the gesture configuration. See Remarks for additional information and supported values.</param>
        /// <param name="pcIDs">The size, in number of gesture configuration structures, that is in the pGestureConfig buffer.</param>
        /// <param name="pGestureConfig">An array of gesture configuration structures that specify the gesture configuration.</param>
        /// <param name="cbSize">The size of the gesture configuration (GESTURECONFIG) structure.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.Passing a value other than sizeof(GESTURECONFIG) for the cbSize parameter will cause calls to this function to fail and GetLastError will return ERROR_INVALID_PARAMETER (87 in decimal).The following table lists the gesture configuration values:FunctionsGESTURECONFIGProgramming Guide for Gestures</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetGestureConfig(nint hwnd, uint dwReserved, uint dwFlags, uint pcIDs, out GESTURECONFIG pGestureConfig, uint cbSize);

        /// <summary>
        ///Retrieves additional information about a gesture from its GESTUREINFO handle.
        /// </summary>
        /// <param name="hGestureInfo">The handle to the gesture information that is passed in the lParam of a WM_GESTURE message.</param>
        /// <param name="cbExtraArgs">A count of the bytes of data stored in the extra arguments.</param>
        /// <param name="pExtraArgs"></param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetGestureExtraArgs(GESTUREINFO hGestureInfo, uint cbExtraArgs, out byte pExtraArgs);

        /// <summary>
        ///Retrieves a GESTUREINFO structure given a handle to the gesture information.
        /// </summary>
        /// <param name="hGestureInfo">The gesture information handle.</param>
        /// <param name="pGestureInfo"></param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetGestureInfo(GESTUREINFO hGestureInfo, out GESTUREINFO pGestureInfo);

        /// <summary>
        ///Retrieves the count of handles to graphical user interface (GUI) objects in use by the specified process.
        /// </summary>
        /// <param name="hProcess">A handle to the process. The handle must refer to a process in the current session, and must have the PROCESS_QUERY_LIMITED_INFORMATION access right (see Process security and access rights).If this parameter is the special value GR_GLOBAL, then the resource usage is reported across all processes in the current session.Windows Server 2008, Windows Vista, Windows Server 2003, and Windows XP: The GR_GLOBAL value is not supported until Windows 7 and Windows Server 2008 R2.Windows Server 2003 and Windows XP: The handle must have the PROCESS_QUERY_INFORMATION access right.</param>
        /// <param name="uiFlags">The GUI object type. This parameter can be one of the following values.If the function succeeds, the return value is the count of handles to GUI objects in use by the process. If no GUI objects are in use, the return value is zero.If the function fails, the return value is zero. To get extended error information, call GetLastError.A process without a graphical user interface does not use GUI resources, therefore, GetGuiResources will return zero.CreateProcessGetCurrentProcessOpenProcessProcess and Thread Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetGuiResources(nint hProcess, uint uiFlags);

        /// <summary>
        ///Retrieves information about the active window or a specified GUI thread.
        /// </summary>
        /// <param name="idThread">Type: DWORDThe identifier for the thread for which information is to be retrieved. To retrieve this value, use the GetWindowThreadProcessId function. If this parameter is NULL, the function returns information for the foreground thread.</param>
        /// <param name="pgui">Type: LPGUITHREADINFOA pointer to a GUITHREADINFO structure that receives information describing the thread. Note that you must set the cbSize member to sizeof(GUITHREADINFO) before calling this function.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.This function succeeds even if the active window is not owned by the calling process. If the specified thread does not exist or have an input queue, the function will fail.This function is useful for retrieving out-of-context information about a thread. The information retrieved is the same as if an application retrieved the information about itself.For an edit control, the returned rcCaret rectangle contains the caret plus information on text direction and padding. Thus, it may not give the correct position of the cursor. The Sans Serif font uses four characters for the cursor:To get the actual insertion point in the rcCaret rectangle, perform the following steps.The function may not return valid window handles in the GUITHREADINFO structure when called to retrieve information for the foreground thread, such as when a window is losing activation.ConceptualGUITHREADINFOGetCursorInfoGetWindowThreadProcessIdReferenceWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetGUIThreadInfo(uint idThread, out GUITHREADINFO pgui);

        /// <summary>
        ///Retrieves information about the specified icon or cursor.
        /// </summary>
        /// <param name="hIcon">Type: HICONA handle to the icon or cursor.To retrieve information about a standard icon or cursor, specify the identifier beginning with the IDI_ prefix or the identifier beginning with the IDC_ prefix in this parameter.</param>
        /// <param name="piconinfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetIconInfo(nint hIcon, out ICONINFO piconinfo);

        /// <summary>
        ///Retrieves information about the specified icon or cursor. GetIconInfoEx extends GetIconInfo by using the newer ICONINFOEX structure.
        /// </summary>
        /// <param name="hicon">Type: HICONA handle to the icon or cursor.To retrieve information about a standard icon or cursor, specify the identifier beginning with the IDI_ prefix or the identifier beginning with the IDC_ prefix in this parameter.</param>
        /// <param name="piconinfo">Type: PICONINFOEXWhen this method returns, contains a pointer to an ICONINFOEX structure. The function fills in the structure's members.Type: BOOLTRUE indicates success, FALSE indicates failure.GetIconInfoEx creates bitmaps for the hbmMask and hbmColor or members of ICONINFOEX. The calling application must manage these bitmaps and delete them with DeleteObject call when they are no longer necessary.ConceptualBitmapsIconsDeleteObjectGetObjectBITMAPCreateIconCreateIconFromResourceCreateIconIndirectDestroyIconDrawIconDrawIconExLoadIconLookupIconIdFromDirectoryICONINFO</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetIconInfoExA(nint hicon, out ICONINFOEXA piconinfo);

        /// <summary>
        ///Retrieves information about the specified icon or cursor. GetIconInfoEx extends GetIconInfo by using the newer ICONINFOEX structure.
        /// </summary>
        /// <param name="hicon">Type: HICONA handle to the icon or cursor.To retrieve information about a standard icon or cursor, specify the identifier beginning with the IDI_ prefix or the identifier beginning with the IDC_ prefix in this parameter.</param>
        /// <param name="piconinfo">Type: PICONINFOEXWhen this method returns, contains a pointer to an ICONINFOEX structure. The function fills in the structure's members.Type: BOOLTRUE indicates success, FALSE indicates failure.GetIconInfoEx creates bitmaps for the hbmMask and hbmColor or members of ICONINFOEX. The calling application must manage these bitmaps and delete them with DeleteObject call when they are no longer necessary.ConceptualBitmapsIconsDeleteObjectGetObjectBITMAPCreateIconCreateIconFromResourceCreateIconIndirectDestroyIconDrawIconDrawIconExLoadIconLookupIconIdFromDirectoryICONINFO</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetIconInfoExW(nint hicon, out ICONINFOEXW piconinfo);

        /// <summary>
        ///Determines whether there are mouse-button or keyboard messages in the calling thread's message queue.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetInputState();

        /// <summary>
        ///Retrieves the current code page.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetKBCodePage();

        /// <summary>
        ///Retrieves the active input locale identifier (formerly called the keyboard layout).
        /// </summary>
        /// <param name="idThread">Type: DWORDThe identifier of the thread to query, or 0 for the current thread.Type: HKLThe return value is the input locale identifier for the thread. The low word contains a Language Identifier for the input language and the high word contains a device handle to the physical layout of the keyboard.The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input.Since the keyboard layout can be dynamically changed, applications that cache information about the current keyboard layout should process the WM_INPUTLANGCHANGE message to be informed of changes in the input language.To get the KLID (keyboard layout ID) of the currently active HKL, call the GetKeyboardLayoutName.Beginning in Windows 8: The preferred method to retrieve the language associated with the current keyboard layout or input method is a call to Windows.Globalization.Language.CurrentInputMethodLanguageTag. If your app passes language tags from CurrentInputMethodLanguageTag to any National Language Support functions, it must first convert the tags by calling ResolveLocaleName.ActivateKeyboardLayoutConceptualCreateThreadKeyboard InputLoadKeyboardLayoutOther ResourcesReferenceWM_INPUTLANGCHANGE</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetKeyboardLayout(uint idThread);

        /// <summary>
        ///Retrieves the input locale identifiers (formerly called keyboard layout handles) corresponding to the current set of input locales in the system. The function copies the identifiers to the specified buffer.
        /// </summary>
        /// <param name="nBuff">Type: intThe maximum number of handles that the buffer can hold.</param>
        /// <param name="lpList"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetKeyboardLayoutList(int nBuff, out nint lpList);

        /// <summary>
        ///Retrieves the name of the active input locale identifier (formerly called the keyboard layout) for the calling thread.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetKeyboardLayoutNameA(out string pwszKLID);

        /// <summary>
        ///Retrieves the name of the active input locale identifier (formerly called the keyboard layout) for the calling thread.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetKeyboardLayoutNameW(out string pwszKLID);

        /// <summary>
        ///Copies the status of the 256 virtual keys to the specified buffer.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetKeyboardState(out byte lpKeyState);

        /// <summary>
        ///Retrieves information about the current keyboard.
        /// </summary>
        /// <param name="nTypeFlag">Type: intThe type of keyboard information to be retrieved. This parameter can be one of the following values.Type: intIf the function succeeds, the return value specifies the requested information.If the function fails and nTypeFlag is not 1, the return value is 0; 0 is a valid return value when nTypeFlag is 1 (keyboard subtype). To get extended error information, call GetLastError.Valid keyboard types are:Keyboard subtypes are original equipment manufacturer (OEM)-dependent values.Keyboard Input Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetKeyboardType(int nTypeFlag);

        /// <summary>
        ///Retrieves a string that represents the name of a key.
        /// </summary>
        /// <param name="lParam">Type: LONGThe second parameter of the keyboard message (such as WM_KEYDOWN) to be processed. The function interprets the following bit positions in the lParam.For more detail, see Keystroke Message Flags.</param>
        /// <param name="lpString"></param>
        /// <param name="cchSize">Type: intThe maximum length, in characters, of the key name, including the terminating null character. (This parameter should be equal to the size of the buffer pointed to by the lpString parameter.)Type: intIf the function succeeds, a null-terminated string is copied into the specified buffer, and the return value is the length of the string, in characters, not counting the terminating null character.If the function fails, the return value is zero. To get extended error information, call GetLastError.The format of the key-name string depends on the current keyboard layout.The keyboard layout maintains a list of names in the form of character strings for keys with names longer than a single character. The key name is translated according to the currently active keyboard layout, therefore the function might return different results for different keyboard layouts.The name of a character key is the character itself. The names of dead keys are spelled out in full.This method might not work properly with some keyboard layouts that produce multiple characters (i.e. ligatures) and/or supplementary Unicode characters that are printed on a single key press. Also, keys that are mapped to the 'A'..'Z' virtual-key codes are translated to upper-case 'A'..'Z' characters regardless of current keyboard layout. Use the ToUnicode or ToUnicodeEx methods in such cases.The winuser.h header defines GetKeyNameText as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for Function Prototypes.Keyboard InputKeyboard LayoutsKeyboard Layout SamplesToUnicodeToUnicodeEx</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetKeyNameTextA(int lParam, out string lpString, int cchSize);

        /// <summary>
        ///Retrieves a string that represents the name of a key.
        /// </summary>
        /// <param name="lParam">Type: LONGThe second parameter of the keyboard message (such as WM_KEYDOWN) to be processed. The function interprets the following bit positions in the lParam.For more detail, see Keystroke Message Flags.</param>
        /// <param name="lpString"></param>
        /// <param name="cchSize">Type: intThe maximum length, in characters, of the key name, including the terminating null character. (This parameter should be equal to the size of the buffer pointed to by the lpString parameter.)Type: intIf the function succeeds, a null-terminated string is copied into the specified buffer, and the return value is the length of the string, in characters, not counting the terminating null character.If the function fails, the return value is zero. To get extended error information, call GetLastError.The format of the key-name string depends on the current keyboard layout.The keyboard layout maintains a list of names in the form of character strings for keys with names longer than a single character. The key name is translated according to the currently active keyboard layout, therefore the function might return different results for different keyboard layouts.The name of a character key is the character itself. The names of dead keys are spelled out in full.This method might not work properly with some keyboard layouts that produce multiple characters (i.e. ligatures) and/or supplementary Unicode characters that are printed on a single key press. Also, keys that are mapped to the 'A'..'Z' virtual-key codes are translated to upper-case 'A'..'Z' characters regardless of current keyboard layout. Use the ToUnicode or ToUnicodeEx methods in such cases.The winuser.h header defines GetKeyNameText as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for Function Prototypes.Keyboard InputKeyboard LayoutsKeyboard Layout SamplesToUnicodeToUnicodeEx</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetKeyNameTextW(int lParam, out string lpString, int cchSize);

        /// <summary>
        ///Retrieves the status of the specified virtual key. The status specifies whether the key is up, down, or toggled (on, off—alternating each time the key is pressed).
        /// </summary>
        /// <param name="nVirtKey">Type: intA virtual key. If the desired virtual key is a letter or digit (A through Z, a through z, or 0 through 9), nVirtKey must be set to the ASCII value of that character. For other keys, it must be a virtual-key code.If a non-English keyboard layout is used, virtual keys with values in the range ASCII A through Z and 0 through 9 are used to specify most of the character keys. For example, for the German keyboard layout, the virtual key of value ASCII O (0x4F) refers to the "o" key, whereas VK_OEM_1 refers to the "o with umlaut" key.Type: SHORTThe return value specifies the status of the specified virtual key, as follows:The key status returned from this function changes as a thread reads key messages from its message queue. The status does not reflect the interrupt-level state associated with the hardware. Use the GetAsyncKeyState function to retrieve that information.An application calls GetKeyState in response to a keyboard-input message. This function retrieves the state of the key when the input message was generated.To retrieve state information for all the virtual keys, use the GetKeyboardState function.An application can use the virtual key code constants VK_SHIFT, VK_CONTROL, and VK_MENU as values for the nVirtKey parameter. This gives the status of the SHIFT, CTRL, or ALT keys without distinguishing between left and right. An application can also use the following virtual-key code constants as values for nVirtKey to distinguish between the left and right instances of those keys:VK_LSHIFT VK_RSHIFT VK_LCONTROL VK_RCONTROL VK_LMENU VK_RMENU These left- and right-distinguishing constants are available to an application only through the GetKeyboardState, SetKeyboardState, GetAsyncKeyState, GetKeyState, and MapVirtualKey functions.For an example, see Displaying Keyboard Input.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short GetKeyState(int nVirtKey);

        /// <summary>
        ///Determines which pop-up window owned by the specified window was most recently active.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the owner window.Type: HWNDThe return value identifies the most recently active pop-up window. The return value is the same as the hWnd parameter, if any of the following conditions are met:AnyPopupConceptualReferenceShowOwnedPopupsWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetLastActivePopup(nint hWnd);

        /// <summary>
        ///Retrieves the time of the last input event.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetLastInputInfo(out LASTINPUTINFO plii);

        /// <summary>
        ///Retrieves the opacity and transparency color key of a layered window.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the layered window. A layered window is created by specifying WS_EX_LAYERED when creating the window with the CreateWindowEx function or by setting WS_EX_LAYERED using SetWindowLong after the window has been created.</param>
        /// <param name="pcrKey"></param>
        /// <param name="pbAlpha"></param>
        /// <param name="pdwFlags"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetLayeredWindowAttributes(nint hwnd, out COORD pcrKey, out byte pbAlpha, out uint pdwFlags);

        /// <summary>
        ///Retrieves the number of items per column in a specified list box.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the list box whose number of items per column is to be retrieved.Type: DWORDThe return value is the number of items per column.GetComboBoxInfo</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetListBoxInfo(nint hwnd);

        /// <summary>
        ///Retrieves a handle to the menu assigned to the specified window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose menu handle is to be retrieved.Type: HMENUThe return value is a handle to the menu. If the specified window has no menu, the return value is NULL. If the window is a child window, the return value is undefined.GetMenu does not work on floating menu bars. Floating menu bars are custom controls that mimic standard menus; they are not menus. To get the handle on a floating menu bar, use the Active Accessibility APIs.For an example, see Adding Lines and Graphs to a Menu.ConceptualGetSubMenuMenusReferenceSetMenu</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetMenu(nint hWnd);

        /// <summary>
        ///Retrieves information about the specified menu bar.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window (menu bar) whose information is to be retrieved.</param>
        /// <param name="idObject">Type: LONGThe menu object. This parameter can be one of the following values.</param>
        /// <param name="idItem">Type: LONGThe item for which to retrieve information. If this parameter is zero, the function retrieves information about the menu itself. If this parameter is 1, the function retrieves information about the first item on the menu, and so on.</param>
        /// <param name="pmbi">Type: PMENUBARINFOA pointer to a MENUBARINFO structure that receives the information. Note that you must set the cbSize member to sizeof(MENUBARINFO) before calling this function.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.ConceptualGetMenuGetSystemMenuMENUBARINFOMenusReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetMenuBarInfo(nint hwnd, int idObject, int idItem, out MENUBARINFO pmbi);

        /// <summary>
        ///Retrieves the dimensions of the default check-mark bitmap. The system displays this bitmap next to selected menu items. Before calling the SetMenuItemBitmaps function to replace the default check-mark bitmap for a menu item, an application must determine the correct bitmap size by calling GetMenuCheckMarkDimensions.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetMenuCheckMarkDimensions();

        /// <summary>
        ///Retrieves the Help context identifier associated with the specified menu.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetMenuContextHelpId(nint unnamedParam1);

        /// <summary>
        ///Determines the default menu item on the specified menu.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu for which to retrieve the default menu item.</param>
        /// <param name="fByPos">Type: UINTIndicates whether to retrieve the menu item's identifier or its position. If this parameter is FALSE, the identifier is returned. Otherwise, the position is returned.</param>
        /// <param name="gmdiFlags">Type: UINTIndicates how the function should search for menu items. This parameter can be zero or more of the following values.Type: UINTIf the function succeeds, the return value is the identifier or position of the menu item.If the function fails, the return value is -1. To get extended error information, call GetLastError.ConceptualMenusReferenceSetMenuDefaultItem</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetMenuDefaultItem(nint hMenu, uint fByPos, uint gmdiFlags);

        /// <summary>
        ///Retrieves information about a specified menu.
        /// </summary>
        /// <param name="unnamedParam1">Type: HMENUA handle on a menu.</param>
        /// <param name="unnamedParam2">Type: LPMENUINFOA pointer to a MENUINFO structure containing information for the menu. Note that you must set the cbSize member to sizeof(MENUINFO) before calling this function.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Menus</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetMenuInfo(nint unnamedParam1, out MENUINFO unnamedParam2);

        /// <summary>
        ///Determines the number of items in the specified menu.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetMenuItemCount(nint hMenu);

        /// <summary>
        ///Retrieves the menu item identifier of a menu item located at the specified position in a menu.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu that contains the item whose identifier is to be retrieved.</param>
        /// <param name="nPos">Type: intThe zero-based relative position of the menu item whose identifier is to be retrieved.Type: UINTThe return value is the identifier of the specified menu item. If the menu item identifier is NULL or if the specified item opens a submenu, the return value is -1.ConceptualGetMenuItemCountMenusReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetMenuItemID(nint hMenu, int nPos);

        /// <summary>
        ///Retrieves information about a menu item.
        /// </summary>
        /// <param name="hmenu">Type: HMENUA handle to the menu that contains the menu item.</param>
        /// <param name="item">Type: UINTThe identifier or position of the menu item to get information about. The meaning of this parameter depends on the value of fByPosition.</param>
        /// <param name="fByPosition">Type: BOOLThe meaning of uItem. If this parameter is FALSE, uItem is a menu item identifier. Otherwise, it is a menu item position. See Accessing Menu Items Programmatically for more information.</param>
        /// <param name="lpmii">Type: LPMENUITEMINFOA pointer to a MENUITEMINFO structure that specifies the information to retrieve and receives information about the menu item. Note that you must set the cbSize member to sizeof(MENUITEMINFO) before calling this function.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.To retrieve a menu item of type MFT_STRING, first find the size of the string by setting the dwTypeData member of MENUITEMINFO to NULL and then calling GetMenuItemInfo. The value of cch+1 is the size needed. Then allocate a buffer of this size, place the pointer to the buffer in dwTypeData, increment cch by one, and then call GetMenuItemInfo once again to fill the buffer with the string.If the retrieved menu item is of some other type, then GetMenuItemInfo sets the dwTypeData member to a value whose type is specified by the fTypefType member and sets cch to 0.For an example, see Example of Owner-Drawn Menu Items.ConceptualMenusReferenceSetMenuItemInfo</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetMenuItemInfoA(nint hmenu, uint item, bool fByPosition, out MENUITEMINFOA lpmii);

        /// <summary>
        ///Retrieves information about a menu item.
        /// </summary>
        /// <param name="hmenu">Type: HMENUA handle to the menu that contains the menu item.</param>
        /// <param name="item">Type: UINTThe identifier or position of the menu item to get information about. The meaning of this parameter depends on the value of fByPosition.</param>
        /// <param name="fByPosition">Type: BOOLThe meaning of uItem. If this parameter is FALSE, uItem is a menu item identifier. Otherwise, it is a menu item position. See Accessing Menu Items Programmatically for more information.</param>
        /// <param name="lpmii">Type: LPMENUITEMINFOA pointer to a MENUITEMINFO structure that specifies the information to retrieve and receives information about the menu item. Note that you must set the cbSize member to sizeof(MENUITEMINFO) before calling this function.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.To retrieve a menu item of type MFT_STRING, first find the size of the string by setting the dwTypeData member of MENUITEMINFO to NULL and then calling GetMenuItemInfo. The value of cch+1 is the size needed. Then allocate a buffer of this size, place the pointer to the buffer in dwTypeData, increment cch by one, and then call GetMenuItemInfo once again to fill the buffer with the string.If the retrieved menu item is of some other type, then GetMenuItemInfo sets the dwTypeData member to a value whose type is specified by the fTypefType member and sets cch to 0.For an example, see Example of Owner-Drawn Menu Items.ConceptualMenusReferenceSetMenuItemInfo</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetMenuItemInfoW(nint hmenu, uint item, bool fByPosition, out MENUITEMINFOW lpmii);

        /// <summary>
        ///Retrieves the bounding rectangle for the specified menu item.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="hMenu">Type: HMENUA handle to a menu.</param>
        /// <param name="uItem">Type: UINTThe zero-based position of the menu item.</param>
        /// <param name="lprcItem"></param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetMenuItemRect(nint hWnd, nint hMenu, uint uItem, out RECT lprcItem);

        /// <summary>
        ///Retrieves the menu flags associated with the specified menu item. If the menu item opens a submenu, this function also returns the number of items in the submenu.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu that contains the menu item whose flags are to be retrieved.</param>
        /// <param name="uId">Type: UINTThe menu item for which the menu flags are to be retrieved, as determined by the uFlags parameter.</param>
        /// <param name="uFlags">Type: UINTIndicates how the uId parameter is interpreted. This parameter can be one of the following values.Type: UINTIf the specified item does not exist, the return value is -1.If the menu item opens a submenu, the low-order byte of the return value contains the menu flags associated with the item, and the high-order byte contains the number of items in the submenu opened by the item.Otherwise, the return value is a mask (Bitwise OR) of the menu flags. Following are the menu flags associated with the menu item.It is possible to test an item for a flag value of MF_ENABLED, MF_STRING, MF_UNCHECKED, or MF_UNHILITE. However, since these values equate to zero you must use an expression to test for them.For an example, see Simulating Check Boxes in a Menu.ConceptualGetMenuGetMenuItemCountGetMenuItemIDGetMenuItemInfoMenusReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetMenuState(nint hMenu, uint uId, uint uFlags);

        /// <summary>
        ///Copies the text string of the specified menu item into the specified buffer.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu.</param>
        /// <param name="uIDItem">Type: UINTThe menu item to be changed, as determined by the uFlag parameter.</param>
        /// <param name="lpString"></param>
        /// <param name="cchMax">Type: intThe maximum length, in characters, of the string to be copied. If the string is longer than the maximum specified in the nMaxCount parameter, the extra characters are truncated. If nMaxCount is 0, the function returns the length of the menu string.</param>
        /// <param name="flags">Type: UINTIndicates how the uIDItem parameter is interpreted. This parameter must be one of the following values.Type: intIf the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null character.If the function fails, the return value is zero.If the specified item is not of type MIIM_STRING or MFT_STRING, then the return value is zero.The nMaxCount parameter must be one larger than the number of characters in the text string to accommodate the terminating null character.If nMaxCount is 0, the function returns the length of the menu string.For an example, see Creating User Editable Accelerators.ConceptualGetMenuItemIDMenusReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetMenuStringA(nint hMenu, uint uIDItem, out string lpString, int cchMax, uint flags);

        /// <summary>
        ///Copies the text string of the specified menu item into the specified buffer.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu.</param>
        /// <param name="uIDItem">Type: UINTThe menu item to be changed, as determined by the uFlag parameter.</param>
        /// <param name="lpString"></param>
        /// <param name="cchMax">Type: intThe maximum length, in characters, of the string to be copied. If the string is longer than the maximum specified in the nMaxCount parameter, the extra characters are truncated. If nMaxCount is 0, the function returns the length of the menu string.</param>
        /// <param name="flags">Type: UINTIndicates how the uIDItem parameter is interpreted. This parameter must be one of the following values.Type: intIf the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null character.If the function fails, the return value is zero.If the specified item is not of type MIIM_STRING or MFT_STRING, then the return value is zero.The nMaxCount parameter must be one larger than the number of characters in the text string to accommodate the terminating null character.If nMaxCount is 0, the function returns the length of the menu string.For an example, see Creating User Editable Accelerators.ConceptualGetMenuItemIDMenusReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetMenuStringW(nint hMenu, uint uIDItem, out string lpString, int cchMax, uint flags);

        /// <summary>
        ///Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is available for retrieval.
        /// </summary>
        /// <param name="lpMsg"></param>
        /// <param name="hWnd"></param>
        /// <param name="wMsgFilterMin">Type: UINTThe integer value of the lowest message value to be retrieved. Use WM_KEYFIRST (0x0100) to specify the first keyboard message or WM_MOUSEFIRST (0x0200) to specify the first mouse message.Use WM_INPUT here and in wMsgFilterMax to specify only the WM_INPUT messages.If wMsgFilterMin and wMsgFilterMax are both zero, GetMessage returns all available messages (that is, no range filtering is performed).</param>
        /// <param name="wMsgFilterMax">Type: UINTThe integer value of the highest message value to be retrieved. Use WM_KEYLAST to specify the last keyboard message or WM_MOUSELAST to specify the last mouse message.Use WM_INPUT here and in wMsgFilterMin to specify only the WM_INPUT messages.If wMsgFilterMin and wMsgFilterMax are both zero, GetMessage returns all available messages (that is, no range filtering is performed).Type: BOOLIf the function retrieves a message other than WM_QUIT, the return value is nonzero.If the function retrieves the WM_QUIT message, the return value is zero.If there is an error, the return value is -1. For example, the function fails if hWnd is an invalid window handle or lpMsg is an invalid pointer. To get extended error information, call GetLastError.Because the return value can be nonzero, zero, or -1, avoid code like this:The possibility of a -1 return value in the case that hWnd is an invalid parameter (such as referring to a window that has already been destroyed) means that such code can lead to fatal application errors. Instead, use code like this:An application typically uses the return value to determine whether to end the main message loop and exit the program.The GetMessage function retrieves messages associated with the window identified by the hWnd parameter or any of its children, as specified by the IsChild function, and within the range of message values given by the wMsgFilterMin and wMsgFilterMax parameters. Note that an application can only use the low word in the wMsgFilterMin and wMsgFilterMax parameters; the high word is reserved for the system.Note that GetMessage always retrieves WM_QUIT messages, no matter which values you specify for wMsgFilterMin and wMsgFilterMax.During this call, the system delivers pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the SendMessage, SendMessageCallback, SendMessageTimeout, or SendNotifyMessage function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order:GetMessage does not remove WM_PAINT messages from the queue. The messages remain in the queue until processed.If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When in the debugger mode, the system does not generate a ghost window.For an example, see Creating a Message Loop.ConceptualIsChildMSGMessages and Message QueuesPeekMessagePostMessagePostThreadMessageReferenceWaitMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetMessage(out MSG lpMsg, nint hWnd, uint wMsgFilterMin, uint wMsgFilterMax);

        /// <summary>
        ///Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is available for retrieval.
        /// </summary>
        /// <param name="lpMsg"></param>
        /// <param name="hWnd"></param>
        /// <param name="wMsgFilterMin">Type: UINTThe integer value of the lowest message value to be retrieved. Use WM_KEYFIRST (0x0100) to specify the first keyboard message or WM_MOUSEFIRST (0x0200) to specify the first mouse message.Use WM_INPUT here and in wMsgFilterMax to specify only the WM_INPUT messages.If wMsgFilterMin and wMsgFilterMax are both zero, GetMessage returns all available messages (that is, no range filtering is performed).</param>
        /// <param name="wMsgFilterMax">Type: UINTThe integer value of the highest message value to be retrieved. Use WM_KEYLAST to specify the last keyboard message or WM_MOUSELAST to specify the last mouse message.Use WM_INPUT here and in wMsgFilterMin to specify only the WM_INPUT messages.If wMsgFilterMin and wMsgFilterMax are both zero, GetMessage returns all available messages (that is, no range filtering is performed).Type: BOOLIf the function retrieves a message other than WM_QUIT, the return value is nonzero.If the function retrieves the WM_QUIT message, the return value is zero.If there is an error, the return value is -1. For example, the function fails if hWnd is an invalid window handle or lpMsg is an invalid pointer. To get extended error information, call GetLastError.Because the return value can be nonzero, zero, or -1, avoid code like this:The possibility of a -1 return value in the case that hWnd is an invalid parameter (such as referring to a window that has already been destroyed) means that such code can lead to fatal application errors. Instead, use code like this:An application typically uses the return value to determine whether to end the main message loop and exit the program.The GetMessage function retrieves messages associated with the window identified by the hWnd parameter or any of its children, as specified by the IsChild function, and within the range of message values given by the wMsgFilterMin and wMsgFilterMax parameters. Note that an application can only use the low word in the wMsgFilterMin and wMsgFilterMax parameters; the high word is reserved for the system.Note that GetMessage always retrieves WM_QUIT messages, no matter which values you specify for wMsgFilterMin and wMsgFilterMax.During this call, the system delivers pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the SendMessage, SendMessageCallback, SendMessageTimeout, or SendNotifyMessage function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order:GetMessage does not remove WM_PAINT messages from the queue. The messages remain in the queue until processed.If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When in the debugger mode, the system does not generate a ghost window.For an example, see Creating a Message Loop.ConceptualIsChildMSGMessages and Message QueuesPeekMessagePostMessagePostThreadMessageReferenceWaitMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetMessageA(out MSG lpMsg, nint hWnd, uint wMsgFilterMin, uint wMsgFilterMax);

        /// <summary>
        ///Retrieves the extra message information for the current thread. Extra message information is an application- or driver-defined value associated with the current thread's message queue.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetMessageExtraInfo();

        /// <summary>
        ///Retrieves the cursor position for the last message retrieved by the GetMessage function.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetMessagePos();

        /// <summary>
        ///Retrieves the message time for the last message retrieved by the GetMessage function. The time is a long integer that specifies the elapsed time, in milliseconds, from the time the system was started to the time the message was created (that is, placed in the thread's message queue).
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetMessageTime();

        /// <summary>
        ///Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is available for retrieval.
        /// </summary>
        /// <param name="lpMsg"></param>
        /// <param name="hWnd"></param>
        /// <param name="wMsgFilterMin">Type: UINTThe integer value of the lowest message value to be retrieved. Use WM_KEYFIRST (0x0100) to specify the first keyboard message or WM_MOUSEFIRST (0x0200) to specify the first mouse message.Use WM_INPUT here and in wMsgFilterMax to specify only the WM_INPUT messages.If wMsgFilterMin and wMsgFilterMax are both zero, GetMessage returns all available messages (that is, no range filtering is performed).</param>
        /// <param name="wMsgFilterMax">Type: UINTThe integer value of the highest message value to be retrieved. Use WM_KEYLAST to specify the last keyboard message or WM_MOUSELAST to specify the last mouse message.Use WM_INPUT here and in wMsgFilterMin to specify only the WM_INPUT messages.If wMsgFilterMin and wMsgFilterMax are both zero, GetMessage returns all available messages (that is, no range filtering is performed).Type: BOOLIf the function retrieves a message other than WM_QUIT, the return value is nonzero.If the function retrieves the WM_QUIT message, the return value is zero.If there is an error, the return value is -1. For example, the function fails if hWnd is an invalid window handle or lpMsg is an invalid pointer. To get extended error information, call GetLastError.Because the return value can be nonzero, zero, or -1, avoid code like this:The possibility of a -1 return value in the case that hWnd is an invalid parameter (such as referring to a window that has already been destroyed) means that such code can lead to fatal application errors. Instead, use code like this:An application typically uses the return value to determine whether to end the main message loop and exit the program.The GetMessage function retrieves messages associated with the window identified by the hWnd parameter or any of its children, as specified by the IsChild function, and within the range of message values given by the wMsgFilterMin and wMsgFilterMax parameters. Note that an application can only use the low word in the wMsgFilterMin and wMsgFilterMax parameters; the high word is reserved for the system.Note that GetMessage always retrieves WM_QUIT messages, no matter which values you specify for wMsgFilterMin and wMsgFilterMax.During this call, the system delivers pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the SendMessage, SendMessageCallback, SendMessageTimeout, or SendNotifyMessage function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order:GetMessage does not remove WM_PAINT messages from the queue. The messages remain in the queue until processed.If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When in the debugger mode, the system does not generate a ghost window.For an example, see Creating a Message Loop.ConceptualIsChildMSGMessages and Message QueuesPeekMessagePostMessagePostThreadMessageReferenceWaitMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetMessageW(out MSG lpMsg, nint hWnd, uint wMsgFilterMin, uint wMsgFilterMax);

        /// <summary>
        ///The GetMonitorInfo function retrieves information about a display monitor.
        /// </summary>
        /// <param name="hMonitor">A handle to the display monitor of interest.</param>
        /// <param name="lpmi"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetMonitorInfoA(nint hMonitor, out MONITORINFO lpmi);

        /// <summary>
        ///The GetMonitorInfo function retrieves information about a display monitor.
        /// </summary>
        /// <param name="hMonitor">A handle to the display monitor of interest.</param>
        /// <param name="lpmi"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetMonitorInfoW(nint hMonitor, out MONITORINFO lpmi);

        /// <summary>
        ///Retrieves a history of up to 64 previous coordinates of the mouse or pen.
        /// </summary>
        /// <param name="cbSize">Type: UINTThe size, in bytes, of the MOUSEMOVEPOINT structure.</param>
        /// <param name="lppt">Type: LPMOUSEMOVEPOINTA pointer to a MOUSEMOVEPOINT structure containing valid mouse coordinates (in screen coordinates). It may also contain a time stamp.The GetMouseMovePointsEx function searches for the point in the mouse coordinates history. If the function finds the point, it returns the last nBufPoints prior to and including the supplied point.If your application supplies a time stamp, the GetMouseMovePointsEx function will use it to differentiate between two equal points that were recorded at different times.An application should call this function using the mouse coordinates received from the WM_MOUSEMOVE message and convert them to screen coordinates.</param>
        /// <param name="lpptBuf"></param>
        /// <param name="nBufPoints">Type: intThe number of points to be retrieved.</param>
        /// <param name="resolution">Type: DWORDThe resolution desired. This parameter can be one of the following values.Type: intIf the function succeeds, the return value is the number of points in the buffer. Otherwise, the function returns –1. For extended error information, your application can call GetLastError.The system retains the last 64 mouse coordinates and their time stamps. If your application supplies a mouse coordinate to GetMouseMovePointsEx and the coordinate exists in the system's mouse coordinate history, the function retrieves the specified number of coordinates from the systems' history. You can also supply a time stamp, which will be used to differentiate between identical points in the history.The GetMouseMovePointsEx function will return points that eventually were dispatched not only to the calling thread but also to other threads.GetMouseMovePointsEx may fail or return erroneous values in the following cases:ConceptualMOUSEMOVEPOINTMouse InputReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetMouseMovePointsEx(uint cbSize, MOUSEMOVEPOINT lppt, out MOUSEMOVEPOINT lpptBuf, int nBufPoints, uint resolution);

        /// <summary>
        ///Retrieves a handle to the first control in a group of controls that precedes (or follows) the specified control in a dialog box.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box to be searched.</param>
        /// <param name="hCtl"></param>
        /// <param name="bPrevious">Type: BOOLIndicates how the function is to search the group of controls in the dialog box. If this parameter is TRUE, the function searches for the previous control in the group. If it is FALSE, the function searches for the next control in the group.Type: HWNDIf the function succeeds, the return value is a handle to the previous (or next) control in the group of controls.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The GetNextDlgGroupItem function searches controls in the order (or reverse order) they were created in the dialog box template. The first control in the group must have the WS_GROUP style; all other controls in the group must have been consecutively created and must not have the WS_GROUP style.When searching for the previous control, the function returns the first control it locates that is visible and not disabled. If the control specified by hCtl has the WS_GROUP style, the function temporarily reverses the search to locate the first control having the WS_GROUP style, then resumes the search in the original direction, returning the first control it locates that is visible and not disabled, or returning hCtl if no such control is found.When searching for the next control, the function returns the first control it locates that is visible, not disabled, and does not have the WS_GROUP style. If it encounters a control having the WS_GROUP style, the function reverses the search, locates the first control having the WS_GROUP style, and returns this control if it is visible and not disabled. Otherwise, the function resumes the search in the original direction and returns the first control it locates that is visible and not disabled, or returns hCtl if no such control is found.If the search for the next control in the group encounters a window with the WS_EX_CONTROLPARENT style, the system recursively searches the window's children.ConceptualDialog BoxesGetNextDlgTabItemReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetNextDlgGroupItem(nint hDlg, nint hCtl, bool bPrevious);

        /// <summary>
        ///Retrieves a handle to the first control that has the WS_TABSTOP style that precedes (or follows) the specified control.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box to be searched.</param>
        /// <param name="hCtl"></param>
        /// <param name="bPrevious">Type: BOOLIndicates how the function is to search the dialog box. If this parameter is TRUE, the function searches for the previous control in the dialog box. If this parameter is FALSE, the function searches for the next control in the dialog box.Type: HWNDIf the function succeeds, the return value is the window handle of the previous (or next) control that has the WS_TABSTOP style set.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The GetNextDlgTabItem function searches controls in the order (or reverse order) they were created in the dialog box template. The function returns the first control it locates that is visible, not disabled, and has the WS_TABSTOP style. If no such control exists, the function returns hCtl.If the search for the next control with the WS_TABSTOP style encounters a window with the WS_EX_CONTROLPARENT style, the system recursively searches the window's children.ConceptualDialog BoxesGetDlgItemGetNextDlgGroupItemReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetNextDlgTabItem(nint hDlg, nint hCtl, bool bPrevious);

        /// <summary>
        ///Retrieves the handle to the window that currently has the clipboard open.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetOpenClipboardWindow();

        /// <summary>
        ///Retrieves a handle to the specified window's parent or owner.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose parent window handle is to be retrieved.Type: HWNDIf the window is a child window, the return value is a handle to the parent window. If the window is a top-level window with the WS_POPUP style, the return value is a handle to the owner window.If the function fails, the return value is NULL. To get extended error information, call GetLastError.This function typically fails for one of the following reasons:To obtain a window's owner window, instead of using GetParent, use GetWindow with the GW_OWNER flag. To obtain the parent window and not the owner, instead of using GetParent, use GetAncestor with the GA_PARENT flag.For an example, see Initializing a Dialog Box.ConceptualGetAncestorGetWindowReferenceSetParentWindowsWindows Styles</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetParent(nint hWnd);

        /// <summary>
        ///Retrieves the position of the cursor in physical coordinates.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPhysicalCursorPos(out POINT lpPoint);

        /// <summary>
        ///Retrieves the cursor identifier associated with the specified pointer.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve the cursor identifier.</param>
        /// <param name="cursorId"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerCursorId(int pointerId, out int cursorId);

        /// <summary>
        ///Gets information about the pointer device.
        /// </summary>
        /// <param name="device">The handle to the device.</param>
        /// <param name="pointerDevice"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerDevice(nint device, out POINTER_DEVICE_INFO pointerDevice);

        /// <summary>
        ///Gets the cursor IDs that are mapped to the cursors associated with a pointer device.
        /// </summary>
        /// <param name="device">The device handle.</param>
        /// <param name="cursorCount">The number of cursors associated with the pointer device.</param>
        /// <param name="deviceCursors"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerDeviceCursors(nint device, out int cursorCount, out POINTER_DEVICE_CURSOR_INFO deviceCursors);

        /// <summary>
        ///Gets device properties that aren't included in the POINTER_DEVICE_INFO structure.
        /// </summary>
        /// <param name="device">The pointer device to query properties from.A call to the GetPointerDevices function returns this handle in the POINTER_DEVICE_INFO structure.</param>
        /// <param name="propertyCount">The number of properties.</param>
        /// <param name="pointerProperties"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerDeviceProperties(nint device, out int propertyCount, out POINTER_DEVICE_PROPERTY pointerProperties);

        /// <summary>
        ///Gets the x and y range for the pointer device (in himetric) and the x and y range (current resolution) for the display that the pointer device is mapped to.
        /// </summary>
        /// <param name="device">The handle to the pointer device.</param>
        /// <param name="pointerDeviceRect"></param>
        /// <param name="displayRect"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerDeviceRects(nint device, out RECT pointerDeviceRect, out RECT displayRect);

        /// <summary>
        ///Gets information about the pointer devices attached to the system.
        /// </summary>
        /// <param name="deviceCount">If pointerDevices is NULL, deviceCount returns the total number of attached pointer devices. Otherwise, deviceCount specifies the number of POINTER_DEVICE_INFO structures pointed to by pointerDevices.</param>
        /// <param name="pointerDevices"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerDevices(out int deviceCount, out POINTER_DEVICE_INFO pointerDevices);

        /// <summary>
        ///Gets the entire frame of information for the specified pointers associated with the current message.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve frame information.</param>
        /// <param name="pointerCount">A pointer to a variable that specifies the count of structures in the buffer to which pointerInfo points. If GetPointerFrameInfo succeeds, pointerCount is updated with the total count of pointers in the frame.</param>
        /// <param name="pointerInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerFrameInfo(int pointerId, out int pointerCount, out POINTER_INFO pointerInfo);

        /// <summary>
        ///Gets the entire frame of information (including coalesced input frames) for the specified pointers associated with the current message.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve frame information.</param>
        /// <param name="entriesCount">A pointer to a variable that specifies the count of rows in the two-dimensional array to which pointerInfo points. If GetPointerFrameInfoHistory succeeds, entriesCount is updated with the total count of frames available in the history.</param>
        /// <param name="pointerCount">A pointer to a variable that specifies the count of columns in the two-dimensional array to which pointerInfo points. If GetPointerFrameInfoHistory succeeds, pointerCount is updated with the total count of pointers in each frame.</param>
        /// <param name="pointerInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerFrameInfoHistory(int pointerId, out int entriesCount, out int pointerCount, out POINTER_INFO pointerInfo);

        /// <summary>
        ///Gets the entire frame of pen-based information for the specified pointers (of type PT_PEN) associated with the current message.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve frame information.</param>
        /// <param name="pointerCount">A pointer to a variable that specifies the count of structures in the buffer to which penInfo points. If GetPointerFramePenInfo succeeds, pointerCount is updated with the total count of pointers in the frame.</param>
        /// <param name="penInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerFramePenInfo(int pointerId, out int pointerCount, out POINTER_PEN_INFO penInfo);

        /// <summary>
        ///Gets the entire frame of pen-based information (including coalesced input frames) for the specified pointers (of type PT_PEN) associated with the current message.
        /// </summary>
        /// <param name="pointerId">The identifier of the pointer for which to retrieve frame information.</param>
        /// <param name="entriesCount">A pointer to a variable that specifies the count of rows in the two-dimensional array to which penInfo points. If GetPointerFramePenInfoHistory succeeds, entriesCount is updated with the total count of frames available in the history.</param>
        /// <param name="pointerCount">A pointer to a variable that specifies the count of columns in the two-dimensional array to which penInfo points. If GetPointerFramePenInfoHistory succeeds, pointerCount is updated with the total count of pointers in each frame.</param>
        /// <param name="penInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerFramePenInfoHistory(int pointerId, out int entriesCount, out int pointerCount, out POINTER_PEN_INFO penInfo);

        /// <summary>
        ///Gets the entire frame of touch-based information for the specified pointers (of type PT_TOUCH) associated with the current message.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve frame information.</param>
        /// <param name="pointerCount">A pointer to a variable that specifies the count of structures in the buffer to which touchInfo points. If GetPointerFrameTouchInfo succeeds, pointerCount is updated with the total count of pointers in the frame.</param>
        /// <param name="touchInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerFrameTouchInfo(int pointerId, out int pointerCount, out POINTER_TOUCH_INFO touchInfo);

        /// <summary>
        ///Gets the entire frame of touch-based information (including coalesced input frames) for the specified pointers (of type PT_TOUCH) associated with the current message.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve frame information.</param>
        /// <param name="entriesCount">A pointer to variable that specifies the count of rows in the two-dimensional array to which touchInfo points. If GetPointerFrameTouchInfoHistory succeeds, entriesCount is updated with the total count of frames available in the history.</param>
        /// <param name="pointerCount">A pointer to a variable that specifies the count of columns in the two-dimensional array to which touchInfo points. If GetPointerFrameTouchInfoHistory succeeds, pointerCount is updated with the total count of pointers in each frame.</param>
        /// <param name="touchInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerFrameTouchInfoHistory(int pointerId, out int entriesCount, out int pointerCount, out POINTER_TOUCH_INFO touchInfo);

        /// <summary>
        ///Gets the information for the specified pointer associated with the current message.
        /// </summary>
        /// <param name="pointerId">The pointer identifier.</param>
        /// <param name="pointerInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerInfo(int pointerId, out POINTER_INFO pointerInfo);

        /// <summary>
        ///Gets the information associated with the individual inputs, if any, that were coalesced into the current message for the specified pointer. The most recent input is included in the returned history and is the same as the most recent input returned by the GetPointerInfo function.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name="entriesCount">A pointer to a variable that specifies the count of structures in the buffer to which pointerInfo points. If GetPointerInfoHistory succeeds, entriesCount is updated with the total count of structures available. The total count of structures available is the same as the historyCount field of the POINTER_INFO structure returned by a call to GetPointerInfo.</param>
        /// <param name="pointerInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerInfoHistory(int pointerId, out int entriesCount, out POINTER_INFO pointerInfo);

        /// <summary>
        ///Gets one or more transforms for the pointer information coordinates associated with the current message.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name="historyCount">The number of INPUT_TRANSFORM structures that inputTransform can point to.This value must be no less than 1 and no greater than the value specified in historyCount of the POINTER_INFO structure returned by GetPointerInfo, GetPointerTouchInfo, or GetPointerPenInfo (for a single input transform) or GetPointerInfoHistory, GetPointerTouchInfoHistory, or GetPointerPenInfoHistory (for an array of input transforms).If GetPointerInputTransform succeeds, inputTransform is updated with the total count of structures available. The total count of structures available is the same as the historyCount field of the POINTER_INFO structure.</param>
        /// <param name="inputTransform"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerInputTransform(int pointerId, int historyCount, out INPUT_RECORD inputTransform);

        /// <summary>
        ///Gets the pen-based information for the specified pointer (of type PT_PEN) associated with the current message.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name="penInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerPenInfo(int pointerId, out POINTER_PEN_INFO penInfo);

        /// <summary>
        ///Gets the pen-based information associated with the individual inputs, if any, that were coalesced into the current message for the specified pointer (of type PT_PEN). The most recent input is included in the returned history and is the same as the most recent input returned by the GetPointerPenInfo function.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name="entriesCount">A pointer to a variable that specifies the count of structures in the buffer to which penInfo points. If GetPointerPenInfoHistory succeeds, entriesCount is updated with the total count of structures available. The total count of structures available is the same as the historyCount field in the POINTER_PEN_INFO structure returned by a call to GetPointerPenInfo.</param>
        /// <param name="penInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerPenInfoHistory(int pointerId, out int entriesCount, out POINTER_PEN_INFO penInfo);

        /// <summary>
        ///Gets the touch-based information for the specified pointer (of type PT_TOUCH) associated with the current message.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name="touchInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerTouchInfo(int pointerId, out POINTER_TOUCH_INFO touchInfo);

        /// <summary>
        ///Gets the touch-based information associated with the individual inputs, if any, that were coalesced into the current message for the specified pointer (of type PT_TOUCH). The most recent input is included in the returned history and is the same as the most recent input returned by the GetPointerTouchInfo function.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name="entriesCount">A pointer to a variable that specifies the count of structures in the buffer to which touchInfo points. If GetPointerTouchInfoHistory succeeds, entriesCount is updated with the total count of structures available. The total count of structures available is the same as the historyCount field in the POINTER_INFO structure returned by a call to GetPointerInfo or GetPointerTouchInfo.</param>
        /// <param name="touchInfo"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerTouchInfoHistory(int pointerId, out int entriesCount, out POINTER_TOUCH_INFO touchInfo);

        /// <summary>
        ///Retrieves the pointer type for a specified pointer.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve pointer type.</param>
        /// <param name="pointerType"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetPointerType(int pointerId, out POINTER_INPUT_TYPE pointerType);

        /// <summary>
        ///Retrieves the first available clipboard format in the specified list.
        /// </summary>
        /// <param name="paFormatPriorityList">Type: UINT*The clipboard formats, in priority order. For a description of the standard clipboard formats, see Standard Clipboard Formats .</param>
        /// <param name="cFormats">Type: intThe number of entries in the paFormatPriorityList array. This value must not be greater than the number of entries in the list.Type: intIf the function succeeds, the return value is the first clipboard format in the list for which data is available. If the clipboard is empty, the return value is NULL. If the clipboard contains data, but not in any of the specified formats, the return value is –1. To get extended error information, call GetLastError.ClipboardConceptualCountClipboardFormatsEnumClipboardFormatsGetClipboardFormatNameIsClipboardFormatAvailableReferenceRegisterClipboardFormat</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetPriorityClipboardFormat(uint paFormatPriorityList, int cFormats);

        /// <summary>
        ///Retrieves the default layout that is used when windows are created with no parent or owner.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetProcessDefaultLayout(out uint pdwDefaultLayout);

        /// <summary>
        ///Retrieves a handle to the current window station for the calling process.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetProcessWindowStation();

        /// <summary>
        ///Retrieves a data handle from the property list of the specified window. The character string identifies the handle to be retrieved. The string and handle must have been added to the property list by a previous call to the SetProp function.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose property list is to be searched.</param>
        /// <param name="lpString">Type: LPCTSTRAn atom that identifies a string. If this parameter is an atom, it must have been created by using the GlobalAddAtom function. The atom, a 16-bit value, must be placed in the low-order word of the lpString parameter; the high-order word must be zero.Type: HANDLEIf the property list contains the string, the return value is the associated data handle. Otherwise, the return value is NULL.ConceptualGlobalAddAtomReferenceSetPropWindow PropertiesITaskbarList2::MarkFullscreenWindow</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetPropA(nint hWnd, string lpString);

        /// <summary>
        ///Retrieves a data handle from the property list of the specified window. The character string identifies the handle to be retrieved. The string and handle must have been added to the property list by a previous call to the SetProp function.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose property list is to be searched.</param>
        /// <param name="lpString">Type: LPCTSTRAn atom that identifies a string. If this parameter is an atom, it must have been created by using the GlobalAddAtom function. The atom, a 16-bit value, must be placed in the low-order word of the lpString parameter; the high-order word must be zero.Type: HANDLEIf the property list contains the string, the return value is the associated data handle. Otherwise, the return value is NULL.ConceptualGlobalAddAtomReferenceSetPropWindow PropertiesITaskbarList2::MarkFullscreenWindow</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetPropW(nint hWnd, string lpString);

        /// <summary>
        ///Retrieves the type of messages found in the calling thread's message queue.
        /// </summary>
        /// <param name="flags">Type: UINTThe types of messages for which to check. This parameter can be one or more of the following values.Type: DWORDThe high-order word of the return value indicates the types of messages currently in the queue. The low-order word indicates the types of messages that have been added to the queue and that are still in the queue since the last call to the GetQueueStatus, GetMessage, or PeekMessage function.The presence of a QS_ flag in the return value does not guarantee that a subsequent call to the GetMessage or PeekMessage function will return a message. GetMessage and PeekMessage perform some internal filtering that may cause the message to be processed internally. For this reason, the return value from GetQueueStatus should be considered only a hint as to whether GetMessage or PeekMessage should be called.The QS_ALLPOSTMESSAGE and QS_POSTMESSAGE flags differ in when they are cleared. QS_POSTMESSAGE is cleared when you call GetMessage or PeekMessage, whether or not you are filtering messages. QS_ALLPOSTMESSAGE is cleared when you call GetMessage or PeekMessage without filtering messages (wMsgFilterMin and wMsgFilterMax are 0). This can be useful when you call PeekMessage multiple times to get messages in different ranges.ConceptualGetInputStateGetMessageMessages and Message QueuesPeekMessageReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetQueueStatus(uint flags);

        /// <summary>
        ///Performs a buffered read of the raw input messages data found in the calling thread's message queue.
        /// </summary>
        /// <param name="pData"></param>
        /// <param name="pcbSize">Type: PUINTThe size, in bytes, of the provided RAWINPUT buffer.</param>
        /// <param name="cbSizeHeader">Type: UINTThe size, in bytes, of the RAWINPUTHEADER structure.Type: UINTIf pData is NULL and the function is successful, the return value is zero. If pData is not NULL and the function is successful, the return value is the number of RAWINPUT structures written to pData.If an error occurs, the return value is (UINT)-1. Call GetLastError for the error code.When an application receives raw input, its message queue gets a WM_INPUT message and the queue status flag QS_RAWINPUT is set.Using GetRawInputBuffer, the raw input data is read in the array of variable size RAWINPUT structures and corresponding WM_INPUT messages are removed from the calling thread's message queue. You can call this method several times with buffer that cannot fit all message's data until all raw input messages have been read.The NEXTRAWINPUTBLOCK macro allows an application to traverse an array of RAWINPUT structures.If all raw input messages have been successfully read from message queue then QS_RAWINPUT flag is cleared from the calling thread's message queue status.ConceptualGetMessageNEXTRAWINPUTBLOCKRAWINPUTRAWINPUTHEADERRaw InputReferenceRaw Input Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetRawInputBuffer(out POINT pData, out uint pcbSize, uint cbSizeHeader);

        /// <summary>
        ///Retrieves the raw input from the specified device.
        /// </summary>
        /// <param name="hRawInput">Type: HRAWINPUTA handle to the RAWINPUT structure. This comes from the lParam in WM_INPUT.</param>
        /// <param name="uiCommand">Type: UINTThe command flag. This parameter can be one of the following values.</param>
        /// <param name="pData"></param>
        /// <param name="pcbSize">Type: PUINTThe size, in bytes, of the data in pData.</param>
        /// <param name="cbSizeHeader">Type: UINTThe size, in bytes, of the RAWINPUTHEADER structure.Type: UINTIf pData is NULL and the function is successful, the return value is 0. If pData is not NULL and the function is successful, the return value is the number of bytes copied into pData.If there is an error, the return value is (UINT)-1.GetRawInputData gets the raw input one RAWINPUT structure at a time. In contrast, GetRawInputBuffer gets an array of RAWINPUT structures.ConceptualGetRawInputBufferRAWINPUTRAWINPUTHEADERRaw InputReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetRawInputData(HARDWAREINPUT hRawInput, uint uiCommand, out nint pData, out uint pcbSize, uint cbSizeHeader);

        /// <summary>
        ///Retrieves information about the raw input device.
        /// </summary>
        /// <param name="hDevice"></param>
        /// <param name="uiCommand">Type: UINTSpecifies what data will be returned in pData. This parameter can be one of the following values.</param>
        /// <param name="pData"></param>
        /// <param name="pcbSize">Type: PUINTThe size, in bytes, of the data in pData.Type: UINTIf successful, this function returns a non-negative number indicating the number of bytes copied to pData.If pData is not large enough for the data, the function returns -1. If pData is NULL, the function returns a value of zero. In both of these cases, pcbSize is set to the minimum size required for the pData buffer.Call GetLastError to identify any other errors.ConceptualRAWINPUTHEADERRID_DEVICE_INFORaw InputReferenceWM_INPUTTop-Level CollectionsPreparsed DataPHIDP_PREPARSED_DATAOpening HID collectionsHandling HID Reports</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetRawInputDeviceInfoA(nint hDevice, uint uiCommand, out nint pData, out uint pcbSize);

        /// <summary>
        ///Retrieves information about the raw input device.
        /// </summary>
        /// <param name="hDevice"></param>
        /// <param name="uiCommand">Type: UINTSpecifies what data will be returned in pData. This parameter can be one of the following values.</param>
        /// <param name="pData"></param>
        /// <param name="pcbSize">Type: PUINTThe size, in bytes, of the data in pData.Type: UINTIf successful, this function returns a non-negative number indicating the number of bytes copied to pData.If pData is not large enough for the data, the function returns -1. If pData is NULL, the function returns a value of zero. In both of these cases, pcbSize is set to the minimum size required for the pData buffer.Call GetLastError to identify any other errors.ConceptualRAWINPUTHEADERRID_DEVICE_INFORaw InputReferenceWM_INPUTTop-Level CollectionsPreparsed DataPHIDP_PREPARSED_DATAOpening HID collectionsHandling HID Reports</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetRawInputDeviceInfoW(nint hDevice, uint uiCommand, out nint pData, out uint pcbSize);

        /// <summary>
        ///Enumerates the raw input devices attached to the system.
        /// </summary>
        /// <param name="pRawInputDeviceList"></param>
        /// <param name="puiNumDevices">Type: PUINTIf pRawInputDeviceList is NULL, the function populates this variable with the number of devices attached to the system; otherwise, this variable specifies the number of RAWINPUTDEVICELIST structures that can be contained in the buffer to which pRawInputDeviceList points. If this value is less than the number of devices attached to the system, the function returns the actual number of devices in this variable and fails with ERROR_INSUFFICIENT_BUFFER. If this value is greater than or equal to the number of devices attached to the system, then the value is unchanged, and the number of devices is reported as the return value.</param>
        /// <param name="cbSize">Type: UINTThe size of a RAWINPUTDEVICELIST structure, in bytes.Type: UINTIf the function is successful, the return value is the number of devices stored in the buffer pointed to by pRawInputDeviceList.On any other error, the function returns (UINT) -1 and GetLastError returns the error indication.The devices returned from this function are the mouse, the keyboard, and other Human Interface Device (HID) devices.To get more detailed information about the attached devices, call GetRawInputDeviceInfo using the hDevice from RAWINPUTDEVICELIST.The following sample code shows a typical call to GetRawInputDeviceList:ConceptualGetRawInputDeviceInfoRAWINPUTDEVICELISTRaw InputReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetRawInputDeviceList(out RAWINPUTDEVICELIST pRawInputDeviceList, out uint puiNumDevices, uint cbSize);

        /// <summary>
        ///Gets the raw input data from the pointer device.
        /// </summary>
        /// <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
        /// <param name="historyCount">The pointer history.</param>
        /// <param name="propertiesCount">Number of properties to retrieve.</param>
        /// <param name="pProperties">Array of POINTER_DEVICE_PROPERTY structures that contain raw data reported by the device.</param>
        /// <param name="pValues"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetRawPointerDeviceData(int pointerId, int historyCount, int propertiesCount, POINTER_DEVICE_PROPERTY pProperties, out int pValues);

        /// <summary>
        ///Retrieves the information about the raw input devices for the current application.
        /// </summary>
        /// <param name="pRawInputDevices"></param>
        /// <param name="puiNumDevices">Type: PUINTThe number of RAWINPUTDEVICE structures in *pRawInputDevices.</param>
        /// <param name="cbSize">Type: UINTThe size, in bytes, of a RAWINPUTDEVICE structure.Type: UINTIf successful, the function returns a non-negative number that is the number of RAWINPUTDEVICE structures written to the buffer.If the pRawInputDevices buffer is too small or NULL, the function sets the last error as ERROR_INSUFFICIENT_BUFFER, returns -1, and sets puiNumDevices to the required number of devices. If the function fails for any other reason, it returns -1. For more details, call GetLastError.To receive raw input from a device, an application must register it by using RegisterRawInputDevices.ConceptualRAWINPUTDEVICERaw InputReferenceRegisterRawInputDevices</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetRegisteredRawInputDevices(out RAWINPUTDEVICE pRawInputDevices, out uint puiNumDevices, uint cbSize);

        /// <summary>
        ///The GetScrollBarInfo function retrieves information about the specified scroll bar.
        /// </summary>
        /// <param name="hwnd">Type: HWNDHandle to a window associated with the scroll bar whose information is to be retrieved. If the idObject parameter is OBJID_CLIENT, hwnd is a handle to a scroll bar control. Otherwise, hwnd is a handle to a window created with WS_VSCROLL and/or WS_HSCROLL style.</param>
        /// <param name="idObject">Type: LONGSpecifies the scroll bar object. This parameter can be one of the following values.</param>
        /// <param name="psbi"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetScrollBarInfo(nint hwnd, int idObject, out SCROLLBARINFO psbi);

        /// <summary>
        ///The GetScrollInfo function retrieves the parameters of a scroll bar, including the minimum and maximum scrolling positions, the page size, and the position of the scroll box (thumb).
        /// </summary>
        /// <param name="hwnd">Type: HWNDHandle to a scroll bar control or a window with a standard scroll bar, depending on the value of the fnBar parameter.</param>
        /// <param name="nBar">Type: intSpecifies the type of scroll bar for which to retrieve parameters. This parameter can be one of the following values.</param>
        /// <param name="lpsi">Type: LPSCROLLINFOPointer to a SCROLLINFO structure. Before calling GetScrollInfo, set the cbSize member to sizeof(SCROLLINFO), and set the fMask member to specify the scroll bar parameters to retrieve. Before returning, the function copies the specified parameters to the appropriate members of the structure.The fMask member can be one or more of the following values.Type: BOOLIf the function retrieved any values, the return value is nonzero.If the function does not retrieve any values, the return value is zero. To get extended error information, call GetLastError.The GetScrollInfo function enables applications to use 32-bit scroll positions. Although the messages that indicate scroll bar position, WM_HSCROLL and WM_VSCROLL, provide only 16 bits of position data, the functions SetScrollInfo and GetScrollInfo provide 32 bits of scroll bar position data. Thus, an application can call GetScrollInfo while processing either the WM_HSCROLL or WM_VSCROLL messages to obtain 32-bit scroll bar position data.To get the 32-bit position of the scroll box (thumb) during a SB_THUMBTRACK request code in a WM_HSCROLL or WM_VSCROLL message, call GetScrollInfo with the SIF_TRACKPOS value in the fMask member of the SCROLLINFO structure. The function returns the tracking position of the scroll box in the nTrackPos member of the SCROLLINFO structure. This allows you to get the position of the scroll box as the user moves it. The following sample code illustrates the technique.If the fnBar parameter is SB_CTL and the window specified by the hwnd parameter is not a system scroll bar control, the system sends the SBM_GETSCROLLINFO message to the window to obtain scroll bar information. This allows GetScrollInfo to operate on a custom control that mimics a scroll bar. If the window does not handle the SBM_GETSCROLLINFO message, the GetScrollInfo function fails.ReferenceSCROLLINFOSetScrollInfoWM_HSCROLLWM_VSCROLL</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetScrollInfo(nint hwnd, int nBar, out SCROLLINFO lpsi);

        /// <summary>
        ///The GetScrollPos function retrieves the current position of the scroll box (thumb) in the specified scroll bar. The current position is a relative value that depends on the current scrolling range. For example, if the scrolling range is 0 through 100 and the scroll box is in the middle of the bar, the current position is 50.
        /// </summary>
        /// <param name="hWnd">Type: HWNDHandle to a scroll bar control or a window with a standard scroll bar, depending on the value of the nBar parameter.</param>
        /// <param name="nBar">Type: intSpecifies the scroll bar to be examined. This parameter can be one of the following values.Type: intIf the function succeeds, the return value is the current position of the scroll box.If the function fails, the return value is zero. To get extended error information, call GetLastError.The GetScrollPos function enables applications to use 32-bit scroll positions. Although the messages that indicate scroll bar position, WM_HSCROLL and WM_VSCROLL, are limited to 16 bits of position data, the functions SetScrollPos, SetScrollRange, GetScrollPos, and GetScrollRange support 32-bit scroll bar position data. Thus, an application can call GetScrollPos while processing either the WM_HSCROLL or WM_VSCROLL messages to obtain 32-bit scroll bar position data.To get the 32-bit position of the scroll box (thumb) during a SB_THUMBTRACK request code in a WM_HSCROLL or WM_VSCROLL message, use the GetScrollInfo function.If the nBar parameter is SB_CTL and the window specified by the hWnd parameter is not a system scroll bar control, the system sends the SBM_GETPOS message to the window to obtain scroll bar information. This allows GetScrollPos to operate on a custom control that mimics a scroll bar. If the window does not handle the SBM_GETPOS message, the GetScrollPos function fails.GetScrollInfoGetScrollRangeReferenceSetScrollInfoSetScrollPosSetScrollRangeWM_HSCROLLWM_VSCROLL</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetScrollPos(nint hWnd, int nBar);

        /// <summary>
        ///The GetScrollRange function retrieves the current minimum and maximum scroll box (thumb) positions for the specified scroll bar.
        /// </summary>
        /// <param name="hWnd">Type: HWNDHandle to a scroll bar control or a window with a standard scroll bar, depending on the value of the nBar parameter.</param>
        /// <param name="nBar">Type: intSpecifies the scroll bar from which the positions are retrieved. This parameter can be one of the following values.</param>
        /// <param name="lpMinPos"></param>
        /// <param name="lpMaxPos"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetScrollRange(nint hWnd, int nBar, out int lpMinPos, out int lpMaxPos);

        /// <summary>
        ///Retrieves a handle to the Shell's desktop window.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetShellWindow();

        /// <summary>
        ///Retrieves a handle to the drop-down menu or submenu activated by the specified menu item.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu.</param>
        /// <param name="nPos">Type: intThe zero-based relative position in the specified menu of an item that activates a drop-down menu or submenu.Type: HMENUIf the function succeeds, the return value is a handle to the drop-down menu or submenu activated by the menu item. If the menu item does not activate a drop-down menu or submenu, the return value is NULL.ConceptualCreatePopupMenuGetMenuMenusReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetSubMenu(nint hMenu, int nPos);

        /// <summary>
        ///Retrieves the current color of the specified display element. Display elements are the parts of a window and the display that appear on the system display screen.
        /// </summary>
        /// <param name="nIndex">Type: intThe display element whose color is to be retrieved. This parameter can be one of the following values.Type: DWORDThe function returns the red, green, blue (RGB) color value of the given element.If the nIndex parameter is out of range, the return value is zero. Because zero is also a valid RGB value, you cannot use GetSysColor to determine whether a system color is supported by the current platform. Instead, use the GetSysColorBrush function, which returns NULL if the color is not supported.To display the component of the RGB value, use the GetRValue, GetGValue, and GetBValue macros.System colors for monochrome displays are usually interpreted as shades of gray.To paint with a system color brush, an application should use GetSysColorBrush(nIndex), instead of CreateSolidBrush(GetSysColor(nIndex)), because GetSysColorBrush returns a cached brush, instead of allocating a new one.Color is an important visual element of most user interfaces. For guidelines about using color in your applications, see Color - Win32 and Color in Windows 11.This table shows the values that are supported in Windows 10 and Windows 11 with color values from the Windows 11 Aquatic contrast theme.These images show how the colors appear when used on a background set to COLOR_WINDOW.For an example, see SetSysColors.CreateSolidBrushGetSysColorBrushSetSysColorsSystemParametersInfo</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetSysColor(int nIndex);

        /// <summary>
        ///The GetSysColorBrush function retrieves a handle identifying a logical brush that corresponds to the specified color index.
        /// </summary>
        /// <param name="nIndex">A color index. This value corresponds to the color used to paint one of the window elements. See GetSysColor for system color index values.The return value identifies a logical brush if the nIndex parameter is supported by the current platform. Otherwise, it returns NULL.A brush is a bitmap that the system uses to paint the interiors of filled shapes. An application can retrieve the current system colors by calling the GetSysColor function. An application can set the current system colors by calling the SetSysColors function.An application must not register a window class for a window using a system brush. To register a window class with a system color, see the documentation of the hbrBackground member of the WNDCLASS or WNDCLASSEX structures.System color brushes track changes in system colors. In other words, when the user changes a system color, the associated system color brush automatically changes to the new color.To paint with a system color brush, an application should use GetSysColorBrush (nIndex) instead of CreateSolidBrush ( GetSysColor (nIndex)), because GetSysColorBrush returns a cached brush instead of allocating a new one.System color brushes are owned by the system so you don't need to destroy them. Although you don't need to delete the logical brush that GetSysColorBrush returns, no harm occurs by calling DeleteObject.Brush FunctionsBrushes OverviewCreateSolidBrushGetSysColorSetSysColorsWNDCLASSWNDCLASSEX</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetSysColorBrush(int nIndex);

        /// <summary>
        ///Retrieves the system DPI associated with a given process. This is useful for avoiding compatibility issues that arise from sharing DPI-sensitive information between multiple system-aware processes with different system DPI values.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetSystemDpiForProcess(nint hProcess);

        /// <summary>
        ///Enables the application to access the window menu (also known as the system menu or the control menu) for copying and modifying.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window that will own a copy of the window menu.</param>
        /// <param name="bRevert">Type: BOOLThe action to be taken. If this parameter is FALSE, GetSystemMenu returns a handle to the copy of the window menu currently in use. The copy is initially identical to the window menu, but it can be modified. If this parameter is TRUE, GetSystemMenu resets the window menu back to the default state. The previous window menu, if any, is destroyed.Type: HMENUIf the bRevert parameter is FALSE, the return value is a handle to a copy of the window menu. If the bRevert parameter is TRUE, the return value is NULL.Any window that does not use the GetSystemMenu function to make its own copy of the window menu receives the standard window menu.The window menu initially contains items with various identifier values, such as SC_CLOSE, SC_MOVE, and SC_SIZE.Menu items on the window menu send WM_SYSCOMMAND messages.All predefined window menu items have identifier numbers greater than 0xF000. If an application adds commands to the window menu, it should use identifier numbers less than 0xF000.The system automatically grays items on the standard window menu, depending on the situation. The application can perform its own checking or graying by responding to the WM_INITMENU message that is sent before any menu is displayed.ConceptualGetMenuInsertMenuItemMenusReferenceSetMenuItemInfoWM_INITMENUWM_SYSCOMMAND</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetSystemMenu(nint hWnd, bool bRevert);

        /// <summary>
        ///Retrieves the specified system metric or system configuration setting.
        /// </summary>
        /// <param name="nIndex">Type: intThe system metric or configuration setting to be retrieved. This parameter can be one of the following values. Note that all SM_CX* values are widths and all SM_CY* values are heights. Also note that all settings designed to return Boolean data represent TRUE as any nonzero value, and FALSE as a zero value.Type: intIf the function succeeds, the return value is the requested system metric or configuration setting.If the function fails, the return value is 0. GetLastError does not provide extended error information.System metrics can vary from display to display.GetSystemMetrics(SM_CMONITORS) counts only visible display monitors. This is different from EnumDisplayMonitors, which enumerates both visible display monitors and invisible pseudo-monitors that are associated with mirroring drivers. An invisible pseudo-monitor is associated with a pseudo-device used to mirror application drawing for remoting or other purposes.The SM_ARRANGE setting specifies how the system arranges minimized windows, and consists of a starting position and a direction. The starting position can be one of the following values.The direction in which to arrange minimized windows can be one of the following values.The SM_DIGITIZER setting specifies the type of digitizers that are installed on a device running Windows 7 or Windows Server 2008 R2. The return value is a bitmask that specifies one or more of the following values.This API is not DPI aware, and should not be used if the calling thread is per-monitor DPI aware. For the DPI-aware version of this API, see GetSystemMetricsForDPI. For more information on DPI awareness, see the Windows High DPI documentation.The following example uses the GetSystemMetrics function to determine whether a mouse is installed and whether the mouse buttons are swapped. The example also uses the SystemParametersInfo function to retrieve the mouse threshold and speed. It displays the information in the console.EnumDisplayMonitorsGetSystemMetricsForDPISystemParametersInfo</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetSystemMetrics(int nIndex);

        /// <summary>
        ///Retrieves the specified system metric or system configuration setting taking into account a provided DPI.
        /// </summary>
        /// <param name="nIndex">The system metric or configuration setting to be retrieved. See GetSystemMetrics for the possible values.</param>
        /// <param name="dpi">The DPI to use for scaling the metric.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.This function returns the same result as GetSystemMetrics but scales it according to an arbitrary DPI you provide if appropriate.</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetSystemMetricsForDpi(int nIndex, uint dpi);

        /// <summary>
        ///The GetTabbedTextExtent function computes the width and height of a character string. If the string contains one or more tab characters, the width of the string is based upon the specified tab stops. The GetTabbedTextExtent function uses the currently selected font to compute the dimensions of the string.
        /// </summary>
        /// <param name="hdc">A handle to the device context.</param>
        /// <param name="lpString">A pointer to a character string.</param>
        /// <param name="chCount">The length of the text string. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</param>
        /// <param name="nTabPositions">The number of tab-stop positions in the array pointed to by the lpnTabStopPositions parameter.</param>
        /// <param name="lpnTabStopPositions">A pointer to an array containing the tab-stop positions, in device units. The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array.If the function succeeds, the return value is the dimensions of the string in logical units. The height is in the high-order word and the width is in the low-order word.If the function fails, the return value is 0. GetTabbedTextExtent will fail if hDC is invalid and if nTabPositions is less than 0.The current clipping region does not affect the width and height returned by the GetTabbedTextExtent function.Because some devices do not place characters in regular cell arrays (that is, they kern the characters), the sum of the extents of the characters in a string may not be equal to the extent of the string.If the nTabPositions parameter is zero and the lpnTabStopPositions parameter is NULL, tabs are expanded to eight times the average character width.If nTabPositions is 1, the tab stops are separated by the distance specified by the first value in the array to which lpnTabStopPositions points.Font and Text FunctionsFonts and Text OverviewGetTextExtentPoint32TabbedTextOut</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetTabbedTextExtentA(nint hdc, string lpString, int chCount, int nTabPositions, int lpnTabStopPositions);

        /// <summary>
        ///The GetTabbedTextExtent function computes the width and height of a character string. If the string contains one or more tab characters, the width of the string is based upon the specified tab stops. The GetTabbedTextExtent function uses the currently selected font to compute the dimensions of the string.
        /// </summary>
        /// <param name="hdc">A handle to the device context.</param>
        /// <param name="lpString">A pointer to a character string.</param>
        /// <param name="chCount">The length of the text string. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</param>
        /// <param name="nTabPositions">The number of tab-stop positions in the array pointed to by the lpnTabStopPositions parameter.</param>
        /// <param name="lpnTabStopPositions">A pointer to an array containing the tab-stop positions, in device units. The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array.If the function succeeds, the return value is the dimensions of the string in logical units. The height is in the high-order word and the width is in the low-order word.If the function fails, the return value is 0. GetTabbedTextExtent will fail if hDC is invalid and if nTabPositions is less than 0.The current clipping region does not affect the width and height returned by the GetTabbedTextExtent function.Because some devices do not place characters in regular cell arrays (that is, they kern the characters), the sum of the extents of the characters in a string may not be equal to the extent of the string.If the nTabPositions parameter is zero and the lpnTabStopPositions parameter is NULL, tabs are expanded to eight times the average character width.If nTabPositions is 1, the tab stops are separated by the distance specified by the first value in the array to which lpnTabStopPositions points.Font and Text FunctionsFonts and Text OverviewGetTextExtentPoint32TabbedTextOut</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetTabbedTextExtentW(nint hdc, string lpString, int chCount, int nTabPositions, int lpnTabStopPositions);

        /// <summary>
        ///Retrieves a handle to the desktop assigned to the specified thread.
        /// </summary>
        /// <param name="dwThreadId">The thread identifier. The GetCurrentThreadId and CreateProcess functions return thread identifiers.If the function succeeds, the return value is a handle to the desktop associated with the specified thread. You do not need to call the CloseDesktop function to close the returned handle.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The system associates a desktop with a thread when that thread is created. A thread can use the SetThreadDesktop function to change its desktop. The desktop associated with a thread must be on the window station associated with the thread's process.The calling process can use the returned handle in calls to the GetUserObjectInformation, GetUserObjectSecurity, SetUserObjectInformation, and SetUserObjectSecurity functions.A service application is created with an associated window station and desktop, so there is no need to call a USER or GDI function to connect the service to a window station and desktop.DesktopsGetCurrentThreadIdGetProcessWindowStationGetUserObjectInformationGetUserObjectSecuritySetProcessWindowStationSetThreadDesktopSetUserObjectInformationSetUserObjectSecurityWindow Station and Desktop Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetThreadDesktop(uint dwThreadId);

        /// <summary>
        ///Gets the DPI_AWARENESS_CONTEXT for the current thread.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern DPI_AWARENESS GetThreadDpiAwarenessContext();

        /// <summary>
        ///Retrieves the DPI_HOSTING_BEHAVIOR from the current thread.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern DPI_HOSTING_BEHAVIOR GetThreadDpiHostingBehavior();

        /// <summary>
        ///Retrieves information about the specified title bar.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the title bar whose information is to be retrieved.</param>
        /// <param name="pti">Type: PTITLEBARINFOA pointer to a TITLEBARINFO structure to receive the information. Note that you must set the cbSize member to sizeof(TITLEBARINFO) before calling this function.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.ConceptualReferenceTITLEBARINFOWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetTitleBarInfo(nint hwnd, out TITLEBARINFO pti);

        /// <summary>
        ///Examines the Z order of the child windows associated with the specified parent window and retrieves a handle to the child window at the top of the Z order.
        /// </summary>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetTopWindow(nint hWnd);

        /// <summary>
        ///Retrieves detailed information about touch inputs associated with a particular touch input handle.
        /// </summary>
        /// <param name="hTouchInput">The touch input handle received in the LPARAM of a touch message. The function fails with ERROR_INVALID_HANDLE if this handle is not valid. Note that the handle is not valid after it has been used in a successful call to CloseTouchInputHandle or after it has been passed to DefWindowProc, PostMessage, SendMessage or one of their variants.</param>
        /// <param name="cInputs">The number of structures in the pInputs array. This should ideally be at least equal to the number of touch points associated with the message as indicated in the message WPARAM. If cInputs is less than the number of touch points, the function will still succeed and populate the pInputs buffer with information about cInputs touch points.</param>
        /// <param name="pInputs"></param>
        /// <param name="cbSize">The size, in bytes, of a single TOUCHINPUT structure. If cbSize is not the size of a single TOUCHINPUT structure, the function fails with ERROR_INVALID_PARAMETER.If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, use the GetLastError function.Calling CloseTouchInputHandle will not free memory associated with values retrieved in a call to GetTouchInputInfo. Values in structures passed to GetTouchInputInfo will be valid until you delete them.CloseTouchInputHandleFunctionsTOUCHINPUT</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetTouchInputInfo(TOUCHINPUT hTouchInput, uint cInputs, out TOUCHINPUT pInputs, int cbSize);

        /// <summary>
        ///Gets pointer data before it has gone through touch prediction processing.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetUnpredictedMessagePos();

        /// <summary>
        ///Retrieves the currently supported clipboard formats.
        /// </summary>
        /// <param name="lpuiFormats"></param>
        /// <param name="cFormats">Type: UINTThe number of entries in the array pointed to by lpuiFormats.</param>
        /// <param name="pcFormatsOut"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetUpdatedClipboardFormats(out uint lpuiFormats, uint cFormats, out uint pcFormatsOut);

        /// <summary>
        ///The GetUpdateRect function retrieves the coordinates of the smallest rectangle that completely encloses the update region of the specified window. GetUpdateRect retrieves the rectangle in logical coordinates. If there is no update region, GetUpdateRect retrieves an empty rectangle (sets all coordinates to zero).
        /// </summary>
        /// <param name="hWnd">Handle to the window whose update region is to be retrieved.</param>
        /// <param name="lpRect"></param>
        /// <param name="bErase">Specifies whether the background in the update region is to be erased. If this parameter is TRUE and the update region is not empty, GetUpdateRect sends a WM_ERASEBKGND message to the specified window to erase the background.If the update region is not empty, the return value is nonzero.If there is no update region, the return value is zero.The update rectangle retrieved by the BeginPaint function is identical to that retrieved by GetUpdateRect.BeginPaint automatically validates the update region, so any call to GetUpdateRect made immediately after the call to BeginPaint retrieves an empty update region.BeginPaintGetUpdateRgnInvalidateRectPainting and Drawing FunctionsPainting and Drawing OverviewRECTUpdateWindowValidateRect</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetUpdateRect(nint hWnd, out RECT lpRect, bool bErase);

        /// <summary>
        ///The GetUpdateRgn function retrieves the update region of a window by copying it into the specified region. The coordinates of the update region are relative to the upper-left corner of the window (that is, they are client coordinates).
        /// </summary>
        /// <param name="hWnd">Handle to the window with an update region that is to be retrieved.</param>
        /// <param name="hRgn">Handle to the region to receive the update region.</param>
        /// <param name="bErase">Specifies whether the window background should be erased and whether nonclient areas of child windows should be drawn. If this parameter is FALSE, no drawing is done.The return value indicates the complexity of the resulting region; it can be one of the following values.The BeginPaint function automatically validates the update region, so any call to GetUpdateRgn made immediately after the call to BeginPaint retrieves an empty update region.Painting and Drawing FunctionsPainting and Drawing Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetUpdateRgn(nint hWnd, nint hRgn, bool bErase);

        /// <summary>
        ///Retrieves information about the specified window station or desktop object.
        /// </summary>
        /// <param name="hObj">A handle to the window station or desktop object. This handle is returned by the CreateWindowStation, OpenWindowStation, CreateDesktop, or OpenDesktop function.</param>
        /// <param name="nIndex">The information to be retrieved. The parameter can be one of the following values.</param>
        /// <param name="pvInfo"></param>
        /// <param name="nLength">The size of the buffer pointed to by the pvInfo parameter, in bytes.</param>
        /// <param name="lpnLengthNeeded"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetUserObjectInformationA(nint hObj, int nIndex, out nint pvInfo, uint nLength, out uint lpnLengthNeeded);

        /// <summary>
        ///Retrieves information about the specified window station or desktop object.
        /// </summary>
        /// <param name="hObj">A handle to the window station or desktop object. This handle is returned by the CreateWindowStation, OpenWindowStation, CreateDesktop, or OpenDesktop function.</param>
        /// <param name="nIndex">The information to be retrieved. The parameter can be one of the following values.</param>
        /// <param name="pvInfo"></param>
        /// <param name="nLength">The size of the buffer pointed to by the pvInfo parameter, in bytes.</param>
        /// <param name="lpnLengthNeeded"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetUserObjectInformationW(nint hObj, int nIndex, out nint pvInfo, uint nLength, out uint lpnLengthNeeded);

        /// <summary>
        ///The GetUserObjectSecurity function retrieves security information for the specified user object.
        /// </summary>
        /// <param name="hObj">A handle to the user object for which to return security information.</param>
        /// <param name="pSIRequested">A pointer to a SECURITY_INFORMATION value that specifies the security information being requested.</param>
        /// <param name="pSID"></param>
        /// <param name="nLength">The length, in bytes, of the buffer pointed to by the pSD parameter.</param>
        /// <param name="lpnLengthNeeded"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetUserObjectSecurity(nint hObj, ACL_SIZE_INFORMATION pSIRequested, out SECURITY_DESCRIPTOR pSID, uint nLength, out uint lpnLengthNeeded);

        /// <summary>
        ///Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to a window. The window handle retrieved is relative to this window, based on the value of the uCmd parameter.</param>
        /// <param name="uCmd">Type: UINTThe relationship between the specified window and the window whose handle is to be retrieved. This parameter can be one of the following values.Type: HWNDIf the function succeeds, the return value is a window handle. If no window exists with the specified relationship to the specified window, the return value is NULL. To get extended error information, call GetLastError.The EnumChildWindows function is more reliable than calling GetWindow in a loop. An application that calls GetWindow to perform this task risks being caught in an infinite loop or referencing a handle to a window that has been destroyed.ConceptualEnumChildWindowsReferenceWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetWindow(nint hWnd, uint uCmd);

        /// <summary>
        ///Retrieves the Help context identifier, if any, associated with the specified window.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetWindowContextHelpId(nint unnamedParam1);

        /// <summary>
        ///The GetWindowDC function retrieves the device context (DC) for the entire window, including title bar, menus, and scroll bars. A window device context permits painting anywhere in a window, because the origin of the device context is the upper-left corner of the window instead of the client area.
        /// </summary>
        /// <param name="hWnd">A handle to the window with a device context that is to be retrieved. If this value is NULL, GetWindowDC retrieves the device context for the entire screen.If this parameter is NULL, GetWindowDC retrieves the device context for the primary display monitor. To get the device context for other display monitors, use the EnumDisplayMonitors and CreateDC functions.If the function succeeds, the return value is a handle to a device context for the specified window.If the function fails, the return value is NULL, indicating an error or an invalid hWnd parameter.GetWindowDC is intended for special painting effects within a window's nonclient area. Painting in nonclient areas of any window is not recommended.The GetSystemMetrics function can be used to retrieve the dimensions of various parts of the nonclient area, such as the title bar, menu, and scroll bars.The GetDC function can be used to retrieve a device context for the entire screen.After painting is complete, the ReleaseDC function must be called to release the device context. Not releasing the window device context has serious effects on painting requested by applications.BeginPaintGetDCGetSystemMetricsPainting and Drawing FunctionsPainting and Drawing OverviewReleaseDC</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint GetWindowDC(nint hWnd);

        /// <summary>
        ///Retrieves the current display affinity setting, from any process, for a given window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window.</param>
        /// <param name="pdwAffinity"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetWindowDisplayAffinity(nint hWnd, out uint pdwAffinity);

        /// <summary>
        ///Returns the DPI_AWARENESS_CONTEXT associated with a window.
        /// </summary>
        /// <param name="hwnd">The window to query.The DPI_AWARENESS_CONTEXT for the provided window. If the window is not valid, the return value is NULL.DPI_AWARENESSGetAwarenessFromDpiAwarenessContext</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern DPI_AWARENESS GetWindowDpiAwarenessContext(nint hwnd);

        /// <summary>
        ///Returns the DPI_HOSTING_BEHAVIOR of the specified window.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern DPI_HOSTING_BEHAVIOR GetWindowDpiHostingBehavior(nint hwnd);

        /// <summary>
        ///Retrieves the feedback configuration for a window.
        /// </summary>
        /// <param name="hwnd">The window to check for feedback configuration.</param>
        /// <param name="feedback">One of the values from the FEEDBACK_TYPE enumeration.</param>
        /// <param name="dwFlags">Specify GWFS_INCLUDE_ANCESTORS to check the parent window chain until a value is found. The default is 0 and indicates that only the specified window will be checked.</param>
        /// <param name="pSize">The size of memory region that the config parameter points to.The pSize parameter specifies the size of the configuration data for the feedback type in feedback and must be sizeof(BOOL).</param>
        /// <param name="config"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetWindowFeedbackSetting(nint hwnd, FEEDBACK_TYPE feedback, uint dwFlags, out int pSize, out nint config);

        /// <summary>
        ///Retrieves information about the specified window.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window whose information is to be retrieved.</param>
        /// <param name="pwi">Type: PWINDOWINFOA pointer to a WINDOWINFO structure to receive the information. Note that you must set the cbSize member to sizeof(WINDOWINFO) before calling this function.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero.To get extended error information, call GetLastError.ConceptualReferenceWINDOWINFOWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetWindowInfo(nint hwnd, out WINDOWINFO pwi);

        /// <summary>
        ///Retrieves information about the specified window. The function also retrieves the 32-bit (DWORD) value at the specified offset into the extra window memory.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe zero-based offset to the value to be retrieved. Valid values are in the range zero through the number of bytes of extra window memory, minus four; for example, if you specified 12 or more bytes of extra memory, a value of 8 would be an index to the third 32-bit integer. To retrieve any other value, specify one of the following values.The following values are also available when the hWnd parameter identifies a dialog box.Type: LONGIf the function succeeds, the return value is the requested value.If the function fails, the return value is zero. To get extended error information, call GetLastError.If SetWindowLong has not been called previously, GetWindowLong returns zero for values in the extra window or class memory.Reserve extra window memory by specifying a nonzero value in the cbWndExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.For an example, see Creating, Enumerating, and Sizing Child Windows.CallWindowProcConceptualGetWindowLongPtrReferenceRegisterClassExSetParentSetWindowLongWNDCLASSWindow Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetWindowLongA(nint hWnd, int nIndex);

        /// <summary>
        ///Retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra window memory.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe zero-based offset to the value to be retrieved. Valid values are in the range zero through the number of bytes of extra window memory, minus the size of a LONG_PTR. To retrieve any other value, specify one of the following values.The following values are also available when the hWnd parameter identifies a dialog box.Type: LONG_PTRIf the function succeeds, the return value is the requested value.If the function fails, the return value is zero. To get extended error information, call GetLastError.If SetWindowLong or SetWindowLongPtr has not been called previously, GetWindowLongPtr returns zero for values in the extra window or class memory.Reserve extra window memory by specifying a nonzero value in the cbWndExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.CallWindowProcConceptualReferenceRegisterClassExSetParentSetWindowLongPtrWNDCLASSEXWindow Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetWindowLongPtrA(nint hWnd, int nIndex);

        /// <summary>
        ///Retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra window memory.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe zero-based offset to the value to be retrieved. Valid values are in the range zero through the number of bytes of extra window memory, minus the size of a LONG_PTR. To retrieve any other value, specify one of the following values.The following values are also available when the hWnd parameter identifies a dialog box.Type: LONG_PTRIf the function succeeds, the return value is the requested value.If the function fails, the return value is zero. To get extended error information, call GetLastError.If SetWindowLong or SetWindowLongPtr has not been called previously, GetWindowLongPtr returns zero for values in the extra window or class memory.Reserve extra window memory by specifying a nonzero value in the cbWndExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.CallWindowProcConceptualReferenceRegisterClassExSetParentSetWindowLongPtrWNDCLASSEXWindow Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetWindowLongPtrW(nint hWnd, int nIndex);

        /// <summary>
        ///Retrieves information about the specified window. The function also retrieves the 32-bit (DWORD) value at the specified offset into the extra window memory.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe zero-based offset to the value to be retrieved. Valid values are in the range zero through the number of bytes of extra window memory, minus four; for example, if you specified 12 or more bytes of extra memory, a value of 8 would be an index to the third 32-bit integer. To retrieve any other value, specify one of the following values.The following values are also available when the hWnd parameter identifies a dialog box.Type: LONGIf the function succeeds, the return value is the requested value.If the function fails, the return value is zero. To get extended error information, call GetLastError.If SetWindowLong has not been called previously, GetWindowLong returns zero for values in the extra window or class memory.Reserve extra window memory by specifying a nonzero value in the cbWndExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.For an example, see Creating, Enumerating, and Sizing Child Windows.CallWindowProcConceptualGetWindowLongPtrReferenceRegisterClassExSetParentSetWindowLongWNDCLASSWindow Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetWindowLongW(nint hWnd, int nIndex);

        /// <summary>
        ///Retrieves the full path and file name of the module associated with the specified window handle.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window whose module file name is to be retrieved.</param>
        /// <param name="pszFileName"></param>
        /// <param name="cchFileNameMax">Type: UINTThe maximum number of characters that can be copied into the lpszFileName buffer.Type: UINTThe return value is the total number of characters copied into the buffer.Windows Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetWindowModuleFileNameA(nint hwnd, out string pszFileName, uint cchFileNameMax);

        /// <summary>
        ///Retrieves the full path and file name of the module associated with the specified window handle.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window whose module file name is to be retrieved.</param>
        /// <param name="pszFileName"></param>
        /// <param name="cchFileNameMax">Type: UINTThe maximum number of characters that can be copied into the lpszFileName buffer.Type: UINTThe return value is the total number of characters copied into the buffer.Windows Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetWindowModuleFileNameW(nint hwnd, out string pszFileName, uint cchFileNameMax);

        /// <summary>
        ///Retrieves the show state and the restored, minimized, and maximized positions of the specified window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window.</param>
        /// <param name="lpwndpl">Type: WINDOWPLACEMENT*A pointer to the WINDOWPLACEMENT structure that receives the show state and position information. Before calling GetWindowPlacement, set the length member to sizeof(WINDOWPLACEMENT). GetWindowPlacement fails if lpwndpl-> length is not set correctly.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The flags member of WINDOWPLACEMENT retrieved by this function is always zero. If the window identified by the hWnd parameter is maximized, the showCmd member is SW_SHOWMAXIMIZED. If the window is minimized, showCmd is SW_SHOWMINIMIZED. Otherwise, it is SW_SHOWNORMAL.The length member of WINDOWPLACEMENT must be set to sizeof(WINDOWPLACEMENT). If this member is not set correctly, the function returns FALSE. For additional remarks on the proper use of window placement coordinates, see WINDOWPLACEMENT.ConceptualReferenceSetWindowPlacementWINDOWPLACEMENTWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetWindowPlacement(nint hWnd, out WINDOWPLACEMENT lpwndpl);

        /// <summary>
        ///Retrieves the dimensions of the bounding rectangle of the specified window. The dimensions are given in screen coordinates that are relative to the upper-left corner of the screen.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window.</param>
        /// <param name="lpRect"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GetWindowRect(nint hWnd, out RECT lpRect);

        /// <summary>
        ///The GetWindowRgn function obtains a copy of the window region of a window. The window region of a window is set by calling the SetWindowRgn function. The window region determines the area within the window where the system permits drawing. The system does not display any portion of a window that lies outside of the window region
        /// </summary>
        /// <param name="hWnd">Handle to the window whose window region is to be obtained.</param>
        /// <param name="hRgn">Handle to the region which will be modified to represent the window region.The return value specifies the type of the region that the function obtains. It can be one of the following values.The coordinates of a window's window region are relative to the upper-left corner of the window, not the client area of the window.To set the window region of a window, call the SetWindowRgn function.The following code shows how you pass in the handle of an existing region.Painting and Drawing FunctionsPainting and Drawing OverviewSetWindowRgn</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetWindowRgn(nint hWnd, nint hRgn);

        /// <summary>
        ///The GetWindowRgnBox function retrieves the dimensions of the tightest bounding rectangle for the window region of a window.
        /// </summary>
        /// <param name="hWnd">Handle to the window.</param>
        /// <param name="lprc"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetWindowRgnBox(nint hWnd, out RECT lprc);

        /// <summary>
        ///Copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another application.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window or control containing the text.</param>
        /// <param name="lpString"></param>
        /// <param name="nMaxCount">Type: intThe maximum number of characters to copy to the buffer, including the null character. If the text exceeds this limit, it is truncated.Type: intIf the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null character. If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero. To get extended error information, call GetLastError.This function cannot retrieve the text of an edit control in another application.If the target window is owned by the current process, GetWindowText causes a WM_GETTEXT message to be sent to the specified window or control. If the target window is owned by another process and has a caption, GetWindowText retrieves the window caption text. If the window does not have a caption, the return value is a null string. This behavior is by design. It allows applications to call GetWindowText without becoming unresponsive if the process that owns the target window is not responding. However, if the target window is not responding and it belongs to the calling application, GetWindowText will cause the calling application to become unresponsive.To retrieve the text of a control in another process, send a WM_GETTEXT message directly instead of calling GetWindowText.The following example code demonstrates a call to GetWindowTextA.To see this example in context, see Sending a Message.ConceptualGetWindowTextLengthReferenceSetWindowTextWM_GETTEXTWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetWindowTextA(nint hWnd, out string lpString, int nMaxCount);

        /// <summary>
        ///Retrieves the length, in characters, of the specified window's title bar text (if the window has a title bar). If the specified window is a control, the function retrieves the length of the text within the control. However, GetWindowTextLength cannot retrieve the length of the text of an edit control in another application.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window or control.Type: intIf the function succeeds, the return value is the length, in characters, of the text. Under certain conditions, this value might be greater than the length of the text (see Remarks).If the window has no text, the return value is zero.Function failure is indicated by a return value of zero and a GetLastError result that is nonzero.If the target window is owned by the current process, GetWindowTextLength causes a WM_GETTEXTLENGTH message to be sent to the specified window or control.Under certain conditions, the GetWindowTextLength function may return a value that is larger than the actual length of the text. This occurs with certain mixtures of ANSI and Unicode, and is due to the system allowing for the possible existence of double-byte character set (DBCS) characters within the text. The return value, however, will always be at least as large as the actual length of the text; you can thus always use it to guide buffer allocation. This behavior can occur when an application uses both ANSI functions and common dialogs, which use Unicode. It can also occur when an application uses the ANSI version of GetWindowTextLength with a window whose window procedure is Unicode, or the Unicode version of GetWindowTextLength with a window whose window procedure is ANSI. For more information on ANSI and ANSI functions, see Conventions for Function Prototypes.To obtain the exact length of the text, use the WM_GETTEXT, LB_GETTEXT, or CB_GETLBTEXT messages, or the GetWindowText function.CB_GETLBTEXTConceptualGetWindowTextLB_GETTEXTOther ResourcesReferenceSetWindowTextWM_GETTEXTWM_GETTEXTLENGTHWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetWindowTextLengthA(nint hWnd);

        /// <summary>
        ///Retrieves the length, in characters, of the specified window's title bar text (if the window has a title bar). If the specified window is a control, the function retrieves the length of the text within the control. However, GetWindowTextLength cannot retrieve the length of the text of an edit control in another application.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window or control.Type: intIf the function succeeds, the return value is the length, in characters, of the text. Under certain conditions, this value might be greater than the length of the text (see Remarks).If the window has no text, the return value is zero.Function failure is indicated by a return value of zero and a GetLastError result that is nonzero.If the target window is owned by the current process, GetWindowTextLength causes a WM_GETTEXTLENGTH message to be sent to the specified window or control.Under certain conditions, the GetWindowTextLength function may return a value that is larger than the actual length of the text. This occurs with certain mixtures of ANSI and Unicode, and is due to the system allowing for the possible existence of double-byte character set (DBCS) characters within the text. The return value, however, will always be at least as large as the actual length of the text; you can thus always use it to guide buffer allocation. This behavior can occur when an application uses both ANSI functions and common dialogs, which use Unicode. It can also occur when an application uses the ANSI version of GetWindowTextLength with a window whose window procedure is Unicode, or the Unicode version of GetWindowTextLength with a window whose window procedure is ANSI. For more information on ANSI and ANSI functions, see Conventions for Function Prototypes.To obtain the exact length of the text, use the WM_GETTEXT, LB_GETTEXT, or CB_GETLBTEXT messages, or the GetWindowText function.CB_GETLBTEXTConceptualGetWindowTextLB_GETTEXTOther ResourcesReferenceSetWindowTextWM_GETTEXTWM_GETTEXTLENGTHWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetWindowTextLengthW(nint hWnd);

        /// <summary>
        ///Copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another application.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window or control containing the text.</param>
        /// <param name="lpString"></param>
        /// <param name="nMaxCount">Type: intThe maximum number of characters to copy to the buffer, including the null character. If the text exceeds this limit, it is truncated.Type: intIf the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null character. If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero. To get extended error information, call GetLastError.This function cannot retrieve the text of an edit control in another application.If the target window is owned by the current process, GetWindowText causes a WM_GETTEXT message to be sent to the specified window or control. If the target window is owned by another process and has a caption, GetWindowText retrieves the window caption text. If the window does not have a caption, the return value is a null string. This behavior is by design. It allows applications to call GetWindowText without becoming unresponsive if the process that owns the target window is not responding. However, if the target window is not responding and it belongs to the calling application, GetWindowText will cause the calling application to become unresponsive.To retrieve the text of a control in another process, send a WM_GETTEXT message directly instead of calling GetWindowText.For an example, see Sending a Message.ConceptualGetWindowTextLengthReferenceSetWindowTextWM_GETTEXTWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int GetWindowTextW(nint hWnd, out string lpString, int nMaxCount);

        /// <summary>
        ///Retrieves the identifier of the thread that created the specified window and, optionally, the identifier of the process that created the window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window.</param>
        /// <param name="lpdwProcessId"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint GetWindowThreadProcessId(nint hWnd, out uint lpdwProcessId);

        /// <summary>
        ///The GrayString function draws gray text at the specified location. The function draws the text by copying it into a memory bitmap, graying the bitmap, and then copying the bitmap to the screen. The function grays the text regardless of the selected brush and background. GrayString uses the font currently selected for the specified device context.
        /// </summary>
        /// <param name="hDC">A handle to the device context.</param>
        /// <param name="hBrush">A handle to the brush to be used for graying. If this parameter is NULL, the text is grayed with the same brush that was used to draw window text.</param>
        /// <param name="lpOutputFunc">A pointer to the application-defined function that will draw the string, or, if TextOut is to be used to draw the string, it is a NULL pointer. For details, see the OutputProc callback function.</param>
        /// <param name="lpData">A pointer to data to be passed to the output function. If the lpOutputFunc parameter is NULL, lpData must be a pointer to the string to be output.</param>
        /// <param name="nCount">The number of characters to be output. If the nCount parameter is zero, GrayString calculates the length of the string (assuming lpData is a pointer to the string). If nCount is 1 and the function pointed to by lpOutputFunc returns FALSE, the image is shown but not grayed.</param>
        /// <param name="X">The device x-coordinate of the starting position of the rectangle that encloses the string.</param>
        /// <param name="Y">The device y-coordinate of the starting position of the rectangle that encloses the string.</param>
        /// <param name="nWidth">The width, in device units, of the rectangle that encloses the string. If this parameter is zero, GrayString calculates the width of the area, assuming lpData is a pointer to the string.</param>
        /// <param name="nHeight">The height, in device units, of the rectangle that encloses the string. If this parameter is zero, GrayString calculates the height of the area, assuming lpData is a pointer to the string.If the string is drawn, the return value is nonzero.If either the TextOut function or the application-defined output function returned zero, or there was insufficient memory to create a memory bitmap for graying, the return value is zero.Without calling GrayString, an application can draw grayed strings on devices that support a solid gray color. The system color COLOR_GRAYTEXT is the solid-gray system color used to draw disabled text. The application can call the GetSysColor function to retrieve the color value of COLOR_GRAYTEXT. If the color is other than zero (black), the application can call the SetTextColor function to set the text color to the color value and then draw the string directly. If the retrieved color is black, the application must call GrayString to gray the text.DrawTextGetSysColorOutputProcPainting and Drawing FunctionsPainting and Drawing OverviewSetTextColorTabbedTextOutTextOut</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GrayStringA(nint hDC, nint hBrush, GRAYSTRINGPROC lpOutputFunc, nint lpData, int nCount, int X, int Y, int nWidth, int nHeight);

        /// <summary>
        ///The GrayString function draws gray text at the specified location. The function draws the text by copying it into a memory bitmap, graying the bitmap, and then copying the bitmap to the screen. The function grays the text regardless of the selected brush and background. GrayString uses the font currently selected for the specified device context.
        /// </summary>
        /// <param name="hDC">A handle to the device context.</param>
        /// <param name="hBrush">A handle to the brush to be used for graying. If this parameter is NULL, the text is grayed with the same brush that was used to draw window text.</param>
        /// <param name="lpOutputFunc">A pointer to the application-defined function that will draw the string, or, if TextOut is to be used to draw the string, it is a NULL pointer. For details, see the OutputProc callback function.</param>
        /// <param name="lpData">A pointer to data to be passed to the output function. If the lpOutputFunc parameter is NULL, lpData must be a pointer to the string to be output.</param>
        /// <param name="nCount">The number of characters to be output. If the nCount parameter is zero, GrayString calculates the length of the string (assuming lpData is a pointer to the string). If nCount is 1 and the function pointed to by lpOutputFunc returns FALSE, the image is shown but not grayed.</param>
        /// <param name="X">The device x-coordinate of the starting position of the rectangle that encloses the string.</param>
        /// <param name="Y">The device y-coordinate of the starting position of the rectangle that encloses the string.</param>
        /// <param name="nWidth">The width, in device units, of the rectangle that encloses the string. If this parameter is zero, GrayString calculates the width of the area, assuming lpData is a pointer to the string.</param>
        /// <param name="nHeight">The height, in device units, of the rectangle that encloses the string. If this parameter is zero, GrayString calculates the height of the area, assuming lpData is a pointer to the string.If the string is drawn, the return value is nonzero.If either the TextOut function or the application-defined output function returned zero, or there was insufficient memory to create a memory bitmap for graying, the return value is zero.Without calling GrayString, an application can draw grayed strings on devices that support a solid gray color. The system color COLOR_GRAYTEXT is the solid-gray system color used to draw disabled text. The application can call the GetSysColor function to retrieve the color value of COLOR_GRAYTEXT. If the color is other than zero (black), the application can call the SetTextColor function to set the text color to the color value and then draw the string directly. If the retrieved color is black, the application must call GrayString to gray the text.DrawTextGetSysColorOutputProcPainting and Drawing FunctionsPainting and Drawing OverviewSetTextColorTabbedTextOutTextOut</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool GrayStringW(nint hDC, nint hBrush, GRAYSTRINGPROC lpOutputFunc, nint lpData, int nCount, int X, int Y, int nWidth, int nHeight);

        /// <summary>
        ///Removes the caret from the screen. Hiding a caret does not destroy its current shape or invalidate the insertion point.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool HideCaret(nint hWnd);

        /// <summary>
        ///Adds or removes highlighting from an item in a menu bar.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window that contains the menu.</param>
        /// <param name="hMenu">Type: HMENUA handle to the menu bar that contains the item.</param>
        /// <param name="uIDHiliteItem">Type: UINTThe menu item. This parameter is either the identifier of the menu item or the offset of the menu item in the menu bar, depending on the value of the uHilite parameter.</param>
        /// <param name="uHilite">Type: UINTControls the interpretation of the uItemHilite parameter and indicates whether the menu item is highlighted. This parameter must be a combination of either MF_BYCOMMAND or MF_BYPOSITION and MF_HILITE or MF_UNHILITE.Type: BOOLIf the menu item is set to the specified highlight state, the return value is nonzero.If the menu item is not set to the specified highlight state, the return value is zero.The MF_HILITE and MF_UNHILITE flags can be used only with the HiliteMenuItem function; they cannot be used with the ModifyMenu function.ConceptualMenusModifyMenuReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool HiliteMenuItem(nint hWnd, nint hMenu, uint uIDHiliteItem, uint uHilite);

        /// <summary>
        ///The InflateRect function increases or decreases the width and height of the specified rectangle. The InflateRect function adds -dx units to the left end and dx to the right end of the rectangle and -dy units to the top and dy to the bottom. The dx and dy parameters are signed values; positive values increase the width and height, and negative values decrease them.
        /// </summary>
        /// <param name="lprc">A pointer to the RECT structure that increases or decreases in size.</param>
        /// <param name="dx">The amount to increase or decrease the rectangle width. This parameter must be negative to decrease the width.</param>
        /// <param name="dy">The amount to increase or decrease the rectangle height. This parameter must be negative to decrease the height.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure.IntersectRectOffsetRectRECTRectangle FunctionsRectangles OverviewUnionRect</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InflateRect(out RECT lprc, int dx, int dy);

        /// <summary>
        ///Causes a specified window to inherit the monitor of another window.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InheritWindowMonitor(nint hwnd, nint hwndInherit);

        /// <summary>
        ///Configures the touch injection context for the calling application and initializes the maximum number of simultaneous contacts that the app can inject.
        /// </summary>
        /// <param name="maxCount">The maximum number of touch contacts.The maxCount parameter must be greater than 0 and less than or equal to MAX_TOUCH_COUNT (256) as defined in winuser.h.</param>
        /// <param name="dwMode">The contact visualization mode.The dwMode parameter must be TOUCH_FEEDBACK_DEFAULT, TOUCH_FEEDBACK_INDIRECT, or TOUCH_FEEDBACK_NONE.If the function succeeds, the return value is TRUE.If the function fails, the return value is FALSE. To get extended error information, call GetLastError.If TOUCH_FEEDBACK_DEFAULT is set, the injected touch feedback may get suppressed by the end-user settings in the Pen and Touch control panel.If TOUCH_FEEDBACK_INDIRECT is set, the injected touch feedback overrides the end-user settings in the Pen and Touch control panel.If TOUCH_FEEDBACK_INDIRECT or TOUCH_FEEDBACK_NONE are set, touch feedback provided by applications and controls may not be affected.Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InitializeTouchInjection(int maxCount, uint dwMode);

        /// <summary>
        ///Simulates pointer input (pen or touch).
        /// </summary>
        /// <param name="device"></param>
        /// <param name="pointerInfo">An array of POINTER_TYPE_INFO structures represneting the injected pointers.The type must match the pointerType parameter of the CreateSyntheticPointerDevice call that created the injection device.The ptPixelLocation for each POINTER_TYPE_INFO is specified relative to top left of the virtual screen:</param>
        /// <param name="count">The number of contacts.For PT_TOUCH this value must be greater than 0 and less than or equal to MAX_TOUCH_COUNT.For PT_PEN this value must be 1.If this function succeeds, it returns TRUE.Otherwise, it returns FALSE. To retrieve extended error information, call the GetLastError function.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InjectSyntheticPointerInput(EMRSETDIBITSTODEVICE device, POINTER_PEN_INFO pointerInfo, int count);

        /// <summary>
        ///Simulates touch input.
        /// </summary>
        /// <param name="count">The size of the array in contacts.The maximum value for count is specified by the maxCount parameter of the InitializeTouchInjection function.</param>
        /// <param name="contacts">Array of POINTER_TOUCH_INFO structures that represents all contacts on the desktop. The screen coordinates of each contact must be within the bounds of the desktop.If the function succeeds, the return value is non-zero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The injected input is sent to the desktop of the session where the injection process is running.There are two input states for touch input injection (interactive and hover) that are indicated by the following combinations of pointerFlags in contacts:The following diagram demonstrates a touch injection sequence that starts with a hover state, transitions to interactive, and concludes with hover.For press and hold gestures, multiple frames must be sent to ensure input is not cancelled. For a press and hold at point (x,y), send WM_POINTERDOWN at point (x,y) followed by WM_POINTERUPDATE messages at point(x,y).Listen for WM_DISPLAYCHANGE to handle changes to display resolution and orientation and manage screen coordinate updates. All active contacts are cancelled when a WM_DISPLAYCHANGE is received.Cancel individual contacts by setting POINTER_FLAG_CANCELED with POINTER_FLAG_UP or POINTER_FLAG_UPDATE. Cancelling touch injection without POINTER_FLAG_UP or POINTER_FLAG_UPDATE invalidates the injection.When POINTER_FLAG_UP is set, ptPixelLocation of POINTER_INFO should be the same as the value of the previous touch injection frame with POINTER_FLAG_UPDATE. Otherwise, the injection fails with ERROR_INVALID_PARAMETER and all active injection contacts are cancelled. The system modifies the ptPixelLocation of the WM_POINTERUP event as it cancels the injection.The input timestamp can be specified in either the dwTime or PerformanceCount field of POINTER_INFO. The value cannot be more recent than the current tick count or QueryPerformanceCounter value of the injection thread. Once a frame is injected with a timestamp, all subsequent frames must include a timestamp until all contacts in the frame go to the UP state. The custom timestamp value must be provided for the first element in the contacts array. The timestamp values after the first element are ignored. The custom timestamp value must increment in every injection frame.When a PerformanceCount field is specified, the timestamp is converted into current time in .1 millisecond resolution upon actual injection. If a custom PerformanceCount resulted in the same .1 millisecond window from previous injection, the API will return an error (ERROR_NOT_READY) and will not inject the data. While injection is not immediately invalidated by the error, next successful injection must have PerformanceCount value that is at least 0.1 milliseconds apart from the previously successful injection. Similarly a custom dwTime value must be at least 1 millisecond apart if the field was used.If both dwTime and PerformanceCount are specified in the injection parameter, InjectTouchInput fails with an Error Code (ERROR_INVALID_PARAMETER). Once the injection application starts with either a dwTime or PerformanceCount parameter, the timestamp field must be filled correctly. Injection cannot switch the custom timestamp field from one to another once the injection sequence has started.When neither dwTime or PerformanceCount values are specified, the InjectTouchInput allocates the timestamp based on the timing of the API call. If the calls are less than 0.1 millisecond apart, the API may return an error (ERROR_NOT_READY). The error will not invalidate the input immediately, but the injection application needs to retry the same frame again to ensure injection is successful.Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InjectTouchInput(int count, POINTER_TOUCH_INFO contacts);

        /// <summary>
        ///Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or a different process) by a call to the SendMessage function.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InSendMessage();

        /// <summary>
        ///Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or a different process).
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint InSendMessageEx(nint lpReserved);

        /// <summary>
        ///Inserts a new menu item into a menu, moving other items down the menu.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu to be changed.</param>
        /// <param name="uPosition">Type: UINTThe menu item before which the new menu item is to be inserted, as determined by the uFlags parameter.</param>
        /// <param name="uFlags">Type: UINTControls the interpretation of the uPosition parameter and the content, appearance, and behavior of the new menu item. This parameter must include one of the following required values.The parameter must also include at least one of the following values.</param>
        /// <param name="uIDNewItem">Type: UINT_PTRThe identifier of the new menu item or, if the uFlags parameter has the MF_POPUP flag set, a handle to the drop-down menu or submenu.</param>
        /// <param name="lpNewItem"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InsertMenuA(nint hMenu, uint uPosition, uint uFlags, nint uIDNewItem, string lpNewItem);

        /// <summary>
        ///Inserts a new menu item at the specified position in a menu.
        /// </summary>
        /// <param name="hmenu">Type: HMENUA handle to the menu in which the new menu item is inserted.</param>
        /// <param name="item">Type: UINTThe identifier or position of the menu item before which to insert the new item. The meaning of this parameter depends on the value of fByPosition.</param>
        /// <param name="fByPosition">Type: BOOLControls the meaning of item. If this parameter is FALSE, item is a menu item identifier. Otherwise, it is a menu item position. See Accessing Menu Items Programmatically for more information.</param>
        /// <param name="lpmi">Type: LPCMENUITEMINFOA pointer to a MENUITEMINFO structure that contains information about the new menu item.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the WM_MENUCHAR message. See Owner-Drawn Menus and the WM_MENUCHAR Message for more information.For an example, see Example of Menu-Item Bitmaps.ConceptualDrawMenuBarMENUITEMINFOMenusReference</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InsertMenuItemA(nint hmenu, uint item, bool fByPosition, MENUITEMINFOA lpmi);

        /// <summary>
        ///Inserts a new menu item at the specified position in a menu.
        /// </summary>
        /// <param name="hmenu">Type: HMENUA handle to the menu in which the new menu item is inserted.</param>
        /// <param name="item">Type: UINTThe identifier or position of the menu item before which to insert the new item. The meaning of this parameter depends on the value of fByPosition.</param>
        /// <param name="fByPosition">Type: BOOLControls the meaning of item. If this parameter is FALSE, item is a menu item identifier. Otherwise, it is a menu item position. See Accessing Menu Items Programmatically for more information.</param>
        /// <param name="lpmi">Type: LPCMENUITEMINFOA pointer to a MENUITEMINFO structure that contains information about the new menu item.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the WM_MENUCHAR message. See Owner-Drawn Menus and the WM_MENUCHAR Message for more information.For an example, see Example of Menu-Item Bitmaps.ConceptualDrawMenuBarMENUITEMINFOMenusReference</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InsertMenuItemW(nint hmenu, uint item, bool fByPosition, MENUITEMINFOW lpmi);

        /// <summary>
        ///Inserts a new menu item into a menu, moving other items down the menu.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu to be changed.</param>
        /// <param name="uPosition">Type: UINTThe menu item before which the new menu item is to be inserted, as determined by the uFlags parameter.</param>
        /// <param name="uFlags">Type: UINTControls the interpretation of the uPosition parameter and the content, appearance, and behavior of the new menu item. This parameter must include one of the following required values.The parameter must also include at least one of the following values.</param>
        /// <param name="uIDNewItem">Type: UINT_PTRThe identifier of the new menu item or, if the uFlags parameter has the MF_POPUP flag set, a handle to the drop-down menu or submenu.</param>
        /// <param name="lpNewItem"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InsertMenuW(nint hMenu, uint uPosition, uint uFlags, nint uIDNewItem, string lpNewItem);

        /// <summary>
        ///[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window or control containing the text.</param>
        /// <param name="pString"></param>
        /// <param name="cchMaxCount">Type: intThe maximum number of characters to be copied to the buffer, including the null character. If the text exceeds this limit, it is truncated.Type: intIf the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null character.If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero. To get extended error information, call GetLastError.This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server 2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.ConceptualGetWindowTextGetWindowTextLengthReferenceSetWindowTextUsing Messages and Message QueuesWM_GETTEXTWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int InternalGetWindowText(nint hWnd, out string pString, int cchMaxCount);

        /// <summary>
        ///The IntersectRect function calculates the intersection of two source rectangles and places the coordinates of the intersection rectangle into the destination rectangle. If the source rectangles do not intersect, an empty rectangle (in which all coordinates are set to zero) is placed into the destination rectangle.
        /// </summary>
        /// <param name="lprcDst"></param>
        /// <param name="lprcSrc1">A pointer to the RECT structure that contains the first source rectangle.</param>
        /// <param name="lprcSrc2">A pointer to the RECT structure that contains the second source rectangle.If the rectangles intersect, the return value is nonzero.If the rectangles do not intersect, the return value is zero.Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure.For an example, see Using Rectangles.InflateRectOffsetRectRECTRectangle FunctionsRectangles OverviewUnionRect</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IntersectRect(out RECT lprcDst, RECT lprcSrc1, RECT lprcSrc2);

        /// <summary>
        ///The InvalidateRect function adds a rectangle to the specified window's update region. The update region represents the portion of the window's client area that must be redrawn.
        /// </summary>
        /// <param name="hWnd">A handle to the window whose update region has changed. If this parameter is NULL, the system invalidates and redraws all windows, not just the windows for this application, and sends the WM_ERASEBKGND and WM_NCPAINT messages before the function returns. Setting this parameter to NULL is not recommended.</param>
        /// <param name="lpRect">A pointer to a RECT structure that contains the client coordinates of the rectangle to be added to the update region. If this parameter is NULL, the entire client area is added to the update region.</param>
        /// <param name="bErase">Specifies whether the background within the update region is to be erased when the update region is processed. If this parameter is TRUE, the background is erased when the BeginPaint function is called. If this parameter is FALSE, the background remains unchanged.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.The invalidated areas accumulate in the update region until the region is processed when the next WM_PAINT message occurs or until the region is validated by using the ValidateRect or ValidateRgn function.The system sends a WM_PAINT message to a window whenever its update region is not empty and there are no other messages in the application queue for that window.If the bErase parameter is TRUE for any part of the update region, the background is erased in the entire region, not just in the specified part.For an example, see Invalidating the Client Area.BeginPaintInvalidateRgnPainting and Drawing FunctionsPainting and Drawing OverviewRECTValidateRectValidateRgnWM_ERASEBKGNDWM_NCPAINTWM_PAINT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InvalidateRect(nint hWnd, RECT lpRect, bool bErase);

        /// <summary>
        ///The InvalidateRgn function invalidates the client area within the specified region by adding it to the current update region of a window. The invalidated region, along with all other areas in the update region, is marked for painting when the next WM_PAINT message occurs.
        /// </summary>
        /// <param name="hWnd">A handle to the window with an update region that is to be modified.</param>
        /// <param name="hRgn">A handle to the region to be added to the update region. The region is assumed to have client coordinates. If this parameter is NULL, the entire client area is added to the update region.</param>
        /// <param name="bErase">Specifies whether the background within the update region should be erased when the update region is processed. If this parameter is TRUE, the background is erased when the BeginPaint function is called. If the parameter is FALSE, the background remains unchanged.The return value is always nonzero.Invalidated areas accumulate in the update region until the next WM_PAINT message is processed or until the region is validated by using the ValidateRect or ValidateRgn function.The system sends a WM_PAINT message to a window whenever its update region is not empty and there are no other messages in the application queue for that window.The specified region must have been created by using one of the region functions.If the bErase parameter is TRUE for any part of the update region, the background in the entire region is erased, not just in the specified part.BeginPaintInvalidateRectPainting and Drawing FunctionsPainting and Drawing OverviewValidateRectValidateRgnWM_PAINT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InvalidateRgn(nint hWnd, nint hRgn, bool bErase);

        /// <summary>
        ///The InvertRect function inverts a rectangle in a window by performing a logical NOT operation on the color values for each pixel in the rectangle's interior.
        /// </summary>
        /// <param name="hDC">A handle to the device context.</param>
        /// <param name="lprc">A pointer to a RECT structure that contains the logical coordinates of the rectangle to be inverted.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.On monochrome screens, InvertRect makes white pixels black and black pixels white. On color screens, the inversion depends on how colors are generated for the screen. Calling InvertRect twice for the same rectangle restores the display to its previous colors.FillRectFilled Shape FunctionsFilled Shapes OverviewRECT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool InvertRect(nint hDC, RECT lprc);

        /// <summary>
        ///Determines whether a character is an alphabetical character. This determination is based on the semantics of the language selected by the user during setup or through Control Panel.
        /// </summary>
        /// <param name="ch">Type: TCHARThe character to be tested.Type: BOOLIf the character is alphabetical, the return value is nonzero.If the character is not alphabetical, the return value is zero. To get extended error information, call GetLastError.ConceptualIsCharAlphaNumericReferenceStrings</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsCharAlphaA(char ch);

        /// <summary>
        ///Determines whether a character is either an alphabetical or a numeric character. This determination is based on the semantics of the language selected by the user during setup or through Control Panel.
        /// </summary>
        /// <param name="ch">Type: TCHARThe character to be tested.Type: BOOLIf the character is alphanumeric, the return value is nonzero.If the character is not alphanumeric, the return value is zero. To get extended error information, call GetLastError.ConceptualIsCharAlphaReferenceStrings</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsCharAlphaNumericA(char ch);

        /// <summary>
        ///Determines whether a character is either an alphabetical or a numeric character. This determination is based on the semantics of the language selected by the user during setup or through Control Panel.
        /// </summary>
        /// <param name="ch">Type: TCHARThe character to be tested.Type: BOOLIf the character is alphanumeric, the return value is nonzero.If the character is not alphanumeric, the return value is zero. To get extended error information, call GetLastError.ConceptualIsCharAlphaReferenceStrings</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsCharAlphaNumericW(StringBuilder ch);

        /// <summary>
        ///Determines whether a character is an alphabetical character. This determination is based on the semantics of the language selected by the user during setup or through Control Panel.
        /// </summary>
        /// <param name="ch">Type: TCHARThe character to be tested.Type: BOOLIf the character is alphabetical, the return value is nonzero.If the character is not alphabetical, the return value is zero. To get extended error information, call GetLastError.ConceptualIsCharAlphaNumericReferenceStrings</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsCharAlphaW(StringBuilder ch);

        /// <summary>
        ///Determines whether a character is lowercase. This determination is based on the semantics of the language selected by the user during setup or through Control Panel.
        /// </summary>
        /// <param name="ch">Type: TCHARThe character to be tested.Type: BOOLIf the character is lowercase, the return value is nonzero.If the character is not lowercase, the return value is zero. To get extended error information, call GetLastError.ConceptualIsCharUpperReferenceStrings</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsCharLowerA(char ch);

        /// <summary>
        ///Determines whether a character is uppercase. This determination is based on the semantics of the language selected by the user during setup or through Control Panel.
        /// </summary>
        /// <param name="ch">Type: TCHARThe character to be tested.Type: BOOLIf the character is uppercase, the return value is nonzero.If the character is not uppercase, the return value is zero. To get extended error information, call GetLastError.ConceptualIsCharLowerReferenceStrings</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsCharUpperA(char ch);

        /// <summary>
        ///Determines whether a character is uppercase. This determination is based on the semantics of the language selected by the user during setup or through Control Panel.
        /// </summary>
        /// <param name="ch">Type: TCHARThe character to be tested.Type: BOOLIf the character is uppercase, the return value is nonzero.If the character is not uppercase, the return value is zero. To get extended error information, call GetLastError.ConceptualIsCharLowerReferenceStrings</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsCharUpperW(StringBuilder ch);

        /// <summary>
        ///Determines whether a window is a child window or descendant window of a specified parent window. A child window is the direct descendant of a specified parent window if that parent window is in the chain of parent windows; the chain of parent windows leads from the original overlapped or pop-up window to the child window.
        /// </summary>
        /// <param name="hWndParent">Type: HWNDA handle to the parent window.</param>
        /// <param name="hWnd">Type: HWNDA handle to the window to be tested.Type: BOOLIf the window is a child or descendant window of the specified parent window, the return value is nonzero.If the window is not a child or descendant window of the specified parent window, the return value is zero.ConceptualIsWindowReferenceSetParentWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsChild(nint hWndParent, nint hWnd);

        /// <summary>
        ///Determines whether the clipboard contains data in the specified format.
        /// </summary>
        /// <param name="format">Type: UINTA standard or registered clipboard format. For a description of the standard clipboard formats, see Standard Clipboard Formats .Type: BOOLIf the clipboard format is available, the return value is nonzero.If the clipboard format is not available, the return value is zero. To get extended error information, call GetLastError.Typically, an application that recognizes only one clipboard format would call this function when processing the WM_INITMENU or WM_INITMENUPOPUP message. The application would then enable or disable the Paste menu item, depending on the return value. Applications that recognize more than one clipboard format should use the GetPriorityClipboardFormat function for this purpose.For an example, see Pasting Information from the Clipboard.ClipboardConceptualCountClipboardFormatsEnumClipboardFormatsGetPriorityClipboardFormatReferenceRegisterClipboardFormatWM_INITMENUWM_INITMENUPOPUP</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsClipboardFormatAvailable(uint format);

        /// <summary>
        ///Determines whether a message is intended for the specified dialog box and, if it is, processes the message.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box.</param>
        /// <param name="lpMsg">Type: LPMSGA pointer to an MSG structure that contains the message to be checked.Type: BOOLIf the message has been processed, the return value is nonzero.If the message has not been processed, the return value is zero.Although the IsDialogMessage function is intended for modeless dialog boxes, you can use it with any window that contains controls, enabling the windows to provide the same keyboard selection as is used in a dialog box.When IsDialogMessage processes a message, it checks for keyboard messages and converts them into selections for the corresponding dialog box. For example, the TAB key, when pressed, selects the next control or group of controls, and the DOWN ARROW key, when pressed, selects the next control in a group.Because the IsDialogMessage function performs all necessary translating and dispatching of messages, a message processed by IsDialogMessage must not be passed to the TranslateMessage or DispatchMessage function.IsDialogMessage sends WM_GETDLGCODE messages to the dialog box procedure to determine which keys should be processed.IsDialogMessage can send DM_GETDEFID and DM_SETDEFID messages to the window. These messages are defined in the Winuser.h header file as WM_USER and WM_USER + 1, so conflicts are possible with application-defined messages having the same values.ConceptualDM_GETDEFIDDM_SETDEFIDDialog BoxesDispatchMessageMSGReferenceTranslateMessageWM_GETDLGCODEWM_USER</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsDialogMessageA(nint hDlg, MSG lpMsg);

        /// <summary>
        ///Determines whether a message is intended for the specified dialog box and, if it is, processes the message.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box.</param>
        /// <param name="lpMsg">Type: LPMSGA pointer to an MSG structure that contains the message to be checked.Type: BOOLIf the message has been processed, the return value is nonzero.If the message has not been processed, the return value is zero.Although the IsDialogMessage function is intended for modeless dialog boxes, you can use it with any window that contains controls, enabling the windows to provide the same keyboard selection as is used in a dialog box.When IsDialogMessage processes a message, it checks for keyboard messages and converts them into selections for the corresponding dialog box. For example, the TAB key, when pressed, selects the next control or group of controls, and the DOWN ARROW key, when pressed, selects the next control in a group.Because the IsDialogMessage function performs all necessary translating and dispatching of messages, a message processed by IsDialogMessage must not be passed to the TranslateMessage or DispatchMessage function.IsDialogMessage sends WM_GETDLGCODE messages to the dialog box procedure to determine which keys should be processed.IsDialogMessage can send DM_GETDEFID and DM_SETDEFID messages to the window. These messages are defined in the Winuser.h header file as WM_USER and WM_USER + 1, so conflicts are possible with application-defined messages having the same values.ConceptualDM_GETDEFIDDM_SETDEFIDDialog BoxesDispatchMessageMSGReferenceTranslateMessageWM_GETDLGCODEWM_USER</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsDialogMessageW(nint hDlg, MSG lpMsg);

        /// <summary>
        ///The IsDlgButtonChecked function determines whether a button control is checked or whether a three-state button control is checked, unchecked, or indeterminate.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the button control.</param>
        /// <param name="nIDButton">Type: intThe identifier of the button control.Type: UINTThe return value from a button created with the BS_AUTOCHECKBOX, BS_AUTORADIOBUTTON, BS_AUTO3STATE, BS_CHECKBOX, BS_RADIOBUTTON, or BS_3STATE styles can be one of the values in the following table. If the button has any other style, the return value is zero.The IsDlgButtonChecked function sends a BM_GETCHECK message to the specified button control.For an example, see the section titled "Creating a Modeless Dialog Box" in Using Dialog Boxes.CheckDlgButton</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint IsDlgButtonChecked(nint hDlg, int nIDButton);

        /// <summary>
        ///Determines whether the calling thread is already a GUI thread. It can also optionally convert the thread to a GUI thread.
        /// </summary>
        /// <param name="bConvert">Type: BOOLIf TRUE and the thread is not a GUI thread, convert the thread to a GUI thread.Type: BOOLThe function returns a nonzero value in the following situations:If bConvert is TRUE and the function cannot successfully convert the thread to a GUI thread, IsGUIThread returns ERROR_NOT_ENOUGH_MEMORY.Windows Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsGUIThread(bool bConvert);

        /// <summary>
        ///[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window to be tested.Type: BOOLThe return value is TRUE if the window stops responding; otherwise, it is FALSE. Ghost windows always return TRUE.The Windows timeout criteria of 5 seconds is subject to change.This function was not included in the SDK headers and libraries until Windows XP Service Pack 1 (SP1) and Windows Server 2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.ConceptualIsWindowReferenceWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsHungAppWindow(nint hwnd);

        /// <summary>
        ///Determines whether the specified window is minimized (iconic).
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to be tested.Type: BOOLIf the window is iconic, the return value is nonzero.If the window is not iconic, the return value is zero.ConceptualIsZoomedReferenceWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsIconic(nint hWnd);

        /// <summary>
        ///Determines whether the process belongs to a Windows Store app.
        /// </summary>
        /// <param name="hProcess">Target process handle.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsImmersiveProcess(nint hProcess);

        /// <summary>
        ///Determines whether a handle is a menu handle.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to be tested.Type: BOOLIf the handle is a menu handle, the return value is nonzero.If the handle is not a menu handle, the return value is zero.Menus</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsMenu(nint hMenu);

        /// <summary>
        ///Indicates whether EnableMouseInPointer is set for the mouse to act as a pointer input device and send WM_POINTER messages.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsMouseInPointerEnabled();

        /// <summary>
        ///
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsProcessDPIAware();

        /// <summary>
        ///The IsRectEmpty function determines whether the specified rectangle is empty. An empty rectangle is one that has no area; that is, the coordinate of the right side is less than or equal to the coordinate of the left side, or the coordinate of the bottom side is less than or equal to the coordinate of the top side.
        /// </summary>
        /// <param name="lprc">Pointer to a RECT structure that contains the logical coordinates of the rectangle.If the rectangle is empty, the return value is nonzero.If the rectangle is not empty, the return value is zero.Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure.For an example, see Using Rectangles.EqualRectPtInRectRECTRectangle FunctionsRectangles Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsRectEmpty(RECT lprc);

        /// <summary>
        ///Checks whether a specified window is touch-capable and, optionally, retrieves the modifier flags set for the window's touch capability.
        /// </summary>
        /// <param name="hwnd">The handle of the window. The function fails with ERROR_ACCESS_DENIED if the calling thread is not on the same desktop as the specified window.</param>
        /// <param name="pulFlags"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsTouchWindow(nint hwnd, out uint pulFlags);

        /// <summary>
        ///Determines if a specified DPI_AWARENESS_CONTEXT is valid and supported by the current system.
        /// </summary>
        /// <param name="value">The context that you want to determine if it is supported.TRUE if the provided context is supported, otherwise FALSE.IsValidDpiAwarenessContext determines the validity of any provided DPI_AWARENESS_CONTEXT. You should make sure a context is valid before using SetThreadDpiAwarenessContext to that context.An input value of NULL is considered to be an invalid context and will result in a return value of FALSE.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsValidDpiAwarenessContext(DPI_AWARENESS value);

        /// <summary>
        ///Determines whether the specified window handle identifies an existing window.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsWindow(nint hWnd);

        /// <summary>
        ///Determines whether a window is arranged.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsWindowArranged(nint hwnd);

        /// <summary>
        ///Determines whether the specified window is enabled for mouse and keyboard input.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to be tested.Type: BOOLIf the window is enabled, the return value is nonzero.If the window is not enabled, the return value is zero.A child window receives input only if it is both enabled and visible.ConceptualEnableWindowIsWindowVisibleKeyboard InputReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsWindowEnabled(nint hWnd);

        /// <summary>
        ///Determines whether the specified window is a native Unicode window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to be tested.Type: BOOLIf the window is a native Unicode window, the return value is nonzero.If the window is not a native Unicode window, the return value is zero. The window is a native ANSI window.The character set of a window is determined by the use of the RegisterClass function. If the window class was registered with the ANSI version of RegisterClass (RegisterClassA), the character set of the window is ANSI. If the window class was registered with the Unicode version of RegisterClass (RegisterClassW), the character set of the window is Unicode.The system does automatic two-way translation (Unicode to ANSI) for window messages. For example, if an ANSI window message is sent to a window that uses the Unicode character set, the system translates that message into a Unicode message before calling the window procedure. The system calls IsWindowUnicode to determine whether to translate the message.Windows Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsWindowUnicode(nint hWnd);

        /// <summary>
        ///Determines the visibility state of the specified window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to be tested.Type: BOOLIf the specified window, its parent window, its parent's parent window, and so forth, have the WS_VISIBLE style, the return value is nonzero. Otherwise, the return value is zero.Because the return value specifies whether the window has the WS_VISIBLE style, it may be nonzero even if the window is totally obscured by other windows.The visibility state of a window is indicated by the WS_VISIBLE style bit. When WS_VISIBLE is set, the window is displayed and subsequent drawing into it is displayed as long as the window has the WS_VISIBLE style.Any drawing to a window with the WS_VISIBLE style will not be displayed if the window is obscured by other windows or is clipped by its parent window.ConceptualReferenceShowWindowWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsWindowVisible(nint hWnd);

        /// <summary>
        ///Determines whether there is an installed WinEvent hook that might be notified of a specified event.
        /// </summary>
        /// <param name="event">Type: DWORDThe event constant that hooks might be notified of. The function checks whether there is an installed hook for this event constant.Type: BOOLIf there is a hook to be notified of the specified event, the return value is TRUE.If there are no hooks to be notified of the specified event, the return value is FALSE.This method is guaranteed to never return a false negative. If this method returns FALSE, it means that no hooks in the system would be notified of the event. However, this method may return a false positive. In other words, it may return TRUE even though there are no hooks that would be notified. Thus, it is safe for components to circumvent some work if this method returns FALSE.Event hooks can be installed at any time, so server developers should not cache the return value for long periods of time.SetWinEventHookUnhookWinEvent</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsWinEventHookInstalled(uint @event);

        /// <summary>
        ///Determines whether the last message read from the current thread's queue originated from a WOW64 process.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsWow64Message();

        /// <summary>
        ///Determines whether a window is maximized.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to be tested.Type: BOOLIf the window is zoomed, the return value is nonzero.If the window is not zoomed, the return value is zero.ConceptualIsIconicReferenceWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool IsZoomed(nint hWnd);

        /// <summary>
        ///Synthesizes a keystroke. The system can use such a synthesized keystroke to generate a WM_KEYUP or WM_KEYDOWN message. The keyboard driver's interrupt handler calls the keybd_event function.
        /// </summary>
        /// <param name="bVk">Type: BYTEA virtual-key code. The code must be a value in the range 1 to 254. For a complete list, see Virtual Key Codes.</param>
        /// <param name="bScan">Type: BYTEA hardware scan code for the key.</param>
        /// <param name="dwFlags">Type: DWORDControls various aspects of function operation. This parameter can be one or more of the following values.</param>
        /// <param name="dwExtraInfo">Type: ULONG_PTRAn additional value associated with the key stroke.NoneAn application can simulate a press of the PRINTSCRN key in order to obtain a screen snapshot and save it to the clipboard. To do this, call keybd_event with the bVk parameter set to VK_SNAPSHOT.The following sample program toggles the NUM LOCK light by using keybd_event with a virtual key of VK_NUMLOCK. It takes a Boolean value that indicates whether the light should be turned off (FALSE) or on (TRUE). The same technique can be used for the CAPS LOCK key (VK_CAPITAL) and the SCROLL LOCK key (VK_SCROLL).</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, uint dwExtraInfo);

        /// <summary>
        ///Destroys the specified timer.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="uIDEvent">Type: UINT_PTRThe timer to be destroyed. If the window handle passed to SetTimer is valid, this parameter must be the same as the nIDEventvalue passed to SetTimer. If the application calls SetTimer with hWnd set to NULL, this parameter must be the timer identifier returned by SetTimer.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The KillTimer function does not remove WM_TIMER messages already posted to the message queue.For an example, see Destroying a Timer.ConceptualReferenceSetTimerTimersWM_TIMER</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool KillTimer(nint hWnd, nint uIDEvent);

        /// <summary>
        ///Loads the specified accelerator table.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpTableName">Type: LPCTSTRThe name of the accelerator table to be loaded. Alternatively, this parameter can specify the resource identifier of an accelerator-table resource in the low-order word and zero in the high-order word. To create this value, use the MAKEINTRESOURCE macro.Type: HACCELIf the function succeeds, the return value is a handle to the loaded accelerator table.If the function fails, the return value is NULL. To get extended error information, call GetLastError.If the accelerator table has not yet been loaded, the function loads it from the specified executable file.Accelerator tables loaded from resources are freed automatically when the application terminates.For an example, see Creating Accelerators for Font Attributes.ConceptualCopyAcceleratorTableCreateAcceleratorTableDestroyAcceleratorTableKeyboard AcceleratorsMAKEINTRESOURCEReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern ACCEL LoadAcceleratorsA(nint hInstance, string lpTableName);

        /// <summary>
        ///Loads the specified accelerator table.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpTableName">Type: LPCTSTRThe name of the accelerator table to be loaded. Alternatively, this parameter can specify the resource identifier of an accelerator-table resource in the low-order word and zero in the high-order word. To create this value, use the MAKEINTRESOURCE macro.Type: HACCELIf the function succeeds, the return value is a handle to the loaded accelerator table.If the function fails, the return value is NULL. To get extended error information, call GetLastError.If the accelerator table has not yet been loaded, the function loads it from the specified executable file.Accelerator tables loaded from resources are freed automatically when the application terminates.For an example, see Creating Accelerators for Font Attributes.ConceptualCopyAcceleratorTableCreateAcceleratorTableDestroyAcceleratorTableKeyboard AcceleratorsMAKEINTRESOURCEReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern ACCEL LoadAcceleratorsW(nint hInstance, string lpTableName);

        /// <summary>
        ///[LoadBitmap is available for use in the operating systems specified in the Requirements section. It may be altered or unavailable in subsequent versions. Instead, use LoadImage and DrawFrameControl.]
        /// </summary>
        /// <param name="hInstance">A handle to the instance of the module whose executable file contains the bitmap to be loaded.</param>
        /// <param name="lpBitmapName">A pointer to a null-terminated string that contains the name of the bitmap resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. The MAKEINTRESOURCE macro can be used to create this value.If the function succeeds, the return value is the handle to the specified bitmap.If the function fails, the return value is NULL.If the bitmap pointed to by the lpBitmapName parameter does not exist or there is insufficient memory to load the bitmap, the function fails.LoadBitmap creates a compatible bitmap of the display, which cannot be selected to a printer. To load a bitmap that you can select to a printer, call LoadImage and specify LR_CREATEDIBSECTION to create a DIB section. A DIB section can be selected to any device.An application can use the LoadBitmap function to access predefined bitmaps. To do so, the application must set the hInstance parameter to NULL and the lpBitmapName parameter to one of the following values.Bitmap names that begin with OBM_OLD represent bitmaps used by 16-bit versions of Windows earlier than 3.0.For an application to use any of the OBM_ constants, the constant OEMRESOURCE must be defined before the Windows.h header file is included.The application must call the DeleteObject function to delete each bitmap handle returned by the LoadBitmap function.For an example, see Example of Menu-Item Bitmaps in Using Menus.Bitmap FunctionsBitmaps OverviewCreateBitmapDeleteObjectDrawFrameControlLoadCursorLoadIconLoadImageMAKEINTRESOURCE</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadBitmapA(nint hInstance, string lpBitmapName);

        /// <summary>
        ///[LoadBitmap is available for use in the operating systems specified in the Requirements section. It may be altered or unavailable in subsequent versions. Instead, use LoadImage and DrawFrameControl.]
        /// </summary>
        /// <param name="hInstance">A handle to the instance of the module whose executable file contains the bitmap to be loaded.</param>
        /// <param name="lpBitmapName">A pointer to a null-terminated string that contains the name of the bitmap resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. The MAKEINTRESOURCE macro can be used to create this value.If the function succeeds, the return value is the handle to the specified bitmap.If the function fails, the return value is NULL.If the bitmap pointed to by the lpBitmapName parameter does not exist or there is insufficient memory to load the bitmap, the function fails.LoadBitmap creates a compatible bitmap of the display, which cannot be selected to a printer. To load a bitmap that you can select to a printer, call LoadImage and specify LR_CREATEDIBSECTION to create a DIB section. A DIB section can be selected to any device.An application can use the LoadBitmap function to access predefined bitmaps. To do so, the application must set the hInstance parameter to NULL and the lpBitmapName parameter to one of the following values.Bitmap names that begin with OBM_OLD represent bitmaps used by 16-bit versions of Windows earlier than 3.0.For an application to use any of the OBM_ constants, the constant OEMRESOURCE must be defined before the Windows.h header file is included.The application must call the DeleteObject function to delete each bitmap handle returned by the LoadBitmap function.For an example, see Example of Menu-Item Bitmaps in Using Menus.Bitmap FunctionsBitmaps OverviewCreateBitmapDeleteObjectDrawFrameControlLoadCursorLoadIconLoadImageMAKEINTRESOURCE</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadBitmapW(nint hInstance, string lpBitmapName);

        /// <summary>
        ///Loads the specified cursor resource from the executable (.EXE) file associated with an application instance.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpCursorName">Type: LPCTSTRIf hInstance is non-NULL, lpCursorName specifies the cursor resource either by name or ordinal. This ordinal must be packaged by using the MAKEINTRESOURCE macro.If hInstance is NULL, lpCursorName specifies the identifier (beginning with the IDC_ prefix) of a predefined system cursor to load.Type: HCURSORIf the function succeeds, the return value is the handle to the newly loaded cursor.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The LoadCursor function loads the cursor resource only if it has not been loaded; otherwise, it retrieves the handle to the existing resource. This function returns a valid cursor handle only if the lpCursorName parameter is a pointer to a cursor resource. If lpCursorName is a pointer to any type of resource other than a cursor (such as an icon), the return value is not NULL, even though it is not a valid cursor handle.The LoadCursor function searches the cursor resource most appropriate for the cursor for the current display device. The cursor resource can be a color or monochrome bitmap.For an example, see Creating a Cursor.ConceptualCursorsLoadImageMAKEINTRESOURCEIS_INTRESOURCEReferenceSetCursorSetCursorPosShowCursor</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadCursorA(nint hInstance, string lpCursorName);

        /// <summary>
        ///Creates a cursor based on data contained in a file.
        /// </summary>
        /// <param name="lpFileName">Type: LPCTSTRThe source of the file data to be used to create the cursor. The data in the file must be in either .CUR or .ANI format.If the high-order word of lpFileName is nonzero, it is a pointer to a string that is a fully qualified name of a file containing cursor data.Type: HCURSORIf the function is successful, the return value is a handle to the new cursor.If the function fails, the return value is NULL. To get extended error information, call GetLastError. GetLastError may return the following value.ConceptualCursorsLoadCursorReferenceSetCursorSetSystemCursor</param>
        /// <remarks>
        /// To get extended error information, call GetLastError. GetLastError may return the following value.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadCursorFromFileA(string lpFileName);

        /// <summary>
        ///Creates a cursor based on data contained in a file.
        /// </summary>
        /// <param name="lpFileName">Type: LPCTSTRThe source of the file data to be used to create the cursor. The data in the file must be in either .CUR or .ANI format.If the high-order word of lpFileName is nonzero, it is a pointer to a string that is a fully qualified name of a file containing cursor data.Type: HCURSORIf the function is successful, the return value is a handle to the new cursor.If the function fails, the return value is NULL. To get extended error information, call GetLastError. GetLastError may return the following value.ConceptualCursorsLoadCursorReferenceSetCursorSetSystemCursor</param>
        /// <remarks>
        /// To get extended error information, call GetLastError. GetLastError may return the following value.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadCursorFromFileW(string lpFileName);

        /// <summary>
        ///Loads the specified cursor resource from the executable (.exe) file associated with an application instance.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpCursorName">Type: LPCTSTRIf hInstance is non-NULL, lpCursorName specifies the cursor resource either by name or ordinal. This ordinal must be packaged by using the MAKEINTRESOURCE macro.If hInstance is NULL, lpCursorName specifies the identifier that begins with the IDC_ prefix of a predefined system cursor to load.Type: HCURSORIf the function succeeds, the return value is the handle to the newly loaded cursor.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The LoadCursor function loads the cursor resource only if it has not been loaded; otherwise, it retrieves the handle to the existing resource. This function returns a valid cursor handle only if the lpCursorName parameter is a pointer to a cursor resource. If lpCursorName is a pointer to any type of resource other than a cursor (such as an icon), the return value is not NULL, even though it is not a valid cursor handle.The LoadCursor function searches the cursor resource most appropriate for the cursor for the current display device. The cursor resource can be a color or monochrome bitmap.For an example, see Creating a Cursor.ConceptualCursorsLoadImageMAKEINTRESOURCEIS_INTRESOURCEReferenceSetCursorSetCursorPosShowCursor</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadCursorW(nint hInstance, string lpCursorName);

        /// <summary>
        ///Loads the specified icon resource from the executable (.exe) file associated with an application instance.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpIconName">Type: LPCTSTRIf hInstance is non-NULL, lpIconName specifies the icon resource either by name or ordinal. This ordinal must be packaged by using the MAKEINTRESOURCE macro.If hInstance is NULL, lpIconName specifies the identifier (beginning with the IDI_ prefix) of a predefined system icon to load.Type: HICONIf the function succeeds, the return value is a handle to the newly loaded icon.If the function fails, the return value is NULL. To get extended error information, call GetLastError.LoadIcon loads the icon resource only if it has not been loaded; otherwise, it retrieves a handle to the existing resource. The function searches the icon resource for the icon most appropriate for the current display. The icon resource can be a color or monochrome bitmap.LoadIcon can only load an icon whose size conforms to the SM_CXICON and SM_CYICON system metric values. Use the LoadImage function to load icons of other sizes.ConceptualCreateIconIconsLoadImageMAKEINTRESOURCEIS_INTRESOURCE</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadIconA(nint hInstance, string lpIconName);

        /// <summary>
        ///Loads the specified icon resource from the executable (.exe) file associated with an application instance.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpIconName">Type: LPCTSTRIf hInstance is non-NULL, lpIconName specifies the icon resource either by name or ordinal. This ordinal must be packaged by using the MAKEINTRESOURCE macro.If hInstance is NULL, lpIconName specifies the identifier (beginning with the IDI_ prefix) of a predefined system icon to load.Type: HICONIf the function succeeds, the return value is a handle to the newly loaded icon.If the function fails, the return value is NULL. To get extended error information, call GetLastError.LoadIcon loads the icon resource only if it has not been loaded; otherwise, it retrieves a handle to the existing resource. The function searches the icon resource for the icon most appropriate for the current display. The icon resource can be a color or monochrome bitmap.LoadIcon can only load an icon whose size conforms to the SM_CXICON and SM_CYICON system metric values. Use the LoadImage function to load icons of other sizes.ConceptualCreateIconIconsLoadImageMAKEINTRESOURCEIS_INTRESOURCE</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadIconW(nint hInstance, string lpIconName);

        /// <summary>
        ///Loads an icon, cursor, animated cursor, or bitmap.
        /// </summary>
        /// <param name="hInst"></param>
        /// <param name="name">Type: LPCTSTRThe image to be loaded.If the hInst parameter is non-NULL and the fuLoad parameter omits LR_LOADFROMFILE, name specifies the image resource in the hInst module.If the image resource is to be loaded by name from the module, the name parameter is a pointer to a null-terminated string that contains the name of the image resource.If the image resource is to be loaded by ordinal from the module, use the MAKEINTRESOURCE macro to convert the image ordinal into a form that can be passed to the LoadImage function.If the hInst parameter is NULL and the fuLoad parameter omits the LR_LOADFROMFILE value, the name specifies the predefined image to load.The predefined image identifiers are defined in Winuser.h and have the following prefixes:To pass OEM image identifiers constants to the LoadImage function, use the MAKEINTRESOURCE macro. For example, to load the OCR_NORMAL cursor, pass MAKEINTRESOURCE(OCR_NORMAL) as the name parameter, NULL as the hInst parameter, and LR_SHARED as one of the flags to the fuLoad parameter.If the hInst parameter is NULL and the fuLoad parameter includes the LR_LOADFROMFILE value, name is the name of the file that contains the standalone resource (icon, cursor, or bitmap file), - for example, c:\myicon.ico.For more information, see the Remarks section below.</param>
        /// <param name="type">Type: UINTThe type of image to be loaded.This parameter can be one of the following values:</param>
        /// <param name="cx">Type: intThe width, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function uses the SM_CXICON or SM_CXCURSOR system metric value to set the width. If this parameter is zero and LR_DEFAULTSIZE is not used, the function uses the actual resource width.</param>
        /// <param name="cy">Type: intThe height, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function uses the SM_CYICON or SM_CYCURSOR system metric value to set the height. If this parameter is zero and LR_DEFAULTSIZE is not used, the function uses the actual resource height.</param>
        /// <param name="fuLoad">Type: UINTThis parameter can be one or more of the following values.Type: HANDLEIf the function succeeds, the return value is the handle of the newly loaded image.If the function fails, the return value is NULL. To get extended error information, call GetLastError.If IS_INTRESOURCE(name) is TRUE, then name specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource. For example, the string "#258" represents the identifier 258.When you are finished using a bitmap, cursor, or icon you loaded without specifying the LR_SHARED flag, you can release its associated memory by calling one of the functions in the following table.The system automatically deletes these resources when the process that created them terminates; however, calling the appropriate function saves memory and decreases the size of the process's working set.For an example, see Using Window Classes.ConceptualCopyImageGetSystemMetricsLoadBitmapLoadCursorLoadIconOther ResourcesReferenceResources</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadImageA(nint hInst, string name, uint type, int cx, int cy, uint fuLoad);

        /// <summary>
        ///Loads an icon, cursor, animated cursor, or bitmap.
        /// </summary>
        /// <param name="hInst"></param>
        /// <param name="name">Type: LPCTSTRThe image to be loaded.If the hInst parameter is non-NULL and the fuLoad parameter omits LR_LOADFROMFILE, name specifies the image resource in the hInst module.If the image resource is to be loaded by name from the module, the name parameter is a pointer to a null-terminated string that contains the name of the image resource.If the image resource is to be loaded by ordinal from the module, use the MAKEINTRESOURCE macro to convert the image ordinal into a form that can be passed to the LoadImage function.If the hInst parameter is NULL and the fuLoad parameter omits the LR_LOADFROMFILE value, the name specifies the predefined image to load.The predefined image identifiers are defined in Winuser.h and have the following prefixes:To pass OEM image identifiers constants to the LoadImage function, use the MAKEINTRESOURCE macro. For example, to load the OCR_NORMAL cursor, pass MAKEINTRESOURCE(OCR_NORMAL) as the name parameter, NULL as the hInst parameter, and LR_SHARED as one of the flags to the fuLoad parameter.If the hInst parameter is NULL and the fuLoad parameter includes the LR_LOADFROMFILE value, name is the name of the file that contains the standalone resource (icon, cursor, or bitmap file), - for example, c:\myicon.ico.For more information, see the Remarks section below.</param>
        /// <param name="type">Type: UINTThe type of image to be loaded.This parameter can be one of the following values:</param>
        /// <param name="cx">Type: intThe width, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function uses the SM_CXICON or SM_CXCURSOR system metric value to set the width. If this parameter is zero and LR_DEFAULTSIZE is not used, the function uses the actual resource width.</param>
        /// <param name="cy">Type: intThe height, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function uses the SM_CYICON or SM_CYCURSOR system metric value to set the height. If this parameter is zero and LR_DEFAULTSIZE is not used, the function uses the actual resource height.</param>
        /// <param name="fuLoad">Type: UINTThis parameter can be one or more of the following values.Type: HANDLEIf the function succeeds, the return value is the handle of the newly loaded image.If the function fails, the return value is NULL. To get extended error information, call GetLastError.If IS_INTRESOURCE(name) is TRUE, then name specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string.If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource. For example, the string "#258" represents the identifier 258.When you are finished using a bitmap, cursor, or icon you loaded without specifying the LR_SHARED flag, you can release its associated memory by calling one of the functions in the following table.The system automatically deletes these resources when the process that created them terminates; however, calling the appropriate function saves memory and decreases the size of the process's working set.For an example, see Using Window Classes.ConceptualCopyImageGetSystemMetricsLoadBitmapLoadCursorLoadIconOther ResourcesReferenceResources</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadImageW(nint hInst, string name, uint type, int cx, int cy, uint fuLoad);

        /// <summary>
        ///Loads a new input locale identifier (formerly called the keyboard layout) into the system.
        /// </summary>
        /// <param name="pwszKLID">Type: LPCTSTRThe name of the input locale identifier to load. This name is a string composed of the hexadecimal value of the Language Identifier (low word) and a device identifier (high word). For example, U.S. English has a language identifier of 0x0409, so the primary U.S. English layout is named "00000409". Variants of U.S. English layout (such as the Dvorak layout) are named "00010409", "00020409", and so on.For a list of the input layouts that are supplied with Windows, see Keyboard Identifiers and Input Method Editors for Windows.</param>
        /// <param name="Flags">Type: UINTSpecifies how the input locale identifier is to be loaded. This parameter can be one or more of the following values.Type: HKLIf the function succeeds, the return value is the input locale identifier corresponding to the name specified in pwszKLID. If no matching locale is available, the return value is the default language of the system.If the function fails, the return value is NULL. This can occur if the layout library is loaded from the application directory.To get extended error information, call GetLastError.The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input.An application can and will typically load the default input locale identifier or IME for a language and can do so by specifying only a string version of the language identifier. If an application wants to load a specific locale or IME, it should read the registry to determine the specific input locale identifier to pass to LoadKeyboardLayout. In this case, a request to activate the default input locale identifier for a locale will activate the first matching one. A specific IME should be activated using an explicit input locale identifier returned from GetKeyboardLayout or LoadKeyboardLayout.Prior to Windows 8: This function only affects the layout for the current process or thread.Beginning in Windows 8: This function affects the layout for the entire system.ActivateKeyboardLayoutConceptualGetKeyboardLayoutNameKeyboard InputMAKELANGIDOther ResourcesReferenceUnloadKeyboardLayout</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadKeyboardLayoutA(string pwszKLID, uint Flags);

        /// <summary>
        ///Loads a new input locale identifier (formerly called the keyboard layout) into the system.
        /// </summary>
        /// <param name="pwszKLID">Type: LPCTSTRThe name of the input locale identifier to load. This name is a string composed of the hexadecimal value of the Language Identifier (low word) and a device identifier (high word). For example, U.S. English has a language identifier of 0x0409, so the primary U.S. English layout is named "00000409". Variants of U.S. English layout (such as the Dvorak layout) are named "00010409", "00020409", and so on.For a list of the input layouts that are supplied with Windows, see Keyboard Identifiers and Input Method Editors for Windows.</param>
        /// <param name="Flags">Type: UINTSpecifies how the input locale identifier is to be loaded. This parameter can be one of the following values.Type: HKLIf the function succeeds, the return value is the input locale identifier corresponding to the name specified in pwszKLID. If no matching locale is available, the return value is the default language of the system.If the function fails, the return value is NULL. This can occur if the layout library is loaded from the application directory.To get extended error information, call GetLastError.The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input.An application can and will typically load the default input locale identifier or IME for a language and can do so by specifying only a string version of the language identifier. If an application wants to load a specific locale or IME, it should read the registry to determine the specific input locale identifier to pass to LoadKeyboardLayout. In this case, a request to activate the default input locale identifier for a locale will activate the first matching one. A specific IME should be activated using an explicit input locale identifier returned from GetKeyboardLayout or LoadKeyboardLayout.Prior to Windows 8: This function only affects the layout for the current process or thread.Beginning in Windows 8: This function affects the layout for the entire system.ActivateKeyboardLayoutConceptualGetKeyboardLayoutNameKeyboard InputMAKELANGIDOther ResourcesReferenceUnloadKeyboardLayout</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadKeyboardLayoutW(string pwszKLID, uint Flags);

        /// <summary>
        ///Loads the specified menu resource from the executable (.exe) file associated with an application instance.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpMenuName">Type: LPCTSTRThe name of the menu resource. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. To create this value, use the MAKEINTRESOURCE macro.Type: HMENUIf the function succeeds, the return value is a handle to the menu resource.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The DestroyMenu function is used, before an application closes, to destroy the menu and free memory that the loaded menu occupied.For an example, see Displaying a Shortcut MenuConceptualLoadMenuIndirectMAKEINTRESOURCEMenusReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadMenuA(nint hInstance, string lpMenuName);

        /// <summary>
        ///Loads the specified menu template in memory.
        /// </summary>
        /// <param name="lpMenuTemplate">Type: const MENUTEMPLATE*A pointer to a menu template or an extended menu template. A menu template consists of a MENUITEMTEMPLATEHEADER structure followed by one or more contiguous MENUITEMTEMPLATE structures. An extended menu template consists of a MENUEX_TEMPLATE_HEADER structure followed by one or more contiguous MENUEX_TEMPLATE_ITEM structures.Type: HMENUIf the function succeeds, the return value is a handle to the menu.If the function fails, the return value is NULL. To get extended error information, call GetLastError.For both the ANSI and the Unicode version of this function, the strings in the MENUITEMTEMPLATE structure must be Unicode strings.ConceptualLoadMenuMENUEX_TEMPLATE_HEADERMENUEX_TEMPLATE_ITEMMENUITEMTEMPLATEMENUITEMTEMPLATEHEADERMenusReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadMenuIndirectA(DLGTEMPLATE lpMenuTemplate);

        /// <summary>
        ///Loads the specified menu template in memory.
        /// </summary>
        /// <param name="lpMenuTemplate">Type: const MENUTEMPLATE*A pointer to a menu template or an extended menu template. A menu template consists of a MENUITEMTEMPLATEHEADER structure followed by one or more contiguous MENUITEMTEMPLATE structures. An extended menu template consists of a MENUEX_TEMPLATE_HEADER structure followed by one or more contiguous MENUEX_TEMPLATE_ITEM structures.Type: HMENUIf the function succeeds, the return value is a handle to the menu.If the function fails, the return value is NULL. To get extended error information, call GetLastError.For both the ANSI and the Unicode version of this function, the strings in the MENUITEMTEMPLATE structure must be Unicode strings.ConceptualLoadMenuMENUEX_TEMPLATE_HEADERMENUEX_TEMPLATE_ITEMMENUITEMTEMPLATEMENUITEMTEMPLATEHEADERMenusReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadMenuIndirectW(DLGTEMPLATE lpMenuTemplate);

        /// <summary>
        ///Loads the specified menu resource from the executable (.exe) file associated with an application instance.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="lpMenuName">Type: LPCTSTRThe name of the menu resource. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. To create this value, use the MAKEINTRESOURCE macro.Type: HMENUIf the function succeeds, the return value is a handle to the menu resource.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The DestroyMenu function is used, before an application closes, to destroy the menu and free memory that the loaded menu occupied.For an example, see Displaying a Shortcut MenuConceptualLoadMenuIndirectMAKEINTRESOURCEMenusReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint LoadMenuW(nint hInstance, string lpMenuName);

        /// <summary>
        ///Loads a string resource from the executable file associated with a specified module and either copies the string into a buffer with a terminating null character or returns a read-only pointer to the string resource itself.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="uID">Type: UINTThe identifier of the string to be loaded.</param>
        /// <param name="lpBuffer"></param>
        /// <param name="cchBufferMax">Type: intThe size of the buffer, in characters. The string is truncated and null-terminated if it is longer than the number of characters specified. This parameter may not be zero.Type: intIf the function succeeds, the return value is the number of characters copied into the buffer, not including the terminating null character.If the string resource does not exist, the return value is zero.To get extended error information, call GetLastError.Unlike the LoadStringW function, the LoadStringA function does not support passing a value of zero for cchBufferMax. Doing so will corrupt memory.For an example, see Creating a Child WindowConceptualFormatMessageLoadAcceleratorsLoadBitmapLoadCursorLoadIconLoadMenuLoadMenuIndirectOther ResourcesReferenceStrings</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int LoadStringA(nint hInstance, uint uID, out string lpBuffer, int cchBufferMax);

        /// <summary>
        ///Loads a string resource from the executable file associated with a specified module and either copies the string into a buffer with a terminating null character or returns a read-only pointer to the string resource itself.
        /// </summary>
        /// <param name="hInstance"></param>
        /// <param name="uID">Type: UINTThe identifier of the string to be loaded.</param>
        /// <param name="lpBuffer"></param>
        /// <param name="cchBufferMax">Type: intThe size of the buffer, in characters. The string is truncated and null-terminated if it is longer than the number of characters specified. If this parameter is 0, then lpBuffer receives a read-only pointer to the string resource itself.Type: intIf the function succeeds, the return value is one of the following:To get extended error information, call GetLastError.If you pass 0 to cchBufferMax to return a read-only pointer to the string resource in the lpBuffer parameter, use the number of characters in the return value to determine the length of the string resource. String resources are not guaranteed to be null-terminated in the module's resource table. However, resource tables can contain null characters. String resources are stored in blocks of 16 strings, and any empty slots within a block are indicated by null characters.For an example, see Creating a Child WindowConceptualFormatMessageLoadAcceleratorsLoadBitmapLoadCursorLoadIconLoadMenuLoadMenuIndirectOther ResourcesReferenceStrings</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int LoadStringW(nint hInstance, uint uID, out string lpBuffer, int cchBufferMax);

        /// <summary>
        ///The foreground process can call the LockSetForegroundWindow function to disable calls to the SetForegroundWindow function.
        /// </summary>
        /// <param name="uLockCode">Type: UINTSpecifies whether to enable or disable calls to SetForegroundWindow. This parameter can be one of the following values.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The system automatically enables calls to SetForegroundWindow if the user presses the ALT key or takes some action that causes the system itself to change the foreground window (for example, clicking a background window).This function is provided so applications can prevent other applications from making a foreground change that can interrupt its interaction with the user.AllowSetForegroundWindowConceptualReferenceSetForegroundWindowWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool LockSetForegroundWindow(uint uLockCode);

        /// <summary>
        ///The LockWindowUpdate function disables or enables drawing in the specified window. Only one window can be locked at a time.
        /// </summary>
        /// <param name="hWndLock">The window in which drawing will be disabled. If this parameter is NULL, drawing in the locked window is enabled.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero, indicating that an error occurred or another window was already locked.The purpose of the LockWindowUpdate function is to permit drag/drop feedback to be drawn over a window without interference from the window itself. The intent is that the window is locked when feedback is drawn and unlocked when feedback is complete. LockWindowUpdate is not intended for general-purpose suppression of window redraw. Use the WM_SETREDRAW message to disable redrawing of a particular window.If an application with a locked window (or any locked child windows) calls the GetDC, GetDCEx, or BeginPaint function, the called function returns a device context with a visible region that is empty. This will occur until the application unlocks the window by calling LockWindowUpdate, specifying a value of NULL for hWndLock.If an application attempts to draw within a locked window, the system records the extent of the attempted operation in a bounding rectangle. When the window is unlocked, the system invalidates the area within this bounding rectangle, forcing an eventual WM_PAINT message to be sent to the previously locked window and its child windows. If no drawing has occurred while the window updates were locked, no area is invalidated.LockWindowUpdate does not make the specified window invisible and does not clear the WS_VISIBLE style bit.A locked window cannot be moved.BeginPaintGetDCGetDCExPainting and Drawing FunctionsPainting and Drawing OverviewWM_PAINT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool LockWindowUpdate(nint hWndLock);

        /// <summary>
        ///Locks the workstation's display. Locking a workstation protects it from unauthorized use.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool LockWorkStation();

        /// <summary>
        ///Converts the logical coordinates of a point in a window to physical coordinates.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose transform is used for the conversion. Top level windows are fully supported. In the case of child windows, only the area of overlap between the parent and the child window is converted.</param>
        /// <param name="lpPoint">Type: LPPOINTA pointer to a POINT structure that specifies the logical coordinates to be converted. The new physical coordinates are copied into this structure if the function succeeds.NoneWindows Vista introduces the concept of physical coordinates. Desktop Window Manager (DWM) scales non-dots per inch (dpi) aware windows when the display is high dpi. The window seen on the screen corresponds to the physical coordinates. The application continues to work in logical space. Therefore, the application's view of the window is different from that which appears on the screen. For scaled windows, logical and physical coordinates are different.LogicalToPhysicalPoint is a transformation API that can be called by a process that declares itself as dpi aware. The function uses the window identified by the hWnd parameter and the logical coordinates given in the POINT structure to compute the physical coordinates.The LogicalToPhysicalPoint function replaces the logical coordinates in the POINT structure with the physical coordinates. The physical coordinates are relative to the upper-left corner of the screen. The coordinates have to be inside the client area of hWnd.On all platforms, LogicalToPhysicalPoint will fail on a window that has either 0 width or height; an application must first establish a non-0 width and height by calling, for example, MoveWindow. On some versions of Windows (including Windows 7), LogicalToPhysicalPoint will still fail if MoveWindow has been called after a call to ShowWindow with SH_HIDE has hidden the window.In Windows 8, system–DPI aware applications translate between physical and logical space using PhysicalToLogicalPoint and LogicalToPhysicalPoint. In Windows 8.1, the additional virtualization of the system and inter-process communications means that for the majority of applications, you do not need these APIs. As a result, in Windows 8.1, PhysicalToLogicalPoint and LogicalToPhysicalPoint no longer transform points. The system returns all points to an application in its own coordinate space. This behavior preserves functionality for the majority of applications, but there are some exceptions in which you must make changes to ensure that the application works as expected. In those cases, use PhysicalToLogicalPointForPerMonitorDPI and LogicalToPhysicalPointForPerMonitorDPI.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool LogicalToPhysicalPoint(nint hWnd, out POINT lpPoint);

        /// <summary>
        ///Converts a point in a window from logical coordinates into physical coordinates, regardless of the dots per inch (dpi) awareness of the caller. For more information about DPI awareness levels, see PROCESS_DPI_AWARENESS.
        /// </summary>
        /// <param name="hWnd">A handle to the window whose transform is used for the conversion.</param>
        /// <param name="lpPoint">A pointer to a POINT structure that specifies the logical coordinates to be converted. The new physical coordinates are copied into this structure if the function succeeds.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool LogicalToPhysicalPointForPerMonitorDPI(nint hWnd, out POINT lpPoint);

        /// <summary>
        ///Searches through icon (RT_GROUP_ICON) or cursor (RT_GROUP_CURSOR) resource data for the icon or cursor that best fits the current display device.
        /// </summary>
        /// <param name="presbits">Type: PBYTEThe icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or returns an undefined value if presbits is not pointing to valid resource data.</param>
        /// <param name="fIcon">Type: BOOLIndicates whether an icon or a cursor is sought. If this parameter is TRUE, the function is searching for an icon; if the parameter is FALSE, the function is searching for a cursor.Type: intIf the function succeeds, the return value is an integer resource identifier for the icon (RT_ICON) or cursor (RT_CURSOR) that best fits the current display device.If the function fails, the return value is zero. To get extended error information, call GetLastError.A resource file of type RT_GROUP_ICON (RT_GROUP_CURSOR indicates cursors) contains icon (or cursor) data in several device-dependent and device-independent formats. LookupIconIdFromDirectory searches the resource file for the icon (or cursor) that best fits the current display device and returns its integer identifier. The FindResource and FindResourceEx functions use the MAKEINTRESOURCE macro with this identifier to locate the resource in the module.The icon directory is loaded from a resource file with resource type RT_GROUP_ICON (or RT_GROUP_CURSOR for cursors), and an integer resource name for the specific icon to be loaded. LookupIconIdFromDirectory returns an integer identifier that is the resource name of the icon that best fits the current display device.The LoadIcon, LoadCursor, and LoadImage functions use this function to search the specified resource data for the icon or cursor that best fits the current display device.ConceptualCreateIconFromResourceCreateIconIndirectFindResourceFindResourceExGetIconInfoIconsLoadCursorLoadIconLoadImageLookupIconIdFromDirectoryExMAKEINTRESOURCEReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int LookupIconIdFromDirectory(byte presbits, bool fIcon);

        /// <summary>
        ///Searches through icon (RT_GROUP_ICON) or cursor (RT_GROUP_CURSOR) resource data for the icon or cursor that best fits the current display device.
        /// </summary>
        /// <param name="presbits">Type: PBYTEThe icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or returns an undefined value if presbits is not pointing to valid resource data.</param>
        /// <param name="fIcon">Type: BOOLIndicates whether an icon or a cursor is sought. If this parameter is TRUE, the function is searching for an icon; if the parameter is FALSE, the function is searching for a cursor.</param>
        /// <param name="cxDesired">Type: intThe desired width, in pixels, of the icon. If this parameter is zero, the function uses the SM_CXICON or SM_CXCURSOR system metric value.</param>
        /// <param name="cyDesired">Type: intThe desired height, in pixels, of the icon. If this parameter is zero, the function uses the SM_CYICON or SM_CYCURSOR system metric value.</param>
        /// <param name="Flags">Type: UINTA combination of the following values.Type: intIf the function succeeds, the return value is an integer resource identifier for the icon (RT_ICON) or cursor (RT_CURSOR) that best fits the current display device.If the function fails, the return value is zero. To get extended error information, call GetLastError.A resource file of type RT_GROUP_ICON (RT_GROUP_CURSOR indicates cursors) contains icon (or cursor) data in several device-dependent and device-independent formats. LookupIconIdFromDirectoryEx searches the resource file for the icon (or cursor) that best fits the current display device and returns its integer identifier. The FindResource and FindResourceEx functions use the MAKEINTRESOURCE macro with this identifier to locate the resource in the module.The icon directory is loaded from a resource file with resource type RT_GROUP_ICON (or RT_GROUP_CURSOR for cursors), and an integer resource name for the specific icon (RT_ICON) or cursor (RT_CURSOR) to be loaded. LoadResource and CreateIconFromResourceEx functions may be used to create a corresponding icon or cursor.The LoadIcon, LoadImage, and LoadCursor functions use this function to search the specified resource data for the icon or cursor that best fits the current display device. LoadIconWithScaleDown uses alternative search criteria for a best fit.For an example, see Sharing Icon Resources.ConceptualCreateIconFromResourceExCreateIconIndirectFindResourceFindResourceExGetIconInfoIconsLoadCursorLoadIconLoadImageLookupIconIdFromDirectoryMAKEINTRESOURCEReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int LookupIconIdFromDirectoryEx(byte presbits, bool fIcon, int cxDesired, int cyDesired, uint Flags);

        /// <summary>
        ///Converts the specified dialog box units to screen units (pixels). The function replaces the coordinates in the specified RECT structure with the converted coordinates, which allows the structure to be used to create a dialog box or position a control within a dialog box.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to a dialog box. This function accepts only handles returned by one of the dialog box creation functions; handles for other windows are not valid.</param>
        /// <param name="lpRect">Type: LPRECTA pointer to a RECT structure that contains the dialog box coordinates to be converted.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The MapDialogRect function assumes that the initial coordinates in the RECT structure represent dialog box units. To convert these coordinates from dialog box units to pixels, the function retrieves the current horizontal and vertical base units for the dialog box, then applies the following formulas:If the dialog box template has the DS_SETFONT or DS_SHELLFONT style, the base units are the average width and height, in pixels, of the characters in the font specified by the template.ConceptualDialog BoxesGetDialogBaseUnitsOther ResourcesRECTReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool MapDialogRect(nint hDlg, out RECT lpRect);

        /// <summary>
        ///Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code.
        /// </summary>
        /// <param name="uCode">Type: UINTThe virtual key code or scan code for a key. How this value is interpreted depends on the value of the uMapType parameter.Starting with Windows Vista, the high byte of the uCode value can contain either 0xe0 or 0xe1 to specify the extended scan code.</param>
        /// <param name="uMapType">Type: UINTThe translation to be performed. The value of this parameter depends on the value of the uCode parameter.Type: UINTThe return value is either a scan code, a virtual-key code, or a character value, depending on the value of uCode and uMapType. If there is no translation, the return value is zero.To specify a handle to the keyboard layout to use for translating the specified code, use the MapVirtualKeyEx function.An application can use MapVirtualKey to translate scan codes to the virtual-key code constants VK_SHIFT, VK_CONTROL, and VK_MENU, and vice versa. These translations do not distinguish between the left and right instances of the SHIFT, CTRL, or ALT keys.An application can get the scan code corresponding to the left or right instance of one of these keys by calling MapVirtualKey with uCode set to one of the following virtual-key code constants:These left- and right-distinguishing constants are available to an application only through the GetKeyboardState, SetKeyboardState, GetAsyncKeyState, GetKeyState, MapVirtualKey, and MapVirtualKeyEx functions. For list complete table of virtual key codes, see Virtual Key Codes.In MAPVK_VK_TO_CHAR mode virtual-key codes, the 'A'..'Z' keys are translated to upper-case 'A'..'Z' characters regardless of current keyboard layout. If you want to translate a virtual-key code to the corresponding character, use the ToAscii function.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint MapVirtualKeyA(uint uCode, uint uMapType);

        /// <summary>
        ///Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code. The function translates the codes using the input language and an input locale identifier.
        /// </summary>
        /// <param name="uCode">Type: UINTThe virtual key code or scan code for a key. How this value is interpreted depends on the value of the uMapType parameter.Starting with Windows Vista, the high byte of the uCode value can contain either 0xe0 or 0xe1 to specify the extended scan code.</param>
        /// <param name="uMapType">Type: UINTThe translation to perform. The value of this parameter depends on the value of the uCode parameter.</param>
        /// <param name="dwhkl"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint MapVirtualKeyExA(uint uCode, uint uMapType, out nint dwhkl);

        /// <summary>
        ///Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code. The function translates the codes using the input language and an input locale identifier.
        /// </summary>
        /// <param name="uCode">Type: UINTThe virtual key code or scan code for a key. How this value is interpreted depends on the value of the uMapType parameter.Starting with Windows Vista, the high byte of the uCode value can contain either 0xe0 or 0xe1 to specify the extended scan code.</param>
        /// <param name="uMapType">Type: UINTThe translation to perform. The value of this parameter depends on the value of the uCode parameter.</param>
        /// <param name="dwhkl"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint MapVirtualKeyExW(uint uCode, uint uMapType, out nint dwhkl);

        /// <summary>
        ///Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code.
        /// </summary>
        /// <param name="uCode">Type: UINTThe virtual key code or scan code for a key. How this value is interpreted depends on the value of the uMapType parameter.Starting with Windows Vista, the high byte of the uCode value can contain either 0xe0 or 0xe1 to specify the extended scan code.</param>
        /// <param name="uMapType">Type: UINTThe translation to be performed. The value of this parameter depends on the value of the uCode parameter.Type: UINTThe return value is either a scan code, a virtual-key code, or a character value, depending on the value of uCode and uMapType. If there is no translation, the return value is zero.To specify a handle to the keyboard layout to use for translating the specified code, use the MapVirtualKeyEx function.An application can use MapVirtualKey to translate scan codes to the virtual-key code constants VK_SHIFT, VK_CONTROL, and VK_MENU, and vice versa. These translations do not distinguish between the left and right instances of the SHIFT, CTRL, or ALT keys.An application can get the scan code corresponding to the left or right instance of one of these keys by calling MapVirtualKey with uCode set to one of the following virtual-key code constants:These left- and right-distinguishing constants are available to an application only through the GetKeyboardState, SetKeyboardState, GetAsyncKeyState, GetKeyState, MapVirtualKey, and MapVirtualKeyEx functions. For list complete table of virtual key codes, see Virtual Key Codes.In MAPVK_VK_TO_CHAR mode virtual-key codes, the 'A'..'Z' keys are translated to upper-case 'A'..'Z' characters regardless of current keyboard layout. If you want to translate a virtual-key code to the corresponding character, use the ToUnicode function.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint MapVirtualKeyW(uint uCode, uint uMapType);

        /// <summary>
        ///The MapWindowPoints function converts (maps) a set of points from a coordinate space relative to one window to a coordinate space relative to another window.
        /// </summary>
        /// <param name="hWndFrom">A handle to the window from which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are presumed to be in screen coordinates.</param>
        /// <param name="hWndTo">A handle to the window to which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are converted to screen coordinates.</param>
        /// <param name="lpPoints">A pointer to an array of POINT structures that contain the set of points to be converted. The points are in device units. This parameter can also point to a RECT structure, in which case the cPoints parameter should be set to 2.</param>
        /// <param name="cPoints">The number of POINT structures in the array pointed to by the lpPoints parameter.If the function succeeds, the low-order word of the return value is the number of pixels added to the horizontal coordinate of each source point in order to compute the horizontal coordinate of each destination point. (In addition to that, if precisely one of hWndFrom and hWndTo is mirrored, then each resulting horizontal coordinate is multiplied by -1.) The high-order word is the number of pixels added to the vertical coordinate of each source point in order to compute the vertical coordinate of each destination point.If the function fails, the return value is zero. Call SetLastError prior to calling this method to differentiate an error return value from a legitimate "0" return value.If hWndFrom or hWndTo (or both) are mirrored windows (that is, have WS_EX_LAYOUTRTL extended style) and precisely two points are passed in lpPoints, MapWindowPoints will interpret those two points as a RECT and possibly automatically swap the left and right fields of that rectangle to ensure that left is not greater than right. If any number of points other than 2 is passed in lpPoints, then MapWindowPoints will correctly map the coordinates of each of those points separately, so if you pass in a pointer to an array of more than one rectangle in lpPoints, the new rectangles may get their left field greater than right. Thus, to guarantee the correct transformation of rectangle coordinates, you must call MapWindowPoints with one RECT pointer at a time, as shown in the following example:Also, if you need to map precisely two independent points and don't want the RECT logic applied to them by MapWindowPoints, to guarantee the correct result you must call MapWindowPoints with one POINT pointer at a time, as shown in the following example:ClientToScreenCoordinate Space and Transformation FunctionsCoordinate Spaces and Transformations OverviewPOINTRECTScreenToClient</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int MapWindowPoints(nint hWndFrom, nint hWndTo, out POINT lpPoints, uint cPoints);

        /// <summary>
        ///Determines which menu item, if any, is at the specified location.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="hMenu">Type: HMENUA handle to the menu containing the menu items to hit test.</param>
        /// <param name="ptScreen">Type: POINTA structure that specifies the location to test. If hMenu specifies a menu bar, this parameter is in window coordinates. Otherwise, it is in client coordinates.Type: int</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int MenuItemFromPoint(nint hWnd, nint hMenu, POINT ptScreen);

        /// <summary>
        ///Plays a waveform sound. The waveform sound for each sound type is identified by an entry in the registry.
        /// </summary>
        /// <param name="uType">The sound to be played. The sounds are set by the user through the Sound control panel application, and then stored in the registry.This parameter can be one of the following values.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.After queuing the sound, the MessageBeep function returns control to the calling function and plays the sound asynchronously.If it cannot play the specified alert sound, MessageBeep attempts to play the system default sound. If it cannot play the system default sound, the function produces a standard beep sound through the computer speaker.The user can disable the warning beep by using the Sound control panel application.Note  To send a beep to a remote client, use the Beep function. The Beep function is redirected to the client, whereas MessageBeep is not.BeepError Handling FunctionsFlashWindowNotifying the User</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool MessageBeep(uint uType);

        /// <summary>
        ///Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message, such as status or error information. The message box returns an integer value that indicates which button the user clicked.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="lpText"></param>
        /// <param name="lpCaption"></param>
        /// <param name="uType">Type: UINTThe contents and behavior of the dialog box. This parameter can be a combination of flags from the following groups of flags.To indicate the buttons displayed in the message box, specify one of the following values.To display an icon in the message box, specify one of the following values.To indicate the default button, specify one of the following values.To indicate the modality of the dialog box, specify one of the following values.To specify other options, use one or more of the following values.Type: intIf a message box has a Cancel button, the function returns the IDCANCEL value if either the ESC key is pressed or the Cancel button is selected. If the message box has no Cancel button, pressing ESC will no effect - unless an MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be IDOK.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the function succeeds, the return value is one of the following menu-item values.The following system icons can be used in a message box by setting the uType parameter to the corresponding flag value.Adding two right-to-left marks (RLMs), represented by Unicode formatting character U+200F, in the beginning of a MessageBox display string is interpreted by the MessageBox rendering engine so as to cause the reading order of the MessageBox to be rendered as right-to-left (RTL).When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the lpText and lpCaption parameters should not be taken from a resource file because an attempt to load the resource may fail.If you create a message box while a dialog box is present, use a handle to the dialog box as the hWnd parameter. The hWnd parameter should not identify a child window, such as a control in a dialog box.In the following example, the application displays a message box that prompts the user for an action after an error condition has occurred. The message box displays the message that describes the error condition and how to resolve it. The MB_CANCELTRYCONTINUE style directs MessageBox to provide three buttons with which the user can choose how to proceed. The MB_DEFBUTTON2 style sets the default focus on the second button of the message box, in this case, the Try Again button.The following image shows the output from the preceding code example:For another message box example, see Displaying a Message Box.ConceptualDialog BoxesFlashWindowMessageBeepMessageBoxExMessageBoxIndirectOther ResourcesReferenceSetForegroundWindow</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int MessageBox(nint hWnd, string lpText, string lpCaption, uint uType);

        /// <summary>
        ///Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message, such as status or error information. The message box returns an integer value that indicates which button the user clicked.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="lpText"></param>
        /// <param name="lpCaption"></param>
        /// <param name="uType">Type: UINTThe contents and behavior of the dialog box. This parameter can be a combination of flags from the following groups of flags.To indicate the buttons displayed in the message box, specify one of the following values.To display an icon in the message box, specify one of the following values.To indicate the default button, specify one of the following values.To indicate the modality of the dialog box, specify one of the following values.To specify other options, use one or more of the following values.Type: intIf a message box has a Cancel button, the function returns the IDCANCEL value if either the ESC key is pressed or the Cancel button is selected. If the message box has no Cancel button, pressing ESC will no effect - unless an MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be IDOK.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the function succeeds, the return value is one of the following menu-item values.The following system icons can be used in a message box by setting the uType parameter to the corresponding flag value.Adding two right-to-left marks (RLMs), represented by Unicode formatting character U+200F, in the beginning of a MessageBox display string is interpreted by the MessageBox rendering engine so as to cause the reading order of the MessageBox to be rendered as right-to-left (RTL).When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the lpText and lpCaption parameters should not be taken from a resource file because an attempt to load the resource may fail.If you create a message box while a dialog box is present, use a handle to the dialog box as the hWnd parameter. The hWnd parameter should not identify a child window, such as a control in a dialog box.In the following example, the application displays a message box that prompts the user for an action after an error condition has occurred. The message box displays the message that describes the error condition and how to resolve it. The MB_CANCELTRYCONTINUE style directs MessageBox to provide three buttons with which the user can choose how to proceed. The MB_DEFBUTTON2 style sets the default focus on the second button of the message box, in this case, the Try Again button.The following image shows the output from the preceding code example:For another message box example, see Displaying a Message Box.ConceptualDialog BoxesFlashWindowMessageBeepMessageBoxExMessageBoxIndirectOther ResourcesReferenceSetForegroundWindow</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int MessageBoxA(nint hWnd, string lpText, string lpCaption, uint uType);

        /// <summary>
        ///Creates, displays, and operates a message box. The message box contains an application-defined message and title, plus any combination of predefined icons and push buttons. The buttons are in the language of the system user interface.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="lpText"></param>
        /// <param name="lpCaption"></param>
        /// <param name="uType">Type: UINTThe contents and behavior of the dialog box. For information on the supported flags, see MessageBox.</param>
        /// <param name="wLanguageId">Type: WORDThe language for the text displayed in the message box button(s). Specifying a value of zero (0) indicates to display the button text in the default system language. If this parameter is MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), the current language associated with the calling thread is used.To specify a language other than the current language, use the MAKELANGID macro to create this parameter. For more information, see MAKELANGID.Type: intIf a message box has a Cancel button, the function returns the IDCANCEL value if either the ESC key is pressed or the Cancel button is selected. If the message box has no Cancel button, pressing ESC will no effect - unless an MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be IDOK.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the function succeeds, the return value is one of the following menu-item values.When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the lpText and lpCaption parameters should not be taken from a resource file because an attempt to load the resource may fail.If you create a message box while a dialog box is present, use a handle to the dialog box as the hWnd parameter. The hWnd parameter should not identify a child window, such as a control in a dialog box.ConceptualDialog BoxesMAKELANGIDMessageBeepMessageBoxMessageBoxIndirectOther ResourcesReferenceSetForegroundWindow</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int MessageBoxExA(nint hWnd, string lpText, string lpCaption, uint uType, short wLanguageId);

        /// <summary>
        ///Creates, displays, and operates a message box. The message box contains an application-defined message and title, plus any combination of predefined icons and push buttons. The buttons are in the language of the system user interface.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="lpText"></param>
        /// <param name="lpCaption"></param>
        /// <param name="uType">Type: UINTThe contents and behavior of the dialog box. For information on the supported flags, see MessageBox.</param>
        /// <param name="wLanguageId">Type: WORDThe language for the text displayed in the message box button(s). Specifying a value of zero (0) indicates to display the button text in the default system language. If this parameter is MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), the current language associated with the calling thread is used.To specify a language other than the current language, use the MAKELANGID macro to create this parameter. For more information, see MAKELANGID.Type: intIf a message box has a Cancel button, the function returns the IDCANCEL value if either the ESC key is pressed or the Cancel button is selected. If the message box has no Cancel button, pressing ESC will no effect - unless an MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be IDOK.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the function succeeds, the return value is one of the following menu-item values.When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the lpText and lpCaption parameters should not be taken from a resource file because an attempt to load the resource may fail.If you create a message box while a dialog box is present, use a handle to the dialog box as the hWnd parameter. The hWnd parameter should not identify a child window, such as a control in a dialog box.ConceptualDialog BoxesMAKELANGIDMessageBeepMessageBoxMessageBoxIndirectOther ResourcesReferenceSetForegroundWindow</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int MessageBoxExW(nint hWnd, string lpText, string lpCaption, uint uType, short wLanguageId);

        /// <summary>
        ///Creates, displays, and operates a message box. The message box contains application-defined message text and title, any icon, and any combination of predefined push buttons.
        /// </summary>
        /// <param name="lpmbp">Type: const LPMSGBOXPARAMSA pointer to a MSGBOXPARAMS structure that contains information used to display the message box.Type: intIf the function succeeds, the return value is one of the following menu-item values.If a message box has a Cancel button, the function returns the IDCANCEL value if either the ESC key is pressed or the Cancel button is selected. If the message box has no Cancel button, pressing ESC has no effect.If there is not enough memory to create the message box, the return value is zero.When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the lpszText and lpszCaption members of the MSGBOXPARAMS structure should not be taken from a resource file, because an attempt to load the resource may fail.If you create a message box while a dialog box is present, use a handle to the dialog box as the hWnd parameter. The hWnd parameter should not identify a child window, such as a control in a dialog box.ConceptualDialog BoxesMSGBOXPARAMSMessageBoxMessageBoxExReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int MessageBoxIndirectA(MSGBOXPARAMSA lpmbp);

        /// <summary>
        ///Creates, displays, and operates a message box. The message box contains application-defined message text and title, any icon, and any combination of predefined push buttons.
        /// </summary>
        /// <param name="lpmbp">Type: const LPMSGBOXPARAMSA pointer to a MSGBOXPARAMS structure that contains information used to display the message box.Type: intIf the function succeeds, the return value is one of the following menu-item values.If a message box has a Cancel button, the function returns the IDCANCEL value if either the ESC key is pressed or the Cancel button is selected. If the message box has no Cancel button, pressing ESC has no effect.If there is not enough memory to create the message box, the return value is zero.When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the lpszText and lpszCaption members of the MSGBOXPARAMS structure should not be taken from a resource file, because an attempt to load the resource may fail.If you create a message box while a dialog box is present, use a handle to the dialog box as the hWnd parameter. The hWnd parameter should not identify a child window, such as a control in a dialog box.ConceptualDialog BoxesMSGBOXPARAMSMessageBoxMessageBoxExReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int MessageBoxIndirectW(MSGBOXPARAMSW lpmbp);

        /// <summary>
        ///Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message, such as status or error information. The message box returns an integer value that indicates which button the user clicked.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="lpText"></param>
        /// <param name="lpCaption"></param>
        /// <param name="uType">Type: UINTThe contents and behavior of the dialog box. This parameter can be a combination of flags from the following groups of flags.To indicate the buttons displayed in the message box, specify one of the following values.To display an icon in the message box, specify one of the following values.To indicate the default button, specify one of the following values.To indicate the modality of the dialog box, specify one of the following values.To specify other options, use one or more of the following values.Type: intIf a message box has a Cancel button, the function returns the IDCANCEL value if either the ESC key is pressed or the Cancel button is selected. If the message box has no Cancel button, pressing ESC will no effect - unless an MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be IDOK.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the function succeeds, the return value is one of the following menu-item values.The following system icons can be used in a message box by setting the uType parameter to the corresponding flag value.Adding two right-to-left marks (RLMs), represented by Unicode formatting character U+200F, in the beginning of a MessageBox display string is interpreted by the MessageBox rendering engine so as to cause the reading order of the MessageBox to be rendered as right-to-left (RTL).When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the lpText and lpCaption parameters should not be taken from a resource file because an attempt to load the resource may fail.If you create a message box while a dialog box is present, use a handle to the dialog box as the hWnd parameter. The hWnd parameter should not identify a child window, such as a control in a dialog box.In the following example, the application displays a message box that prompts the user for an action after an error condition has occurred. The message box displays the message that describes the error condition and how to resolve it. The MB_CANCELTRYCONTINUE style directs MessageBox to provide three buttons with which the user can choose how to proceed. The MB_DEFBUTTON2 style sets the default focus on the second button of the message box, in this case, the Try Again button.The following image shows the output from the preceding code example:For another message box example, see Displaying a Message Box.ConceptualDialog BoxesFlashWindowMessageBeepMessageBoxExMessageBoxIndirectOther ResourcesReferenceSetForegroundWindow</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int MessageBoxW(nint hWnd, string lpText, string lpCaption, uint uType);

        /// <summary>
        ///Changes an existing menu item. This function is used to specify the content, appearance, and behavior of the menu item.
        /// </summary>
        /// <param name="hMnu">Type: HMENUA handle to the menu to be changed.</param>
        /// <param name="uPosition">Type: UINTThe menu item to be changed, as determined by the uFlags parameter.</param>
        /// <param name="uFlags">Type: UINTControls the interpretation of the uPosition parameter and the content, appearance, and behavior of the menu item. This parameter must include one of the following required values.The parameter must also include at least one of the following values.</param>
        /// <param name="uIDNewItem">Type: UINT_PTRThe identifier of the modified menu item or, if the uFlags parameter has the MF_POPUP flag set, a handle to the drop-down menu or submenu.</param>
        /// <param name="lpNewItem"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ModifyMenuA(nint hMnu, uint uPosition, uint uFlags, nint uIDNewItem, string lpNewItem);

        /// <summary>
        ///Changes an existing menu item. This function is used to specify the content, appearance, and behavior of the menu item.
        /// </summary>
        /// <param name="hMnu">Type: HMENUA handle to the menu to be changed.</param>
        /// <param name="uPosition">Type: UINTThe menu item to be changed, as determined by the uFlags parameter.</param>
        /// <param name="uFlags">Type: UINTControls the interpretation of the uPosition parameter and the content, appearance, and behavior of the menu item. This parameter must include one of the following required values.The parameter must also include at least one of the following values.</param>
        /// <param name="uIDNewItem">Type: UINT_PTRThe identifier of the modified menu item or, if the uFlags parameter has the MF_POPUP flag set, a handle to the drop-down menu or submenu.</param>
        /// <param name="lpNewItem"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ModifyMenuW(nint hMnu, uint uPosition, uint uFlags, nint uIDNewItem, string lpNewItem);

        /// <summary>
        ///The MonitorFromPoint function retrieves a handle to the display monitor that contains a specified point.
        /// </summary>
        /// <param name="pt">A POINT structure that specifies the point of interest in virtual-screen coordinates.</param>
        /// <param name="dwFlags">Determines the function's return value if the point is not contained within any display monitor.This parameter can be one of the following values.If the point is contained by a display monitor, the return value is an HMONITOR handle to that display monitor.If the point is not contained by a display monitor, the return value depends on the value of dwFlags.MonitorFromRectMonitorFromWindowMultiple Display Monitors FunctionsMultiple Display Monitors Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint MonitorFromPoint(POINT pt, uint dwFlags);

        /// <summary>
        ///The MonitorFromRect function retrieves a handle to the display monitor that has the largest area of intersection with a specified rectangle.
        /// </summary>
        /// <param name="lprc">A pointer to a RECT structure that specifies the rectangle of interest in virtual-screen coordinates.</param>
        /// <param name="dwFlags">Determines the function's return value if the rectangle does not intersect any display monitor.This parameter can be one of the following values.If the rectangle intersects one or more display monitor rectangles, the return value is an HMONITOR handle to the display monitor that has the largest area of intersection with the rectangle.If the rectangle does not intersect a display monitor, the return value depends on the value of dwFlags.MonitorFromPointMonitorFromWindowMultiple Display Monitors FunctionsMultiple Display Monitors Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint MonitorFromRect(RECT lprc, uint dwFlags);

        /// <summary>
        ///The MonitorFromWindow function retrieves a handle to the display monitor that has the largest area of intersection with the bounding rectangle of a specified window.
        /// </summary>
        /// <param name="hwnd">A handle to the window of interest.</param>
        /// <param name="dwFlags">Determines the function's return value if the window does not intersect any display monitor.This parameter can be one of the following values.If the window intersects one or more display monitor rectangles, the return value is an HMONITOR handle to the display monitor that has the largest area of intersection with the window.If the window does not intersect a display monitor, the return value depends on the value of dwFlags.If the window is currently minimized, MonitorFromWindow uses the rectangle of the window before it was minimized.MonitorFromPointMonitorFromRectMultiple Display Monitors FunctionsMultiple Display Monitors Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint MonitorFromWindow(nint hwnd, uint dwFlags);

        /// <summary>
        ///The mouse_event function synthesizes mouse motion and button clicks.
        /// </summary>
        /// <param name="dwFlags">Type: DWORDControls various aspects of mouse motion and button clicking. This parameter can be certain combinations of the following values.The values that specify mouse button status are set to indicate changes in status, not ongoing conditions. For example, if the left mouse button is pressed and held down, MOUSEEVENTF_LEFTDOWN is set when the left button is first pressed, but not for subsequent motions. Similarly, MOUSEEVENTF_LEFTUP is set only when the button is first released.You cannot specify both MOUSEEVENTF_WHEEL and either MOUSEEVENTF_XDOWN or MOUSEEVENTF_XUP simultaneously in the dwFlags parameter, because they both require use of the dwData field.</param>
        /// <param name="dx">Type: DWORDThe mouse's absolute position along the x-axis or its amount of motion since the last mouse event was generated, depending on the setting of MOUSEEVENTF_ABSOLUTE. Absolute data is specified as the mouse's actual x-coordinate; relative data is specified as the number of mickeys moved. A mickey is the amount that a mouse has to move for it to report that it has moved.</param>
        /// <param name="dy">Type: DWORDThe mouse's absolute position along the y-axis or its amount of motion since the last mouse event was generated, depending on the setting of MOUSEEVENTF_ABSOLUTE. Absolute data is specified as the mouse's actual y-coordinate; relative data is specified as the number of mickeys moved.</param>
        /// <param name="dwData">Type: DWORDIf dwFlags contains MOUSEEVENTF_WHEEL, then dwData specifies the amount of wheel movement. A positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel was rotated backward, toward the user. One wheel click is defined as WHEEL_DELTA, which is 120.If dwFlags contains MOUSEEVENTF_HWHEEL, then dwData specifies the amount of wheel movement. A positive value indicates that the wheel was tilted to the right; a negative value indicates that the wheel was tilted to the left.If dwFlags contains MOUSEEVENTF_XDOWN or MOUSEEVENTF_XUP, then dwData specifies which X buttons were pressed or released. This value may be any combination of the following flags.If dwFlags is not MOUSEEVENTF_WHEEL, MOUSEEVENTF_XDOWN, or MOUSEEVENTF_XUP, then dwData should be zero.</param>
        /// <param name="dwExtraInfo">Type: ULONG_PTRAn additional value associated with the mouse event. An application calls GetMessageExtraInfo to obtain this extra information.NoneIf the mouse has moved, indicated by MOUSEEVENTF_MOVE being set, dx and dy hold information about that motion. The information is specified as absolute or relative integer values.If MOUSEEVENTF_ABSOLUTE value is specified, dx and dy contain normalized absolute coordinates between 0 and 65,535. The event procedure maps these coordinates onto the display surface. Coordinate (0,0) maps onto the upper-left corner of the display surface, (65535,65535) maps onto the lower-right corner.If the MOUSEEVENTF_ABSOLUTE value is not specified, dx and dy specify relative motions from when the last mouse event was generated (the last reported position). Positive values mean the mouse moved right (or down); negative values mean the mouse moved left (or up).Relative mouse motion is subject to the settings for mouse speed and acceleration level. An end user sets these values using the Mouse application in Control Panel. An application obtains and sets these values with the SystemParametersInfo function.The system applies two tests to the specified relative mouse motion when applying acceleration. If the specified distance along either the x or y axis is greater than the first mouse threshold value, and the mouse acceleration level is not zero, the operating system doubles the distance. If the specified distance along either the x- or y-axis is greater than the second mouse threshold value, and the mouse acceleration level is equal to two, the operating system doubles the distance that resulted from applying the first threshold test. It is thus possible for the operating system to multiply relatively-specified mouse motion along the x- or y-axis by up to four times.Once acceleration has been applied, the system scales the resultant value by the desired mouse speed. Mouse speed can range from 1 (slowest) to 20 (fastest) and represents how much the pointer moves based on the distance the mouse moves. The default value is 10, which results in no additional modification to the mouse motion.The mouse_event function is used to synthesize mouse events by applications that need to do so. It is also used by applications that need to obtain more information from the mouse than its position and button state. For example, if a tablet manufacturer wants to pass pen-based information to its own applications, it can write a DLL that communicates directly to the tablet hardware, obtains the extra information, and saves it in a queue. The DLL then calls mouse_event with the standard button and x/y position data, along with, in the dwExtraInfo parameter, some pointer or index to the queued extra information. When the application needs the extra information, it calls the DLL with the pointer or index stored in dwExtraInfo, and the DLL returns the extra information.ConceptualGetMessageExtraInfoMouse InputOther ResourcesReferenceSystemParametersInfo</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void mouse_event(uint dwFlags, uint dx, uint dy, uint dwData, uint dwExtraInfo);

        /// <summary>
        ///Changes the position and dimensions of the specified window. For a top-level window, the position and dimensions are relative to the upper-left corner of the screen. For a child window, they are relative to the upper-left corner of the parent window's client area.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window.</param>
        /// <param name="X">Type: intThe new position of the left side of the window.</param>
        /// <param name="Y">Type: intThe new position of the top of the window.</param>
        /// <param name="nWidth">Type: intThe new width of the window.</param>
        /// <param name="nHeight">Type: intThe new height of the window.</param>
        /// <param name="bRepaint">Type: BOOLIndicates whether the window is to be repainted. If this parameter is TRUE, the window receives a message. If the parameter is FALSE, no repainting of any kind occurs. This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of moving a child window.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the bRepaint parameter is TRUE, the system sends the WM_PAINT message to the window procedure immediately after moving the window (that is, the MoveWindow function calls the UpdateWindow function). If bRepaint is FALSE, the application must explicitly invalidate or redraw any parts of the window and parent window that need redrawing.MoveWindow sends the WM_WINDOWPOSCHANGING, WM_WINDOWPOSCHANGED, WM_MOVE, WM_SIZE, and WM_NCCALCSIZE messages to the window.For an example, see Creating, Enumerating, and Sizing Child Windows.ConceptualOther ResourcesReferenceSetWindowPosUpdateWindowWM_GETMINMAXINFOWM_PAINTWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool MoveWindow(nint hWnd, int X, int Y, int nWidth, int nHeight, bool bRepaint);

        /// <summary>
        ///Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. The objects can include input event objects, which you specify using the dwWakeMask parameter.
        /// </summary>
        /// <param name="nCount">The number of object handles in the array pointed to by pHandles. The maximum number of object handles is MAXIMUM_WAIT_OBJECTS minus one. If this parameter has the value zero, then the function waits only for an input event.</param>
        /// <param name="pHandles">An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can contain handles of objects of different types. It may not contain multiple copies of the same handle.If one of these handles is closed while the wait is still pending, the function's behavior is undefined.The handles must have the SYNCHRONIZE access right. For more information, see Standard Access Rights.</param>
        /// <param name="fWaitAll">If this parameter is TRUE, the function returns when the states of all objects in the pHandles array have been set to signaled and an input event has been received. If this parameter is FALSE, the function returns when the state of any one of the objects is set to signaled or an input event has been received. In this case, the return value indicates the object whose state caused the function to return.</param>
        /// <param name="dwMilliseconds">The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the specified objects are not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the specified objects are signaled.Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  The dwMilliseconds value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  The dwMilliseconds value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</param>
        /// <param name="dwWakeMask">The input types for which an input event object handle will be added to the array of object handles. This parameter can be any combination of the values listed in GetQueueStatus flags parameter.If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that WAIT_OBJECT_0 is defined as 0 and WAIT_ABANDONED_0 is defined as 0x00000080L.)The MsgWaitForMultipleObjects function determines whether the wait criteria have been met. If the criteria have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses.When bWaitAll is TRUE, the function does not modify the states of the specified objects until the states of all objects have been set to signaled. For example, a mutex can be signaled, but the thread does not get ownership until the states of the other objects have also been set to signaled. In the meantime, some other thread may get ownership of the mutex, thereby setting its state to nonsignaled.When bWaitAll is TRUE, the function's wait is completed only when the states of all objects have been set to signaled and an input event has been received. Therefore, setting bWaitAll to TRUE prevents input from being processed until the state of all objects in the pHandles array have been set to signaled. For this reason, if you set bWaitAll to TRUE, you should use a short timeout value in dwMilliseconds. If you have a thread that creates windows waiting for all objects in the pHandles array, including input events specified by dwWakeMask, with no timeout interval, the system will deadlock. This is because threads that create windows must process messages. DDE sends message to all windows in the system. Therefore, if a thread creates windows, do not set the bWaitAll parameter to TRUE in calls to MsgWaitForMultipleObjects made from that thread.When bWaitAll is FALSE, this function checks the handles in the array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled.MsgWaitForMultipleObjects does not return if there is unread input of the specified type in the message queue after the thread has called a function to check the queue. This is because functions such as PeekMessage, GetMessage, GetQueueStatus, and WaitMessage check the queue and then change the state information for the queue so that the input is no longer considered new. A subsequent call to MsgWaitForMultipleObjects will not return until new input of the specified type arrives. The existing unread input (received prior to the last time the thread checked the queue) is ignored.The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects whose signaled state caused the function to return. For example, the count of a semaphore object is decreased by one. For more information, see the documentation for the individual synchronization objects.The MsgWaitForMultipleObjects function can specify handles of any of the following object types in the pHandles array:MsgWaitForMultipleObjectsExSynchronization FunctionsWait Functions</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint MsgWaitForMultipleObjects(uint nCount, nint pHandles, bool fWaitAll, uint dwMilliseconds, uint dwWakeMask);

        /// <summary>
        ///Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses. The array of objects can include input event objects, which you specify using the dwWakeMask parameter.
        /// </summary>
        /// <param name="nCount">The number of object handles in the array pointed to by pHandles. The maximum number of object handles is MAXIMUM_WAIT_OBJECTS minus one. If this parameter has the value zero, then the function waits only for an input event.</param>
        /// <param name="pHandles">An array of object handles. For a list of the object types whose handles you can specify, see the Remarks section later in this topic. The array can contain handles to multiple types of objects. It may not contain multiple copies of the same handle.If one of these handles is closed while the wait is still pending, the function's behavior is undefined.The handles must have the SYNCHRONIZE access right. For more information, see Standard Access Rights.</param>
        /// <param name="dwMilliseconds">The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled, an I/O completion routine or APC is queued, or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the criteria is not met; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the specified objects are signaled or an I/O completion routine or APC is queued.Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  The dwMilliseconds value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  The dwMilliseconds value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</param>
        /// <param name="dwWakeMask">The input types for which an input event object handle will be added to the array of object handles. This parameter can be any combination of the values listed in GetQueueStatus flags parameter.</param>
        /// <param name="dwFlags">The wait type. This parameter can be one or more of the following values.If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that WAIT_OBJECT_0 is defined as 0 and WAIT_ABANDONED_0 is defined as 0x00000080L.)The MsgWaitForMultipleObjectsEx function determines whether the conditions specified by dwWakeMask and dwFlags have been met. If the conditions have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses.When dwFlags is zero, this function checks the handles in the array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled.MsgWaitForMultipleObjectsEx does not return if there is unread input of the specified type in the message queue after the thread has called a function to check the queue, unless you use the MWMO_INPUTAVAILABLE flag. This is because functions such as PeekMessage, GetMessage, GetQueueStatus, and WaitMessage check the queue and then change the state information for the queue so that the input is no longer considered new. A subsequent call to MsgWaitForMultipleObjectsEx will not return until new input of the specified type arrives, unless you use the MWMO_INPUTAVAILABLE flag. If this flag is not used, the existing unread input (received prior to the last time the thread checked the queue) is ignored.The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects whose signaled state caused the function to return. For example, the system decreases the count of a semaphore object by one. For more information, see the documentation for the individual synchronization objects.The MsgWaitForMultipleObjectsEx function can specify handles of any of the following object types in the pHandles array:Synchronization FunctionsWait Functions</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint MsgWaitForMultipleObjectsEx(uint nCount, nint pHandles, uint dwMilliseconds, uint dwWakeMask, uint dwFlags);

        /// <summary>
        ///Signals the system that a predefined event occurred. If any client applications have registered a hook function for the event, the system calls the client's hook function.
        /// </summary>
        /// <param name="event">Type: DWORDSpecifies the event that occurred. This value must be one of the event constants.</param>
        /// <param name="hwnd">Type: HWNDHandle to the window that contains the object that generated the event.</param>
        /// <param name="idObject">Type: LONGIdentifies the object that generated the event. This value is either one of the predefined object identifiers or a custom object ID value.</param>
        /// <param name="idChild">Type: LONGIdentifies whether the event was generated by an object or by a child element of the object. If this value is CHILDID_SELF, the event was generated by the object itself. If not CHILDID_SELF, this value is the child ID of the element that generated the event.NoneServers call this function to notify the system that an event has occurred. Microsoft Active Accessibility checks to see if any client applications have set hook procedures for the event and, if so, calls the appropriate hook procedures.If no hook procedures are registered for the event, the performance penalty for calling this function is minor.Servers call NotifyWinEvent to announce the event to the system after the event has occurred; they must never notify the system of an event before the event has occurred.When the client's hook procedure is called, it receives a number of parameters that describe the event and the object that generated the event. The hook procedure uses the AccessibleObjectFromEvent function to retrieve a pointer to the IAccessible interface of the object that generated the event.Servers may receive a WM_GETOBJECT message immediately after calling this function. This can happen if there are any in-context clients that call AccessibleObjectFromEvent in the event callback.When servers call this function, they must be ready to handle WM_GETOBJECT, return an IAccessible interface pointer, and handle any of the IAccessible methods.Note to Server Developers:  When you call NotifyWinEvent, if any clients are listening for that event in-context, their event handlers, which typically send WM_GETOBJECT and call IAccessible methods, will execute before NotifyWinEvent returns. When you call NotifyWinEvent, you should be prepared to handle these calls, if they occur. If you need to do extra setup to allow for this, you should do so before you call NotifyWinEvent, not after.AccessibleObjectFromEventSetWinEventHookUnHookWinEventWinEvents</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void NotifyWinEvent(uint @event, nint hwnd, int idObject, int idChild);

        /// <summary>
        ///Maps OEMASCII codes 0 through 0x0FF into the OEM scan codes and shift states. The function provides information that allows a program to send OEM text to another program by simulating keyboard input.
        /// </summary>
        /// <param name="wOemChar">Type: WORDThe ASCII value of the OEM character.Type: DWORDThe low-order word of the return value contains the scan code of the OEM character, and the high-order word contains the shift state, which can be a combination of the following bits.If the character cannot be produced by a single keystroke using the current keyboard layout, the return value is –1.This function does not provide translations for characters that require CTRL+ALT or dead keys. Characters not translated by this function must be copied by simulating input using the ALT+ keypad mechanism. The NUMLOCK key must be off.This function does not provide translations for characters that cannot be typed with one keystroke using the current keyboard layout, such as characters with diacritics requiring dead keys. Characters not translated by this function may be simulated using the ALT+ keypad mechanism. The NUMLOCK key must be on.This function is implemented using the VkKeyScan function.ConceptualKeyboard InputReferenceVkKeyScan</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint OemKeyScan(short wOemChar);

        /// <summary>
        ///Translates a string from the OEM-defined character set into either an ANSI or a wide-character string.
        /// </summary>
        /// <param name="pSrc">Type: LPCSTRA null-terminated string of characters from the OEM-defined character set.</param>
        /// <param name="pDst"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool OemToCharA(string pSrc, out string pDst);

        /// <summary>
        ///Translates a specified number of characters in a string from the OEM-defined character set into either an ANSI or a wide-character string.
        /// </summary>
        /// <param name="lpszSrc">Type: LPCSTROne or more characters from the OEM-defined character set.</param>
        /// <param name="lpszDst"></param>
        /// <param name="cchDstLength">Type: DWORDThe number of characters to be translated in the buffer identified by the lpszSrc parameter.Type: BOOLThe return value is always nonzero except when you pass the same address to lpszSrc and lpszDst in the wide-character version of the function. In this case the function returns zero and GetLastError returns ERROR_INVALID_ADDRESS.Unlike the OemToChar function, the OemToCharBuff function does not stop converting characters when it encounters a null character in the buffer pointed to by lpszSrc. The OemToCharBuff function converts all cchDstLength characters.CharToOemCharToOemBuffConceptualOemToCharReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool OemToCharBuffA(string lpszSrc, out string lpszDst, uint cchDstLength);

        /// <summary>
        ///Translates a specified number of characters in a string from the OEM-defined character set into either an ANSI or a wide-character string.
        /// </summary>
        /// <param name="lpszSrc">Type: LPCSTROne or more characters from the OEM-defined character set.</param>
        /// <param name="lpszDst"></param>
        /// <param name="cchDstLength">Type: DWORDThe number of characters to be translated in the buffer identified by the lpszSrc parameter.Type: BOOLThe return value is always nonzero except when you pass the same address to lpszSrc and lpszDst in the wide-character version of the function. In this case the function returns zero and GetLastError returns ERROR_INVALID_ADDRESS.Unlike the OemToChar function, the OemToCharBuff function does not stop converting characters when it encounters a null character in the buffer pointed to by lpszSrc. The OemToCharBuff function converts all cchDstLength characters.CharToOemCharToOemBuffConceptualOemToCharReferenceStrings</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool OemToCharBuffW(string lpszSrc, out string lpszDst, uint cchDstLength);

        /// <summary>
        ///Translates a string from the OEM-defined character set into either an ANSI or a wide-character string.
        /// </summary>
        /// <param name="pSrc">Type: LPCSTRA null-terminated string of characters from the OEM-defined character set.</param>
        /// <param name="pDst"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool OemToCharW(string pSrc, out string pDst);

        /// <summary>
        ///The OffsetRect function moves the specified rectangle by the specified offsets.
        /// </summary>
        /// <param name="lprc">Pointer to a RECT structure that contains the logical coordinates of the rectangle to be moved.</param>
        /// <param name="dx">Specifies the amount to move the rectangle left or right. This parameter must be a negative value to move the rectangle to the left.</param>
        /// <param name="dy">Specifies the amount to move the rectangle up or down. This parameter must be a negative value to move the rectangle up.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure.For an example, see Using Rectangles.InflateRectIntersectRectRECTRectangle FunctionsRectangles OverviewUnionRect</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool OffsetRect(out RECT lprc, int dx, int dy);

        /// <summary>
        ///Opens the clipboard for examination and prevents other applications from modifying the clipboard content.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool OpenClipboard(nint hWndNewOwner);

        /// <summary>
        ///Opens the specified desktop object.
        /// </summary>
        /// <param name="lpszDesktop">The name of the desktop to be opened. Desktop names are case-insensitive.This desktop must belong to the current window station.</param>
        /// <param name="dwFlags">This parameter can be zero or the following value.</param>
        /// <param name="fInherit">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name="dwDesiredAccess">The access to the desktop. For a list of access rights, see Desktop Security and Access Rights.If the function succeeds, the return value is a handle to the opened desktop. When you are finished using the handle, call the CloseDesktop function to close it.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The calling process must have an associated window station, either assigned by the system at process creation time or set by the SetProcessWindowStation function.If the dwDesiredAccess parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.CloseDesktopCreateDesktopDesktopsOpenInputDesktopSetProcessWindowStationSetThreadDesktopSwitchDesktopWindow Station and Desktop Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint OpenDesktopA(string lpszDesktop, uint dwFlags, bool fInherit, ACCESSTIMEOUT dwDesiredAccess);

        /// <summary>
        ///Opens the specified desktop object.
        /// </summary>
        /// <param name="lpszDesktop">The name of the desktop to be opened. Desktop names are case-insensitive.This desktop must belong to the current window station.</param>
        /// <param name="dwFlags">This parameter can be zero or the following value.</param>
        /// <param name="fInherit">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name="dwDesiredAccess">The access to the desktop. For a list of access rights, see Desktop Security and Access Rights.If the function succeeds, the return value is a handle to the opened desktop. When you are finished using the handle, call the CloseDesktop function to close it.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The calling process must have an associated window station, either assigned by the system at process creation time or set by the SetProcessWindowStation function.If the dwDesiredAccess parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.CloseDesktopCreateDesktopDesktopsOpenInputDesktopSetProcessWindowStationSetThreadDesktopSwitchDesktopWindow Station and Desktop Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint OpenDesktopW(string lpszDesktop, uint dwFlags, bool fInherit, ACCESSTIMEOUT dwDesiredAccess);

        /// <summary>
        ///Restores a minimized (iconic) window to its previous size and position; it then activates the window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to be restored and activated.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.OpenIcon sends a WM_QUERYOPEN message to the given window.CloseWindowConceptualIsIconicReferenceShowWindowWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool OpenIcon(nint hWnd);

        /// <summary>
        ///Opens the desktop that receives user input.
        /// </summary>
        /// <param name="dwFlags">This parameter can be zero or the following value.</param>
        /// <param name="fInherit">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name="dwDesiredAccess">The access to the desktop. For a list of access rights, see Desktop Security and Access Rights.If the function succeeds, the return value is a handle to the desktop that receives user input. When you are finished using the handle, call the CloseDesktop function to close it.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The calling process must have an associated window station, either assigned by the system when the process is created, or set by the SetProcessWindowStation function. The window station associated with the calling process must be capable of receiving input.If the calling process is running in a disconnected session, the function returns a handle to the desktop that becomes active when the user restores the connection.An application can use the SwitchDesktop function to change the input desktop.If the dwDesiredAccess parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.CloseDesktopDesktopsSetProcessWindowStationSwitchDesktopWindow Station and Desktop Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint OpenInputDesktop(uint dwFlags, bool fInherit, ACCESSTIMEOUT dwDesiredAccess);

        /// <summary>
        ///Opens the specified window station.
        /// </summary>
        /// <param name="lpszWinSta">The name of the window station to be opened. Window station names are case-insensitive.This window station must belong to the current session.</param>
        /// <param name="fInherit">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name="dwDesiredAccess">The access to the window station. For a list of access rights, see Window Station Security and Access Rights.If the function succeeds, the return value is the handle to the specified window station.If the function fails, the return value is NULL. To get extended error information, call GetLastError.After you are done with the handle, you must call CloseWindowStation to free the handle.CloseWindowStationExitWindowsExitWindowsExWindow Station and Desktop FunctionsWindow Stations</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int OpenWindowStationA(string lpszWinSta, bool fInherit, ACCESSTIMEOUT dwDesiredAccess);

        /// <summary>
        ///Opens the specified window station.
        /// </summary>
        /// <param name="lpszWinSta">The name of the window station to be opened. Window station names are case-insensitive.This window station must belong to the current session.</param>
        /// <param name="fInherit">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
        /// <param name="dwDesiredAccess">The access to the window station. For a list of access rights, see Window Station Security and Access Rights.If the function succeeds, the return value is the handle to the specified window station.If the function fails, the return value is NULL. To get extended error information, call GetLastError.After you are done with the handle, you must call CloseWindowStation to free the handle.CloseWindowStationExitWindowsExitWindowsExWindow Station and Desktop FunctionsWindow Stations</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int OpenWindowStationW(string lpszWinSta, bool fInherit, ACCESSTIMEOUT dwDesiredAccess);

        /// <summary>
        ///Returns the proximity evaluation score and the adjusted touch-point coordinates as a packed value for the WM_TOUCHHITTESTING callback.
        /// </summary>
        /// <param name="pHitTestingInput">The TOUCH_HIT_TESTING_INPUT structure that holds the data for the touch contact area.</param>
        /// <param name="pProximityEval">The TOUCH_HIT_TESTING_PROXIMITY_EVALUATION structure that holds the score and adjusted touch-point data that the EvaluateProximityToPolygon or EvaluateProximityToRect function returns.If this function succeeds, it returns the score and adjustedPoint values from TOUCH_HIT_TESTING_PROXIMITY_EVALUATION as an LRESULT. To retrieve extended error information, call the GetLastError function.Usually, this is the last function that's called in a WM_TOUCHHITTESTING handler.FunctionsTouch Hit Testing Scores</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint PackTouchHitTestingProximityEvaluation(TOUCH_HIT_TESTING_INPUT pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION pProximityEval);

        /// <summary>
        ///The PaintDesktop function fills the clipping region in the specified device context with the desktop pattern or wallpaper. The function is provided primarily for shell desktops.
        /// </summary>
        /// <param name="hdc">Handle to the device context.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.Painting and Drawing FunctionsPainting and Drawing Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool PaintDesktop(nint hdc);

        /// <summary>
        ///Dispatches incoming nonqueued messages, checks the thread message queue for a posted message, and retrieves the message (if any exist).
        /// </summary>
        /// <param name="lpMsg"></param>
        /// <param name="hWnd"></param>
        /// <param name="wMsgFilterMin">Type: UINTThe value of the first message in the range of messages to be examined. Use WM_KEYFIRST (0x0100) to specify the first keyboard message or WM_MOUSEFIRST (0x0200) to specify the first mouse message.If wMsgFilterMin and wMsgFilterMax are both zero, PeekMessage returns all available messages (that is, no range filtering is performed).</param>
        /// <param name="wMsgFilterMax">Type: UINTThe value of the last message in the range of messages to be examined. Use WM_KEYLAST to specify the last keyboard message or WM_MOUSELAST to specify the last mouse message.If wMsgFilterMin and wMsgFilterMax are both zero, PeekMessage returns all available messages (that is, no range filtering is performed).</param>
        /// <param name="wRemoveMsg">Type: UINTSpecifies how messages are to be handled. This parameter can be one or more of the following values.By default, all message types are processed. To specify that only certain message should be processed, specify one or more of the following values.Type: BOOLIf a message is available, the return value is nonzero.If no messages are available, the return value is zero.PeekMessage retrieves messages associated with the window identified by the hWnd parameter or any of its children as specified by the IsChild function, and within the range of message values given by the wMsgFilterMin and wMsgFilterMax parameters. Note that an application can only use the low word in the wMsgFilterMin and wMsgFilterMax parameters; the high word is reserved for the system.Note that PeekMessage always retrieves WM_QUIT messages, no matter which values you specify for wMsgFilterMin and wMsgFilterMax.During this call, the system dispatches (DispatchMessage) pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the SendMessage, SendMessageCallback, SendMessageTimeout, or SendNotifyMessage function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order:The PeekMessage function normally does not remove WM_PAINT messages from the queue. WM_PAINT messages remain in the queue until they are processed. However, if a WM_PAINT message has a NULL update region, PeekMessage does remove it from the queue.If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When an application is being debugged, the system does not generate a ghost window.For an example, see Examining a Message Queue.ConceptualGetMessageIsChildMSGMessages and Message QueuesOther ResourcesReferenceWaitForInputIdleWaitMessage</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool PeekMessageA(out MSG lpMsg, nint hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);

        /// <summary>
        ///Dispatches incoming nonqueued messages, checks the thread message queue for a posted message, and retrieves the message (if any exist).
        /// </summary>
        /// <param name="lpMsg"></param>
        /// <param name="hWnd"></param>
        /// <param name="wMsgFilterMin">Type: UINTThe value of the first message in the range of messages to be examined. Use WM_KEYFIRST (0x0100) to specify the first keyboard message or WM_MOUSEFIRST (0x0200) to specify the first mouse message.If wMsgFilterMin and wMsgFilterMax are both zero, PeekMessage returns all available messages (that is, no range filtering is performed).</param>
        /// <param name="wMsgFilterMax">Type: UINTThe value of the last message in the range of messages to be examined. Use WM_KEYLAST to specify the last keyboard message or WM_MOUSELAST to specify the last mouse message.If wMsgFilterMin and wMsgFilterMax are both zero, PeekMessage returns all available messages (that is, no range filtering is performed).</param>
        /// <param name="wRemoveMsg">Type: UINTSpecifies how messages are to be handled. This parameter can be one or more of the following values.By default, all message types are processed. To specify that only certain message should be processed, specify one or more of the following values.Type: BOOLIf a message is available, the return value is nonzero.If no messages are available, the return value is zero.PeekMessage retrieves messages associated with the window identified by the hWnd parameter or any of its children as specified by the IsChild function, and within the range of message values given by the wMsgFilterMin and wMsgFilterMax parameters. Note that an application can only use the low word in the wMsgFilterMin and wMsgFilterMax parameters; the high word is reserved for the system.Note that PeekMessage always retrieves WM_QUIT messages, no matter which values you specify for wMsgFilterMin and wMsgFilterMax.During this call, the system dispatches (DispatchMessage) pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the SendMessage, SendMessageCallback, SendMessageTimeout, or SendNotifyMessage function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order:The PeekMessage function normally does not remove WM_PAINT messages from the queue. WM_PAINT messages remain in the queue until they are processed. However, if a WM_PAINT message has a NULL update region, PeekMessage does remove it from the queue.If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When an application is being debugged, the system does not generate a ghost window.For an example, see Examining a Message Queue.ConceptualGetMessageIsChildMSGMessages and Message QueuesOther ResourcesReferenceWaitForInputIdleWaitMessage</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool PeekMessageW(out MSG lpMsg, nint hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);

        /// <summary>
        ///Converts the physical coordinates of a point in a window to logical coordinates.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose transform is used for the conversion. Top level windows are fully supported. In the case of child windows, only the area of overlap between the parent and the child window is converted.</param>
        /// <param name="lpPoint">Type: LPPOINTA pointer to a POINT structure that specifies the physical/screen coordinates to be converted. The new logical coordinates are copied into this structure if the function succeeds.NoneWindows Vista introduces the concept of physical coordinates. Desktop Window Manager (DWM) scales non-dots per inch (dpi) aware windows when the display is high dpi. The window seen on the screen corresponds to the physical coordinates. The application continues to work in logical space. Therefore, the application's view of the window is different from that which appears on the screen. For scaled windows, logical and physical coordinates are different.The function uses the window identified by the hWnd parameter and the physical coordinates given in the POINT structure to compute the logical coordinates. The logical coordinates are the unscaled coordinates that appear to the application in a programmatic way. In other words, the logical coordinates are the coordinates the application recognizes, which can be different from the physical coordinates. The API then replaces the physical coordinates with the logical coordinates. The new coordinates are in the world coordinates whose origin is (0, 0) on the desktop. The coordinates passed to the API have to be on the hWnd.The source coordinates are in device units.On all platforms, PhysicalToLogicalPoint will fail on a window that has either 0 width or height; an application must first establish a non-0 width and height by calling, for example, MoveWindow. On some versions of Windows (including Windows 7), PhysicalToLogicalPoint will still fail if MoveWindow has been called after a call to ShowWindow with SH_HIDE has hidden the window.In Windows 8, system–DPI aware applications translate between physical and logical space using PhysicalToLogicalPoint and LogicalToPhysicalPoint. In Windows 8.1, the additional virtualization of the system and inter-process communications means that for the majority of applications, you do not need these APIs. As a result, in Windows 8.1, PhysicalToLogicalPoint and LogicalToPhysicalPoint no longer transform points. The system returns all points to an application in its own coordinate space. This behavior preserves functionality for the majority of applications, but there are some exceptions in which you must make changes to ensure that the application works as expected. In those cases, use PhysicalToLogicalPointForPerMonitorDPI and LogicalToPhysicalPointForPerMonitorDPI.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool PhysicalToLogicalPoint(nint hWnd, out POINT lpPoint);

        /// <summary>
        ///Converts a point in a window from physical coordinates into logical coordinates, regardless of the dots per inch (dpi) awareness of the caller. For more information about DPI awareness levels, see PROCESS_DPI_AWARENESS.
        /// </summary>
        /// <param name="hWnd">A handle to the window whose transform is used for the conversion.</param>
        /// <param name="lpPoint">A pointer to a POINT structure that specifies the physical/screen coordinates to be converted. The new logical coordinates are copied into this structure if the function succeeds.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool PhysicalToLogicalPointForPerMonitorDPI(nint hWnd, out POINT lpPoint);

        /// <summary>
        ///Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="Msg">Type: UINTThe message to be posted.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).Messages in a message queue are retrieved by calls to the GetMessage or PeekMessage function.Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.If you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.Do not post the WM_QUIT message using PostMessage; use the PostQuitMessage function.An accessibility application can use PostMessage to post WM_APPCOMMAND messages to the shell to launch applications. This functionality is not guaranteed to work for other types of applications.A message queue can contain at most 10,000 messages. This limit should be sufficiently large. If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.If the function fails, call GetLastError to get extended error information. GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the limit is hit.The minimum acceptable value is 4000.The following example shows how to post a private window message using the PostMessage function. Assume you defined a private window message called WM_COMPLETE:You can post a message to the message queue associated with the thread that created the specified window as shown below:For more examples, see Initiating a Data Link.ConceptualGetMessageMessages and Message QueuesPeekMessagePostQuitMessagePostThreadMessageReferenceRegisterWindowMessageSendMessageCallbackSendNotifyMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool PostMessageA(nint hWnd, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="Msg">Type: UINTThe message to be posted.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).Messages in a message queue are retrieved by calls to the GetMessage or PeekMessage function.Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.If you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.Do not post the WM_QUIT message using PostMessage; use the PostQuitMessage function.An accessibility application can use PostMessage to post WM_APPCOMMAND messages to the shell to launch applications. This functionality is not guaranteed to work for other types of applications.There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large. If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.If the function fails, call GetLastError to get extended error information. GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the limit is hit.The minimum acceptable value is 4000.The following example shows how to post a private window message using the PostMessage function. Assume you defined a private window message called WM_COMPLETE:You can post a message to the message queue associated with the thread that created the specified window as shown below:For more examples, see Initiating a Data Link.ConceptualGetMessageMessages and Message QueuesPeekMessagePostQuitMessagePostThreadMessageReferenceRegisterWindowMessageSendMessageCallbackSendNotifyMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool PostMessageW(nint hWnd, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Indicates to the system that a thread has made a request to terminate (quit). It is typically used in response to a WM_DESTROY message.
        /// </summary>
        /// <param name="nExitCode">Type: intThe application exit code. This value is used as the wParam parameter of the WM_QUIT message.NoneThe PostQuitMessage function posts a WM_QUIT message to the thread's message queue and returns immediately; the function simply indicates to the system that the thread is requesting to quit at some time in the future.When the thread retrieves the WM_QUIT message from its message queue, it should exit its message loop and return control to the system. The exit value returned to the system must be the wParam parameter of the WM_QUIT message.For an example, see Posting a Message.ConceptualGetMessageMessages and Message QueuesPeekMessagePostMessageReferenceWM_DESTROYWM_QUIT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void PostQuitMessage(int nExitCode);

        /// <summary>
        ///Posts a message to the message queue of the specified thread. It returns without waiting for the thread to process the message.
        /// </summary>
        /// <param name="idThread">Type: DWORDThe identifier of the thread to which the message is to be posted.The function fails if the specified thread does not have a message queue. The system creates a thread's message queue when the thread makes its first call to one of the User or GDI functions. For more information, see the Remarks section.Message posting is subject to UIPI. The thread of a process can post messages only to posted-message queues of threads in processes of lesser or equal integrity level.This thread must have the SE_TCB_NAME privilege to post a message to a thread that belongs to a process with the same locally unique identifier (LUID) but is in a different desktop. Otherwise, the function fails and returns ERROR_INVALID_THREAD_ID.This thread must either belong to the same desktop as the calling thread or to a process with the same LUID. Otherwise, the function fails and returns ERROR_INVALID_THREAD_ID.</param>
        /// <param name="Msg">Type: UINTThe type of message to be posted.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError. GetLastError returns ERROR_INVALID_THREAD_ID if idThread is not a valid thread identifier, or if the thread specified by idThread does not have a message queue. GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the message limit is hit.When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).The thread to which the message is posted must have created a message queue, or else the call to PostThreadMessage fails. Use the following method to handle this situation.Messages posted by PostThreadMessage are not associated with a window. As a general rule, messages that are not associated with a window cannot be dispatched by the DispatchMessage function. Therefore, if the recipient thread is in a modal loop (as used by MessageBox or DialogBox), the messages will be lost. To intercept thread messages while in a modal loop, use a thread-specific hook.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large. If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.The minimum acceptable value is 4000.ConceptualGetCurrentThreadIdGetMessageGetWindowThreadProcessIdMSGMessages and Message QueuesOther ResourcesPeekMessagePostMessageReferenceSleepWaitForSingleObject</param>
        /// <remarks>
        /// To get extended error information, call GetLastError. GetLastError returns ERROR_INVALID_THREAD_ID if idThread is not a valid thread identifier, or if the thread specified by idThread does not have a message queue. GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the message limit is hit.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool PostThreadMessageA(uint idThread, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Posts a message to the message queue of the specified thread. It returns without waiting for the thread to process the message.
        /// </summary>
        /// <param name="idThread">Type: DWORDThe identifier of the thread to which the message is to be posted.The function fails if the specified thread does not have a message queue. The system creates a thread's message queue when the thread makes its first call to one of the User or GDI functions. For more information, see the Remarks section.Message posting is subject to UIPI. The thread of a process can post messages only to posted-message queues of threads in processes of lesser or equal integrity level.This thread must have the SE_TCB_NAME privilege to post a message to a thread that belongs to a process with the same locally unique identifier (LUID) but is in a different desktop. Otherwise, the function fails and returns ERROR_INVALID_THREAD_ID.This thread must either belong to the same desktop as the calling thread or to a process with the same LUID. Otherwise, the function fails and returns ERROR_INVALID_THREAD_ID.</param>
        /// <param name="Msg">Type: UINTThe type of message to be posted.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError. GetLastError returns ERROR_INVALID_THREAD_ID if idThread is not a valid thread identifier, or if the thread specified by idThread does not have a message queue. GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the message limit is hit.When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).The thread to which the message is posted must have created a message queue, or else the call to PostThreadMessage fails. Use the following method to handle this situation.Messages posted by PostThreadMessage are not associated with a window. As a general rule, messages that are not associated with a window cannot be dispatched by the DispatchMessage function. Therefore, if the recipient thread is in a modal loop (as used by MessageBox or DialogBox), the messages will be lost. To intercept thread messages while in a modal loop, use a thread-specific hook.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large. If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.The minimum acceptable value is 4000.ConceptualGetCurrentThreadIdGetMessageGetWindowThreadProcessIdMSGMessages and Message QueuesOther ResourcesPeekMessagePostMessageReferenceSleepWaitForSingleObject</param>
        /// <remarks>
        /// To get extended error information, call GetLastError. GetLastError returns ERROR_INVALID_THREAD_ID if idThread is not a valid thread identifier, or if the thread specified by idThread does not have a message queue. GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the message limit is hit.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool PostThreadMessageW(uint idThread, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///The PrintWindow function copies a visual window into the specified device context (DC), typically a printer DC.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool PrintWindow(nint hwnd, nint hdcBlt, uint nFlags);

        /// <summary>
        ///[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]
        /// </summary>
        /// <param name="szFileName">Type: LPCTSTRThe path and name of the file from which the icon(s) are to be extracted.</param>
        /// <param name="nIconIndex">Type: intThe zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file.</param>
        /// <param name="cxIcon">Type: intThe horizontal icon size wanted. See Remarks.</param>
        /// <param name="cyIcon">Type: intThe vertical icon size wanted. See Remarks.</param>
        /// <param name="phicon"></param>
        /// <param name="piconid"></param>
        /// <param name="nIcons">Type: UINTThe number of icons to extract from the file. This parameter is only valid when extracting from .exe and .dll files.</param>
        /// <param name="flags">Type: UINTSpecifies flags that control this function. These flags are the LR_* flags used by the LoadImage function.Type: UINTIf the phicon parameter is NULL and this function succeeds, then the return value is the number of icons in the file. If the function fails then the return value is 0.If the phicon parameter is not NULL and the function succeeds, then the return value is the number of icons extracted. Otherwise, the return value is 0xFFFFFFFF if the file is not found.This function extracts from executable (.exe), DLL (.dll), icon (.ico), cursor (.cur), animated cursor (.ani), and bitmap (.bmp) files. Extractions from Windows 3.x 16-bit executables (.exe or .dll) are also supported.The cxIcon and cyIcon parameters specify the size of the icons to extract. Two sizes can be extracted by putting the first size in the LOWORD of the parameter and the second size in the HIWORD. For example, MAKELONG(24, 48) for both the cxIcon and cyIcon parameters would extract both 24 and 48 size icons.You must destroy all icons extracted by PrivateExtractIcons by calling the DestroyIcon function.This function was not included in the SDK headers and libraries until Windows XP Service Pack 1 (SP1) and Windows Server 2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.ConceptualDestroyIconExtractIconExtractIconExIconsReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint PrivateExtractIconsA(string szFileName, int nIconIndex, int cxIcon, int cyIcon, out nint phicon, out uint piconid, uint nIcons, uint flags);

        /// <summary>
        ///[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]
        /// </summary>
        /// <param name="szFileName">Type: LPCTSTRThe path and name of the file from which the icon(s) are to be extracted.</param>
        /// <param name="nIconIndex">Type: intThe zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file.</param>
        /// <param name="cxIcon">Type: intThe horizontal icon size wanted. See Remarks.</param>
        /// <param name="cyIcon">Type: intThe vertical icon size wanted. See Remarks.</param>
        /// <param name="phicon"></param>
        /// <param name="piconid"></param>
        /// <param name="nIcons">Type: UINTThe number of icons to extract from the file. This parameter is only valid when extracting from .exe and .dll files.</param>
        /// <param name="flags">Type: UINTSpecifies flags that control this function. These flags are the LR_* flags used by the LoadImage function.Type: UINTIf the phicon parameter is NULL and this function succeeds, then the return value is the number of icons in the file. If the function fails then the return value is 0.If the phicon parameter is not NULL and the function succeeds, then the return value is the number of icons extracted. Otherwise, the return value is 0xFFFFFFFF if the file is not found.This function extracts from executable (.exe), DLL (.dll), icon (.ico), cursor (.cur), animated cursor (.ani), and bitmap (.bmp) files. Extractions from Windows 3.x 16-bit executables (.exe or .dll) are also supported.The cxIcon and cyIcon parameters specify the size of the icons to extract. Two sizes can be extracted by putting the first size in the LOWORD of the parameter and the second size in the HIWORD. For example, MAKELONG(24, 48) for both the cxIcon and cyIcon parameters would extract both 24 and 48 size icons.You must destroy all icons extracted by PrivateExtractIcons by calling the DestroyIcon function.This function was not included in the SDK headers and libraries until Windows XP Service Pack 1 (SP1) and Windows Server 2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.ConceptualDestroyIconExtractIconExtractIconExIconsReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint PrivateExtractIconsW(string szFileName, int nIconIndex, int cxIcon, int cyIcon, out nint phicon, out uint piconid, uint nIcons, uint flags);

        /// <summary>
        ///The PtInRect function determines whether the specified point lies within the specified rectangle. A point is within a rectangle if it lies on the left or top side or is within all four sides. A point on the right or bottom side is considered outside the rectangle.
        /// </summary>
        /// <param name="lprc">A pointer to a RECT structure that contains the specified rectangle.</param>
        /// <param name="pt">A POINT structure that contains the specified point.If the specified point lies within the rectangle, the return value is nonzero.If the specified point does not lie within the rectangle, the return value is zero.The rectangle must be normalized before PtInRect is called. That is, lprc.right must be greater than lprc.left and lprc.bottom must be greater than lprc.top. If the rectangle is not normalized, a point is never considered inside of the rectangle.Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure.For an example, see Using Rectangles.EqualRectIsRectEmptyPOINTRECTRectangle FunctionsRectangles Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool PtInRect(RECT lprc, POINT pt);

        /// <summary>
        ///The QueryDisplayConfig function retrieves information about all possible display paths for all display devices, or views, in the current setting.
        /// </summary>
        /// <param name="flags">The type of information to retrieve. The value for the Flags parameter must use one of the following values.The Flags parameter may also be bitwise OR'ed with zero or more of the following values.</param>
        /// <param name="numPathArrayElements">Pointer to a variable that contains the number of elements in pPathInfoArray. This parameter cannot be NULL. If QueryDisplayConfig returns ERROR_SUCCESS, pNumPathInfoElements is updated with the number of valid entries in pPathInfoArray.</param>
        /// <param name="pathArray"></param>
        /// <param name="numModeInfoArrayElements">Pointer to a variable that specifies the number in element of the mode information table. This parameter cannot be NULL. If QueryDisplayConfig returns ERROR_SUCCESS, pNumModeInfoArrayElements is updated with the number of valid entries in pModeInfoArray.</param>
        /// <param name="modeInfoArray"></param>
        /// <param name="currentTopologyId"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int QueryDisplayConfig(int flags, out int numPathArrayElements, out DISPLAYCONFIG_PATH_INFO pathArray, out int numModeInfoArrayElements, out DISPLAYCONFIG_PATH_INFO modeInfoArray, out DISPLAYCONFIG_TOPOLOGY_ID currentTopologyId);

        /// <summary>
        ///Retrieves a handle to the child window at the specified point. The search is restricted to immediate child windows; grandchildren and deeper descendant windows are not searched.
        /// </summary>
        /// <param name="hwndParent">Type: HWNDA handle to the window whose child is to be retrieved.</param>
        /// <param name="ptParentClientCoords">Type: POINTA POINT structure that defines the client coordinates of the point to be checked.Type: HWNDThe return value is a handle to the child window that contains the specified point.RealChildWindowFromPoint treats HTTRANSPARENT areas of a standard control differently from other areas of the control; it returns the child window behind a transparent part of a control. In contrast, ChildWindowFromPoint treats HTTRANSPARENT areas of a control the same as other areas. For example, if the point is in a transparent area of a groupbox, RealChildWindowFromPoint returns the child window behind a groupbox, whereas ChildWindowFromPoint returns the groupbox. However, both APIs return a static field, even though it, too, returns HTTRANSPARENT.ChildWindowFromPointConceptualOther ResourcesPOINTReferenceWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint RealChildWindowFromPoint(nint hwndParent, POINT ptParentClientCoords);

        /// <summary>
        ///Retrieves a string that specifies the window type.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window whose type will be retrieved.</param>
        /// <param name="ptszClassName"></param>
        /// <param name="cchClassNameMax">Type: UINTThe length, in characters, of the buffer pointed to by the pszType parameter.Type: UINTIf the function succeeds, the return value is the number of characters copied to the specified buffer.If the function fails, the return value is zero. To get extended error information, call GetLastError.Windows Overview</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint RealGetWindowClassA(nint hwnd, out string ptszClassName, uint cchClassNameMax);

        /// <summary>
        ///Retrieves a string that specifies the window type.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window whose type will be retrieved.</param>
        /// <param name="ptszClassName"></param>
        /// <param name="cchClassNameMax">Type: UINTThe length, in characters, of the buffer pointed to by the pszType parameter.Type: UINTIf the function succeeds, the return value is the number of characters copied to the specified buffer.If the function fails, the return value is zero. To get extended error information, call GetLastError.Windows Overview</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint RealGetWindowClassW(nint hwnd, out string ptszClassName, uint cchClassNameMax);

        /// <summary>
        ///The RedrawWindow function updates the specified rectangle or region in a window's client area.
        /// </summary>
        /// <param name="hWnd">A handle to the window to be redrawn. If this parameter is NULL, the desktop window is updated.</param>
        /// <param name="lprcUpdate">A pointer to a RECT structure containing the coordinates, in device units, of the update rectangle. This parameter is ignored if the hrgnUpdate parameter identifies a region.</param>
        /// <param name="hrgnUpdate">A handle to the update region. If both the hrgnUpdate and lprcUpdate parameters are NULL, the entire client area is added to the update region.</param>
        /// <param name="flags">One or more redraw flags. This parameter can be used to invalidate or validate a window, control repainting, and control which windows are affected by RedrawWindow.The following flags are used to invalidate the window.The following flags are used to validate the window.The following flags control when repainting occurs. RedrawWindow will not repaint unless one of these flags is specified.By default, the windows affected by RedrawWindow depend on whether the specified window has the WS_CLIPCHILDREN style. Child windows that are not the WS_CLIPCHILDREN style are unaffected; non-WS_CLIPCHILDREN windows are recursively validated or invalidated until a WS_CLIPCHILDREN window is encountered. The following flags control which windows are affected by the RedrawWindow function.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.When RedrawWindow is used to invalidate part of the desktop window, the desktop window does not receive a WM_PAINT message. To repaint the desktop, an application uses the RDW_ERASE flag to generate a WM_ERASEBKGND message.GetUpdateRectGetUpdateRgnInvalidateRectInvalidateRgnPainting and Drawing FunctionsPainting and Drawing OverviewRECTUpdateWindow</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RedrawWindow(nint hWnd, RECT lprcUpdate, nint hrgnUpdate, uint flags);

        /// <summary>
        ///Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function.
        /// </summary>
        /// <param name="lpWndClass">Type: const WNDCLASS*A pointer to a WNDCLASS structure. You must fill the structure with the appropriate class attributes before passing it to the function.Type: ATOMIf the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the CreateWindow, CreateWindowEx, GetClassInfo, GetClassInfoEx, FindWindow, FindWindowEx, and UnregisterClass functions and the IActiveIMMap::FilterClientWindows method.If the function fails, the return value is zero. To get extended error information, call GetLastError.If you register the window class by using RegisterClassA, the application tells the system that the windows of the created class expect messages with text or character parameters to use the ANSI character set; if you register it by using RegisterClassW, the application requests that the system pass text parameters of messages as Unicode. The IsWindowUnicode function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see Conventions for Function Prototypes.All window classes that an application registers are unregistered when it terminates.No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is unloaded.For an example, see Associating a Window Procedure with a Window Class.ConceptualCreateWindowCreateWindowExFindWindowFindWindowExGetClassInfoGetClassInfoExGetClassNameReferenceRegisterClassExUnregisterClassWNDCLASSWindow ClassesWindowProc</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RegisterClassA(WNDCLASSA lpWndClass);

        /// <summary>
        ///Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function.
        /// </summary>
        /// <param name="unnamedParam1">Type: const WNDCLASSEX*A pointer to a WNDCLASSEX structure. You must fill the structure with the appropriate class attributes before passing it to the function.Type: ATOMIf the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the CreateWindow, CreateWindowEx, GetClassInfo, GetClassInfoEx, FindWindow, FindWindowEx, and UnregisterClass functions and the IActiveIMMap::FilterClientWindows method.If the function fails, the return value is zero. To get extended error information, call GetLastError.If you register the window class by using RegisterClassExA, the application tells the system that the windows of the created class expect messages with text or character parameters to use the ANSI character set; if you register it by using RegisterClassExW, the application requests that the system pass text parameters of messages as Unicode. The IsWindowUnicode function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see Conventions for Function Prototypes.All window classes that an application registers are unregistered when it terminates.No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is unloaded.For an example, see Using Window Classes.ConceptualCreateWindowCreateWindowExFindWindowFindWindowExGetClassInfoGetClassInfoExGetClassNameReferenceRegisterClassUnregisterClassWNDCLASSEXWindow ClassesWindowProc</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RegisterClassExA(WNDCLASSEXA unnamedParam1);

        /// <summary>
        ///Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function.
        /// </summary>
        /// <param name="unnamedParam1">Type: const WNDCLASSEX*A pointer to a WNDCLASSEX structure. You must fill the structure with the appropriate class attributes before passing it to the function.Type: ATOMIf the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the CreateWindow, CreateWindowEx, GetClassInfo, GetClassInfoEx, FindWindow, FindWindowEx, and UnregisterClass functions and the IActiveIMMap::FilterClientWindows method.If the function fails, the return value is zero. To get extended error information, call GetLastError.If you register the window class by using RegisterClassExA, the application tells the system that the windows of the created class expect messages with text or character parameters to use the ANSI character set; if you register it by using RegisterClassExW, the application requests that the system pass text parameters of messages as Unicode. The IsWindowUnicode function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see Conventions for Function Prototypes.All window classes that an application registers are unregistered when it terminates.No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is unloaded.For an example, see Using Window Classes.ConceptualCreateWindowCreateWindowExFindWindowFindWindowExGetClassInfoGetClassInfoExGetClassNameReferenceRegisterClassUnregisterClassWNDCLASSEXWindow ClassesWindowProc</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RegisterClassExW(WNDCLASSEXW unnamedParam1);

        /// <summary>
        ///Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function.
        /// </summary>
        /// <param name="lpWndClass">Type: const WNDCLASS*A pointer to a WNDCLASS structure. You must fill the structure with the appropriate class attributes before passing it to the function.Type: ATOMIf the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the CreateWindow, CreateWindowEx, GetClassInfo, GetClassInfoEx, FindWindow, FindWindowEx, and UnregisterClass functions and the IActiveIMMap::FilterClientWindows method.If the function fails, the return value is zero. To get extended error information, call GetLastError.If you register the window class by using RegisterClassA, the application tells the system that the windows of the created class expect messages with text or character parameters to use the ANSI character set; if you register it by using RegisterClassW, the application requests that the system pass text parameters of messages as Unicode. The IsWindowUnicode function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see Conventions for Function Prototypes.All window classes that an application registers are unregistered when it terminates.No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is unloaded.For an example, see Associating a Window Procedure with a Window Class.ConceptualCreateWindowCreateWindowExFindWindowFindWindowExGetClassInfoGetClassInfoExGetClassNameReferenceRegisterClassExUnregisterClassWNDCLASSWindow ClassesWindowProc</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RegisterClassW(WNDCLASSW lpWndClass);

        /// <summary>
        ///Registers a new clipboard format. This format can then be used as a valid clipboard format.
        /// </summary>
        /// <param name="lpszFormat">Type: LPCTSTRThe name of the new format.Type: UINTIf the function succeeds, the return value identifies the registered clipboard format.If the function fails, the return value is zero. To get extended error information, call GetLastError.If a registered format with the specified name already exists, a new format is not registered and the return value identifies the existing format. This enables more than one application to copy and paste data using the same registered clipboard format. Note that the format name comparison is case-insensitive.Registered clipboard formats are identified by values in the range 0xC000 through 0xFFFF.When registered clipboard formats are placed on or retrieved from the clipboard, they must be in the form of an HGLOBAL value.For an example, see Registering a Clipboard Format.ClipboardConceptualCountClipboardFormatsEnumClipboardFormatsGetClipboardFormatNameReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint RegisterClipboardFormatA(string lpszFormat);

        /// <summary>
        ///Registers a new clipboard format. This format can then be used as a valid clipboard format.
        /// </summary>
        /// <param name="lpszFormat">Type: LPCTSTRThe name of the new format.Type: UINTIf the function succeeds, the return value identifies the registered clipboard format.If the function fails, the return value is zero. To get extended error information, call GetLastError.If a registered format with the specified name already exists, a new format is not registered and the return value identifies the existing format. This enables more than one application to copy and paste data using the same registered clipboard format. Note that the format name comparison is case-insensitive.Registered clipboard formats are identified by values in the range 0xC000 through 0xFFFF.When registered clipboard formats are placed on or retrieved from the clipboard, they must be in the form of an HGLOBAL value.For an example, see Registering a Clipboard Format.ClipboardConceptualCountClipboardFormatsEnumClipboardFormatsGetClipboardFormatNameReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint RegisterClipboardFormatW(string lpszFormat);

        /// <summary>
        ///Registers the device or type of device for which a window will receive notifications.
        /// </summary>
        /// <param name="hRecipient">A handle to the window or service that will receive device events for the devices specified in the NotificationFilter parameter. The same window handle can be used in multiple calls to RegisterDeviceNotification.Services can specify either a window handle or service status handle.</param>
        /// <param name="NotificationFilter">A pointer to a block of data that specifies the type of device for which notifications should be sent. This block always begins with the DEV_BROADCAST_HDR structure. The data following this header is dependent on the value of the dbch_devicetype member, which can be DBT_DEVTYP_DEVICEINTERFACE or DBT_DEVTYP_HANDLE. For more information, see Remarks.</param>
        /// <param name="Flags">This parameter can be one of the following values.In addition, you can specify the following value.If the function succeeds, the return value is a device notification handle.If the function fails, the return value is NULL. To get extended error information, call GetLastError.Applications send event notifications using the BroadcastSystemMessage function. Any application with a top-level window can receive basic notifications by processing the WM_DEVICECHANGE message. Applications can use the RegisterDeviceNotification function to register to receive device notifications.Services can use the RegisterDeviceNotification function to register to receive device notifications. If a service specifies a window handle in the hRecipient parameter, the notifications are sent to the window procedure. If hRecipient is a service status handle, SERVICE_CONTROL_DEVICEEVENT notifications are sent to the service control handler. For more information about the service control handler, see HandlerEx.Be sure to handle Plug and Play device events as quickly as possible. Otherwise, the system may become unresponsive. If your event handler is to perform an operation that may block execution (such as I/O), it is best to start another thread to perform the operation asynchronously.Device notification handles returned by RegisterDeviceNotification must be closed by calling the UnregisterDeviceNotification function when they are no longer needed.The DBT_DEVICEARRIVAL and DBT_DEVICEREMOVECOMPLETE events are automatically broadcast to all top-level windows for port devices. Therefore, it is not necessary to call RegisterDeviceNotification for ports, and the function fails if the dbch_devicetype member is DBT_DEVTYP_PORT. Volume notifications are also broadcast to top-level windows, so the function fails if dbch_devicetype is DBT_DEVTYP_VOLUME. OEM-defined devices are not used directly by the system, so the function fails if dbch_devicetype is DBT_DEVTYP_OEM.For an example, see Registering for device notification.BroadcastSystemMessageDEV_BROADCAST_HDRDevice Management FunctionsDevice NotificationsHandlerExRegisterDeviceNotificationUnregisterDeviceNotificationWM_DEVICECHANGE</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint RegisterDeviceNotificationA(nint hRecipient, nint NotificationFilter, uint Flags);

        /// <summary>
        ///Registers the device or type of device for which a window will receive notifications.
        /// </summary>
        /// <param name="hRecipient">A handle to the window or service that will receive device events for the devices specified in the NotificationFilter parameter. The same window handle can be used in multiple calls to RegisterDeviceNotification.Services can specify either a window handle or service status handle.</param>
        /// <param name="NotificationFilter">A pointer to a block of data that specifies the type of device for which notifications should be sent. This block always begins with the DEV_BROADCAST_HDR structure. The data following this header is dependent on the value of the dbch_devicetype member, which can be DBT_DEVTYP_DEVICEINTERFACE or DBT_DEVTYP_HANDLE. For more information, see Remarks.</param>
        /// <param name="Flags">This parameter can be one of the following values.In addition, you can specify the following value.If the function succeeds, the return value is a device notification handle.If the function fails, the return value is NULL. To get extended error information, call GetLastError.Applications send event notifications using the BroadcastSystemMessage function. Any application with a top-level window can receive basic notifications by processing the WM_DEVICECHANGE message. Applications can use the RegisterDeviceNotification function to register to receive device notifications.Services can use the RegisterDeviceNotification function to register to receive device notifications. If a service specifies a window handle in the hRecipient parameter, the notifications are sent to the window procedure. If hRecipient is a service status handle, SERVICE_CONTROL_DEVICEEVENT notifications are sent to the service control handler. For more information about the service control handler, see HandlerEx.Be sure to handle Plug and Play device events as quickly as possible. Otherwise, the system may become unresponsive. If your event handler is to perform an operation that may block execution (such as I/O), it is best to start another thread to perform the operation asynchronously.Device notification handles returned by RegisterDeviceNotification must be closed by calling the UnregisterDeviceNotification function when they are no longer needed.The DBT_DEVICEARRIVAL and DBT_DEVICEREMOVECOMPLETE events are automatically broadcast to all top-level windows for port devices. Therefore, it is not necessary to call RegisterDeviceNotification for ports, and the function fails if the dbch_devicetype member is DBT_DEVTYP_PORT. Volume notifications are also broadcast to top-level windows, so the function fails if dbch_devicetype is DBT_DEVTYP_VOLUME. OEM-defined devices are not used directly by the system, so the function fails if dbch_devicetype is DBT_DEVTYP_OEM.For an example, see Registering for device notification.BroadcastSystemMessageDEV_BROADCAST_HDRDevice Management FunctionsDevice NotificationsHandlerExRegisterDeviceNotificationUnregisterDeviceNotificationWM_DEVICECHANGE</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint RegisterDeviceNotificationW(nint hRecipient, nint NotificationFilter, uint Flags);

        /// <summary>
        ///Defines a system-wide hot key.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="id">Type: intThe identifier of the hot key. If the hWnd parameter is NULL, then the hot key is associated with the current thread rather than with a particular window. If a hot key already exists with the same hWnd and id parameters, see Remarks for the action taken.</param>
        /// <param name="fsModifiers">Type: UINTThe keys that must be pressed in combination with the key specified by the vk parameter in order to generate the WM_HOTKEY message. The fsModifiers parameter can be a combination of the following values.</param>
        /// <param name="vk">Type: UINTThe virtual-key code of the hot key. See Virtual Key Codes.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.When a key is pressed, the system looks for a match against all hot keys. Upon finding a match, the system posts the WM_HOTKEY message to the message queue of the window with which the hot key is associated. If the hot key is not associated with a window, then the WM_HOTKEY message is posted to the thread associated with the hot key.This function cannot associate a hot key with a window created by another thread.RegisterHotKey fails if the keystrokes specified for the hot key have already been registered by another hot key.If a hot key already exists with the same hWnd and id parameters, it is maintained along with the new hot key. The application must explicitly call UnregisterHotKey to unregister the old hot key.Windows Server 2003:  If a hot key already exists with the same hWnd and id parameters, it is replaced by the new hot key.The F12 key is reserved for use by the debugger at all times, so it should not be registered as a hot key. Even when you are not debugging an application, F12 is reserved in case a kernel-mode debugger or a just-in-time debugger is resident.An application must specify an id value in the range 0x0000 through 0xBFFF. A shared DLL must specify a value in the range 0xC000 through 0xFFFF (the range returned by the GlobalAddAtom function). To avoid conflicts with hot-key identifiers defined by other shared DLLs, a DLL should use the GlobalAddAtom function to obtain the hot-key identifier.The following example shows how to use the RegisterHotKey function with the MOD_NOREPEAT flag. In this example, the hotkey 'ALT+b' is registered for the main thread. When the hotkey is pressed, the thread will receive a WM_HOTKEY message, which will get picked up in the GetMessage call. Because this example uses MOD_ALT with the MOD_NOREPEAT value for fsModifiers, the thread will only receive another WM_HOTKEY message when the 'b' key is released and then pressed again while the 'ALT' key is being pressed down.ConceptualGlobalAddAtomKeyboard InputReferenceRegister hotkey for the current app (CSRegisterHotkey)Register hotkey for the current app (CppRegisterHotkey)Register hotkey for the current app (VBRegisterHotkey)SamplesUnregisterHotKeyWM_HOTKEY</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RegisterHotKey(nint hWnd, int id, uint fsModifiers, uint vk);

        /// <summary>
        ///Registers a window to process the WM_POINTERDEVICECHANGE, WM_POINTERDEVICEINRANGE, and WM_POINTERDEVICEOUTOFRANGE pointer device notifications.
        /// </summary>
        /// <param name="window">The window that receives WM_POINTERDEVICECHANGE, WM_POINTERDEVICEINRANGE, and WM_POINTERDEVICEOUTOFRANGE notifications.</param>
        /// <param name="notifyRange">If set to TRUE, process the WM_POINTERDEVICEINRANGE and WM_POINTERDEVICEOUTOFRANGE messages. If set to FALSE, these messages aren't processed.If this function succeeds, it returns TRUE.Otherwise, it returns FALSE. To retrieve extended error information, call the GetLastError function.Functions</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RegisterPointerDeviceNotifications(nint window, bool notifyRange);

        /// <summary>
        ///Allows the caller to register a target window to which all pointer input of the specified type is redirected.
        /// </summary>
        /// <param name="hwnd">The window to register as a global redirection target.Redirection can cause the foreground window to lose activation (focus). To avoid this, ensure the window is a message-only window or has the WS_EX_NOACTIVATE style set.</param>
        /// <param name="pointerType">Type of pointer input to be redirected to the specified window. This is any valid and supported value from the POINTER_INPUT_TYPE enumeration. Note that the generic PT_POINTER type and the PT_MOUSE type are not valid in this parameter.If the function succeeds, the return value is non-zero.If the function fails, the return value is zero. To get extended error information, call GetLastError.An application with the UI Access privilege can use this function to register its own window to receive all input of the specified pointer input type. Each desktop allows only one such global redirection target window for each pointer input type at any given time. The first window to successfully register remains in effect until the window is unregistered or destroyed, at which point the role is available to the next qualified caller.While the registration is in effect, all input of the specified pointer type, whether from an input device or injected by an application, is redirected to the registered window. However, when the process that owns the registered window injects input of the specified pointer type, such injected is not redirected but is instead processed normally.An application that wishes to register the same window as a global redirection target for multiple pointer input types must call the RegisterPointerInputTarget function multiple times, once for each pointer input type of interest.If the calling thread does not have the UI Access privilege, this function fails with the last error set to ERROR_ACCESS_DENIED.If the specified pointer input type is not valid, this function fails with the last error set to ERROR_INVALID_PARAMETER.If the calling thread does not own the specified window, this function fails with the last error set to ERROR_ACCESS_DENIED.If the specified window’s desktop already has a registered global redirection target for the specified pointer input type, this function fails with the last error set to ERROR_ACCESS_DENIED.</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RegisterPointerInputTarget(nint hwnd, POINTER_INPUT_TYPE pointerType);

        /// <summary>
        ///[RegisterPointerInputTargetEx is not supported and may be altered or unavailable in the future. Instead, use RegisterPointerInputTarget.]
        /// </summary>
        /// <param name="hwnd">Not supported.</param>
        /// <param name="pointerType">Not supported.</param>
        /// <param name="fObserve">Not supported.Not supported.RegisterPointerInputTarget</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RegisterPointerInputTargetEx(nint hwnd, POINTER_INPUT_TYPE pointerType, bool fObserve);

        /// <summary>
        ///Registers the application to receive power setting notifications for the specific power setting event.
        /// </summary>
        /// <param name="hRecipient">Handle indicating where the power setting notifications are to be sent. For interactive applications, the Flags parameter should be zero, and the hRecipient parameter should be a window handle. For services, the Flags parameter should be one, and the hRecipient parameter should be a SERVICE_STATUS_HANDLE as returned from RegisterServiceCtrlHandlerEx.</param>
        /// <param name="PowerSettingGuid">The GUID of the power setting for which notifications are to be sent. For more information see Registering for Power Events.</param>
        /// <param name="Flags">Returns a notification handle for unregistering for power notifications. If the function fails, the return value is NULL. To get extended error information, call GetLastError.Power Management FunctionsRegistering for Power EventsUnregisterPowerSettingNotification</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern POWER_ACTION RegisterPowerSettingNotification(nint hRecipient, ushort PowerSettingGuid, uint Flags);

        /// <summary>
        ///Registers the devices that supply the raw input data.
        /// </summary>
        /// <param name="pRawInputDevices">Type: PCRAWINPUTDEVICEAn array of RAWINPUTDEVICE structures that represent the devices that supply the raw input.</param>
        /// <param name="uiNumDevices">Type: UINTThe number of RAWINPUTDEVICE structures pointed to by pRawInputDevices.</param>
        /// <param name="cbSize">Type: UINTThe size, in bytes, of a RAWINPUTDEVICE structure.Type: BOOLTRUE if the function succeeds; otherwise, FALSE. If the function fails, call GetLastError for more information.To receive WM_INPUT messages, an application must first register the raw input devices using RegisterRawInputDevices. By default, an application does not receive raw input.To receive WM_INPUT_DEVICE_CHANGE messages, an application must specify the RIDEV_DEVNOTIFY flag for each device class that is specified by the usUsagePage and usUsage fields of the RAWINPUTDEVICE structure . By default, an application does not receive WM_INPUT_DEVICE_CHANGE notifications for raw input device arrival and removal.If a RAWINPUTDEVICE structure has the RIDEV_REMOVE flag set and the hwndTarget parameter is not set to NULL, then parameter validation will fail.Only one window per raw input device class may be registered to receive raw input within a process (the window passed in the last call to RegisterRawInputDevices). Because of this, RegisterRawInputDevices should not be used from a library, as it may interfere with any raw input processing logic already present in applications that load it.ConceptualRAWINPUTDEVICERaw InputReferenceWM_INPUT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RegisterRawInputDevices(RAWINPUTDEVICE pRawInputDevices, uint uiNumDevices, uint cbSize);

        /// <summary>
        ///[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window to register for Shell hook messages.Type: BOOLTRUE if the function succeeds; otherwise, FALSE.As with normal window messages, the second parameter of the window procedure identifies the message as a WM_SHELLHOOKMESSAGE. However, for these Shell hook messages, the message value is not a pre-defined constant like other message IDs such as WM_COMMAND. The value must be obtained dynamically using a call to RegisterWindowMessage as shown here:RegisterWindowMessage(TEXT("SHELLHOOK"));This precludes handling these messages using a traditional switch statement which requires ID values that are known at compile time. For handling Shell hook messages, the normal practice is to code an If statement in the default section of your switch statement and then handle the message if the value of the message ID is the same as the value obtained from the RegisterWindowMessage call.The following table describes the wParam and lParam parameter values passed to the window procedure for the Shell hook messages.This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server 2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.ConceptualDeregisterShellHookWindowOther ResourcesReferenceSetWindowsHookExShellProcUsing Messages and Message QueuesWinEventsWindowProcWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RegisterShellHookWindow(nint hwnd);

        /// <summary>
        ///Registers to receive notification when the system is suspended or resumed. Similar to PowerRegisterSuspendResumeNotification, but operates in user mode and can take a window handle.
        /// </summary>
        /// <param name="hRecipient">This parameter contains parameters for subscribing to a power notification or a window handle representing the subscribing process.If Flags is DEVICE_NOTIFY_CALLBACK, hRecipient is interpreted as a pointer to a DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS structure. In this case, the callback function is DeviceNotifyCallbackRoutine. When the Callback function executes, the Type parameter is set indicating the type of event that occurred. Possible values include PBT_APMSUSPEND, PBT_APMRESUMESUSPEND, and PBT_APMRESUMEAUTOMATIC - see Power Management Events for more info. The Setting parameter is not used with suspend/resume notifications.If Flags is DEVICE_NOTIFY_WINDOW_HANDLE, hRecipient is a handle to the window to deliver events to.</param>
        /// <param name="Flags">This parameter can be DEVICE_NOTIFY_WINDOW_HANDLE or DEVICE_NOTIFY_CALLBACK.A handle to the registration. Use this handle to unregister for notifications.If the function fails, the return value is NULL. To get extended error information call GetLastError.DEVICE_NOTIFY_CALLBACK_ROUTINEDEVICE_NOTIFY_SUBSCRIBE_PARAMETERSUnregisterSuspendResumeNotification</param>
        /// <remarks>
        /// To get extended error information call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern POWER_ACTION RegisterSuspendResumeNotification(nint hRecipient, uint Flags);

        /// <summary>
        ///Registers a window to process the
        /// </summary>
        /// <param name="hwnd">The window that receives the WM_TOUCHHITTESTING notification.</param>
        /// <param name="value">One of the following values:If this function succeeds, it returns TRUE.Otherwise, it returns FALSE. To retrieve extended error information, call the GetLastError function.Functions</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RegisterTouchHitTestingWindow(nint hwnd, uint value);

        /// <summary>
        ///Registers a window as being touch-capable.
        /// </summary>
        /// <param name="hwnd">The handle of the window being registered. The function fails with ERROR_ACCESS_DENIED if the calling thread does not own the specified window.</param>
        /// <param name="ulFlags">A set of bit flags that specify optional modifications. This field may contain 0 or one of the following values.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.FunctionsUnregisterTouchWindow</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RegisterTouchWindow(nint hwnd, uint ulFlags);

        /// <summary>
        ///Defines a new window message that is guaranteed to be unique throughout the system. The message value can be used when sending or posting messages.
        /// </summary>
        /// <param name="lpString">Type: LPCTSTRThe message to be registered.Type: UINTIf the message is successfully registered, the return value is a message identifier in the range 0xC000 through 0xFFFF.If the function fails, the return value is zero. To get extended error information, call GetLastError.The RegisterWindowMessage function is typically used to register messages for communicating between two cooperating applications.If two different applications register the same message string, the applications return the same message value. The message remains registered until the session ends.Only use RegisterWindowMessage when more than one application must process the same message. For sending private messages within a window class, an application can use any integer in the range WM_USER through 0x7FFF. (Messages in this range are private to a window class, not to an application. For example, predefined control classes such as BUTTON, EDIT, LISTBOX, and COMBOBOX may use values in this range.)For an example, see Finding Text.ConceptualMessages and Message QueuesPostMessageReferenceSendMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint RegisterWindowMessageA(string lpString);

        /// <summary>
        ///Defines a new window message that is guaranteed to be unique throughout the system. The message value can be used when sending or posting messages.
        /// </summary>
        /// <param name="lpString">Type: LPCTSTRThe message to be registered.Type: UINTIf the message is successfully registered, the return value is a message identifier in the range 0xC000 through 0xFFFF.If the function fails, the return value is zero. To get extended error information, call GetLastError.The RegisterWindowMessage function is typically used to register messages for communicating between two cooperating applications.If two different applications register the same message string, the applications return the same message value. The message remains registered until the session ends.Only use RegisterWindowMessage when more than one application must process the same message. For sending private messages within a window class, an application can use any integer in the range WM_USER through 0x7FFF. (Messages in this range are private to a window class, not to an application. For example, predefined control classes such as BUTTON, EDIT, LISTBOX, and COMBOBOX may use values in this range.)For an example, see Finding Text.ConceptualMessages and Message QueuesPostMessageReferenceSendMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint RegisterWindowMessageW(string lpString);

        /// <summary>
        ///Releases the mouse capture from a window in the current thread and restores normal mouse input processing. A window that has captured the mouse receives all mouse input, regardless of the position of the cursor, except when a mouse button is clicked while the cursor hot spot is in the window of another thread.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ReleaseCapture();

        /// <summary>
        ///The ReleaseDC function releases a device context (DC), freeing it for use by other applications. The effect of the ReleaseDC function depends on the type of DC. It frees only common and window DCs. It has no effect on class or private DCs.
        /// </summary>
        /// <param name="hWnd">A handle to the window whose DC is to be released.</param>
        /// <param name="hDC">A handle to the DC to be released.The return value indicates whether the DC was released. If the DC was released, the return value is 1.If the DC was not released, the return value is zero.The application must call the ReleaseDC function for each call to the GetWindowDC function and for each call to the GetDC function that retrieves a common DC.An application cannot use the ReleaseDC function to release a DC that was created by calling the CreateDC function; instead, it must use the DeleteDC function. ReleaseDC must be called from the same thread that called GetDC.For an example, see Scaling an Image.CreateDCDeleteDCDevice Context FunctionsDevice Contexts OverviewGetDCGetWindowDC</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ReleaseDC(nint hWnd, nint hDC);

        /// <summary>
        ///Removes the given window from the system-maintained clipboard format listener list.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window to remove from the clipboard format listener list.Type: BOOL</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RemoveClipboardFormatListener(nint hwnd);

        /// <summary>
        ///Deletes a menu item or detaches a submenu from the specified menu. If the menu item opens a drop-down menu or submenu, RemoveMenu does not destroy the menu or its handle, allowing the menu to be reused. Before this function is called, the GetSubMenu function should retrieve a handle to the drop-down menu or submenu.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu to be changed.</param>
        /// <param name="uPosition">Type: UINTThe menu item to be deleted, as determined by the uFlags parameter.</param>
        /// <param name="uFlags">Type: UINTIndicates how the uPosition parameter is interpreted. This parameter must be one of the following values.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.ConceptualCreatePopupMenuDeleteMenuDrawMenuBarGetSubMenuMenusReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool RemoveMenu(nint hMenu, uint uPosition, uint uFlags);

        /// <summary>
        ///Removes an entry from the property list of the specified window. The specified character string identifies the entry to be removed.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose property list is to be changed.</param>
        /// <param name="lpString">Type: LPCTSTRA null-terminated character string or an atom that identifies a string. If this parameter is an atom, it must have been created using the GlobalAddAtom function. The atom, a 16-bit value, must be placed in the low-order word of lpString; the high-order word must be zero.Type: HANDLEThe return value identifies the specified data. If the data cannot be found in the specified property list, the return value is NULL.The return value is the hData value that was passed to SetProp; it is an application-defined value. Note, this function only destroys the association between the data and the window. If appropriate, the application must free the data handles associated with entries removed from a property list. The application can remove only those properties it has added. It must not remove properties added by other applications or by the system itself.The RemoveProp function returns the data handle associated with the string so that the application can free the data associated with the handle.Starting with Windows Vista, RemoveProp is subject to the restrictions of User Interface Privilege Isolation (UIPI). A process can only call this function on a window belonging to a process of lesser or equal integrity level. When UIPI blocks property changes, GetLastError will return 5.For an example, see Deleting a Window Property.AddAtomConceptualGetPropReferenceSetPropWindow Properties</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint RemovePropA(nint hWnd, string lpString);

        /// <summary>
        ///Removes an entry from the property list of the specified window. The specified character string identifies the entry to be removed.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose property list is to be changed.</param>
        /// <param name="lpString">Type: LPCTSTRA null-terminated character string or an atom that identifies a string. If this parameter is an atom, it must have been created using the GlobalAddAtom function. The atom, a 16-bit value, must be placed in the low-order word of lpString; the high-order word must be zero.Type: HANDLEThe return value identifies the specified data. If the data cannot be found in the specified property list, the return value is NULL.The return value is the hData value that was passed to SetProp; it is an application-defined value. Note, this function only destroys the association between the data and the window. If appropriate, the application must free the data handles associated with entries removed from a property list. The application can remove only those properties it has added. It must not remove properties added by other applications or by the system itself.The RemoveProp function returns the data handle associated with the string so that the application can free the data associated with the handle.Starting with Windows Vista, RemoveProp is subject to the restrictions of User Interface Privilege Isolation (UIPI). A process can only call this function on a window belonging to a process of lesser or equal integrity level. When UIPI blocks property changes, GetLastError will return 5.For an example, see Deleting a Window Property.AddAtomConceptualGetPropReferenceSetPropWindow Properties</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint RemovePropW(nint hWnd, string lpString);

        /// <summary>
        ///Replies to a message sent from another thread by the SendMessage function.
        /// </summary>
        /// <param name="lResult">Type: LRESULTThe result of the message processing. The possible values are based on the message sent.Type: BOOLIf the calling thread was processing a message sent from another thread or process, the return value is nonzero.If the calling thread was not processing a message sent from another thread or process, the return value is zero.By calling this function, the window procedure that receives the message allows the thread that called SendMessage to continue to run as though the thread receiving the message had returned control. The thread that calls the ReplyMessage function also continues to run.If the message was not sent through SendMessage or if the message was sent by the same thread, ReplyMessage has no effect.For an example, see Sending a Message.ConceptualInSendMessageMessages and Message QueuesReferenceSendMessage</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ReplyMessage(nint lResult);

        /// <summary>
        ///The ScreenToClient function converts the screen coordinates of a specified point on the screen to client-area coordinates.
        /// </summary>
        /// <param name="hWnd">A handle to the window whose client area will be used for the conversion.lpPointA pointer to a POINT structure that specifies the screen coordinates to be converted.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.The function uses the window identified by the hWnd parameter and the screen coordinates given in the POINT structure to compute client coordinates. It then replaces the screen coordinates with the client coordinates. The new coordinates are relative to the upper-left corner of the specified window's client area.The ScreenToClient function assumes the specified point is in screen coordinates.All coordinates are in device units.Do not use ScreenToClient when in a mirroring situation, that is, when changing from left-to-right layout to right-to-left layout. Instead, use MapWindowPoints. For more information, see "Window Layout and Mirroring" in Window Features.ClientToScreenCoordinate Space and Transformation FunctionsCoordinate Spaces and Transformations OverviewMapWindowPointsPOINT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ScreenToClient(nint hWnd);

        /// <summary>
        ///The ScrollDC function scrolls a rectangle of bits horizontally and vertically.
        /// </summary>
        /// <param name="hDC">Type: HDCHandle to the device context that contains the bits to be scrolled.</param>
        /// <param name="dx">Type: intSpecifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.</param>
        /// <param name="dy">Type: intSpecifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up.</param>
        /// <param name="lprcScroll">Type: const RECT*Pointer to a RECT structure containing the coordinates of the bits to be scrolled. The only bits affected by the scroll operation are bits in the intersection of this rectangle and the rectangle specified by lprcClip. If lprcScroll is NULL, the entire client area is used.</param>
        /// <param name="lprcClip">Type: const RECT*Pointer to a RECT structure containing the coordinates of the clipping rectangle. The only bits that will be painted are the bits that remain inside this rectangle after the scroll operation has been completed. If lprcClip is NULL, the entire client area is used.</param>
        /// <param name="hrgnUpdate">Type: HRGNHandle to the region uncovered by the scrolling process. ScrollDC defines this region; it is not necessarily a rectangle.</param>
        /// <param name="lprcUpdate"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ScrollDC(nint hDC, int dx, int dy, RECT lprcScroll, RECT lprcClip, nint hrgnUpdate, out RECT lprcUpdate);

        /// <summary>
        ///The ScrollWindow function scrolls the contents of the specified window's client area.
        /// </summary>
        /// <param name="hWnd">Type: HWNDHandle to the window where the client area is to be scrolled.</param>
        /// <param name="XAmount">Type: intSpecifies the amount, in device units, of horizontal scrolling. If the window being scrolled has the CS_OWNDC or CS_CLASSDC style, then this parameter uses logical units rather than device units. This parameter must be a negative value to scroll the content of the window to the left.</param>
        /// <param name="YAmount">Type: intSpecifies the amount, in device units, of vertical scrolling. If the window being scrolled has the CS_OWNDC or CS_CLASSDC style, then this parameter uses logical units rather than device units. This parameter must be a negative value to scroll the content of the window up.</param>
        /// <param name="lpRect">Type: const RECT*Pointer to the RECT structure specifying the portion of the client area to be scrolled. If this parameter is NULL, the entire client area is scrolled.</param>
        /// <param name="lpClipRect">Type: const RECT*Pointer to the RECT structure containing the coordinates of the clipping rectangle. Only device bits within the clipping rectangle are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside of the rectangle to the outside are not painted.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the caret is in the window being scrolled, ScrollWindow automatically hides the caret to prevent it from being erased and then restores the caret after the scrolling is finished. The caret position is adjusted accordingly.The area uncovered by ScrollWindow is not repainted, but it is combined into the window's update region. The application eventually receives a WM_PAINT message notifying it that the region must be repainted. To repaint the uncovered area at the same time the scrolling is in action, call the UpdateWindow function immediately after calling ScrollWindow.If the lpRect parameter is NULL, the positions of any child windows in the window are offset by the amount specified by the XAmount and YAmount parameters; invalid (unpainted) areas in the window are also offset. ScrollWindow is faster when lpRect is NULL.If lpRect is not NULL, the positions of child windows are not changed and invalid areas in the window are not offset. To prevent updating problems when lpRect is not NULL, call UpdateWindow to repaint the window before calling ScrollWindow.For an example, see Scrolling Text with the WM_PAINT Message.Other ResourcesRECTReferenceScrollDCScrollWindowExUpdateWindow</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ScrollWindow(nint hWnd, int XAmount, int YAmount, RECT lpRect, RECT lpClipRect);

        /// <summary>
        ///The ScrollWindowEx function scrolls the contents of the specified window's client area.
        /// </summary>
        /// <param name="hWnd">Type: HWNDHandle to the window where the client area is to be scrolled.</param>
        /// <param name="dx">Type: intSpecifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.</param>
        /// <param name="dy">Type: intSpecifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up.</param>
        /// <param name="prcScroll">Type: const RECT*Pointer to a RECT structure that specifies the portion of the client area to be scrolled. If this parameter is NULL, the entire client area is scrolled.</param>
        /// <param name="prcClip">Type: const RECT*Pointer to a RECT structure that contains the coordinates of the clipping rectangle. Only device bits within the clipping rectangle are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside of the rectangle to the outside are not painted. This parameter may be NULL.</param>
        /// <param name="hrgnUpdate">Type: HRGNHandle to the region that is modified to hold the region invalidated by scrolling. This parameter may be NULL.</param>
        /// <param name="prcUpdate"></param>
        /// <param name="flags">Type: UINTSpecifies flags that control scrolling. This parameter can be a combination of the following values.Type: intIf the function succeeds, the return value is SIMPLEREGION (rectangular invalidated region), COMPLEXREGION (nonrectangular invalidated region; overlapping rectangles), or NULLREGION (no invalidated region).If the function fails, the return value is ERROR. To get extended error information, call GetLastError.If the SW_INVALIDATE and SW_ERASE flags are not specified, ScrollWindowEx does not invalidate the area that is scrolled from. If either of these flags is set, ScrollWindowEx invalidates this area. The area is not updated until the application calls the UpdateWindow function, calls the RedrawWindow function (specifying the RDW_UPDATENOW or RDW_ERASENOW flag), or retrieves the WM_PAINT message from the application queue.If the window has the WS_CLIPCHILDREN style, the returned areas specified by hrgnUpdate and prcUpdate represent the total area of the scrolled window that must be updated, including any areas in child windows that need updating.If the SW_SCROLLCHILDREN flag is specified, the system does not properly update the screen if part of a child window is scrolled. The part of the scrolled child window that lies outside the source rectangle is not erased and is not properly redrawn in its new destination. To move child windows that do not lie completely within the rectangle specified by prcScroll, use the DeferWindowPos function. The cursor is repositioned if the SW_SCROLLCHILDREN flag is set and the caret rectangle intersects the scroll rectangle.All input and output coordinates (for prcScroll, prcClip, prcUpdate, and hrgnUpdate) are determined as client coordinates, regardless of whether the window has the CS_OWNDC or CS_CLASSDC class style. Use the LPtoDP and DPtoLP functions to convert to and from logical coordinates, if necessary.For an example, see Scrolling Text with the WM_PAINT Message.DPtoLPDeferWindowPosLPtoDPOther ResourcesRECTRedrawWindowUpdateWindow</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ScrollWindowEx(nint hWnd, int dx, int dy, RECT prcScroll, RECT prcClip, nint hrgnUpdate, out RECT prcUpdate, uint flags);

        /// <summary>
        ///Sends a message to the specified control in a dialog box.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the control.</param>
        /// <param name="nIDDlgItem">Type: intThe identifier of the control that receives the message.</param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: LRESULTThe return value specifies the result of the message processing and depends on the message sent.The SendDlgItemMessage function does not return until the message has been processed.Using SendDlgItemMessage is identical to retrieving a handle to the specified control and calling the SendMessage function.For an example, see Creating a Modeless Dialog Box.ConceptualDialog BoxesReferenceSendMessage</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SendDlgItemMessageA(nint hDlg, int nIDDlgItem, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Sends a message to the specified control in a dialog box.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the control.</param>
        /// <param name="nIDDlgItem">Type: intThe identifier of the control that receives the message.</param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: LRESULTThe return value specifies the result of the message processing and depends on the message sent.The SendDlgItemMessage function does not return until the message has been processed.Using SendDlgItemMessage is identical to retrieving a handle to the specified control and calling the SendMessage function.For an example, see Creating a Modeless Dialog Box.ConceptualDialog BoxesReferenceSendMessage</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SendDlgItemMessageW(nint hDlg, int nIDDlgItem, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Synthesizes keystrokes, mouse motions, and button clicks.
        /// </summary>
        /// <param name="cInputs">Type: UINTThe number of structures in the pInputs array.</param>
        /// <param name="pInputs">Type: LPINPUTAn array of INPUT structures. Each structure represents an event to be inserted into the keyboard or mouse input stream.</param>
        /// <param name="cbSize">Type: intThe size, in bytes, of an INPUT structure. If cbSize is not the size of an INPUT structure, the function fails.Type: UINTThe function returns the number of events that it successfully inserted into the keyboard or mouse input stream. If the function returns zero, the input was already blocked by another thread. To get extended error information, call GetLastError.This function fails when it is blocked by UIPI. Note that neither GetLastError nor the return value will indicate the failure was caused by UIPI blocking.This function is subject to UIPI. Applications are permitted to inject input only into applications that are at an equal or lesser integrity level.The SendInput function inserts the events in the INPUT structures serially into the keyboard or mouse input stream. These events are not interspersed with other keyboard or mouse input events inserted either by the user (with the keyboard or mouse) or by calls to keybd_event, mouse_event, or other calls to SendInput.This function does not reset the keyboard's current state. Any keys that are already pressed when the function is called might interfere with the events that this function generates. To avoid this problem, check the keyboard's state with the GetAsyncKeyState function and correct as necessary.Because the touch keyboard uses the surrogate macros defined in winnls.h to send input to the system, a listener on the keyboard event hook must decode input originating from the touch keyboard. For more information, see Surrogates and Supplementary Characters.An accessibility application can use SendInput to inject keystrokes corresponding to application launch shortcut keys that are handled by the shell. This functionality is not guaranteed to work for other types of applications.ConceptualGetAsyncKeyStateINPUTKeyboard InputReferenceSurrogates and Supplementary Characterskeybd_eventmouse_event</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint SendInput(uint cInputs, int pInputs, int cbSize);

        /// <summary>
        ///Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level.</param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: LRESULTThe return value specifies the result of the message processing; it depends on the message sent.When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the specified window was created by a different thread, the system switches to that thread and calls the appropriate window procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set. For more information on nonqueued messages, see Nonqueued Messages.An accessibility application can use SendMessage to send WM_APPCOMMAND messages to the shell to launch applications. This functionality is not guaranteed to work for other types of applications.For an example, see Displaying Keyboard Input.ConceptualInSendMessageMessages and Message QueuesPostMessagePostThreadMessageReferenceRegisterWindowMessageSendDlgItemMessageSendMessageCallbackSendMessageTimeoutSendNotifyMessage</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SendMessage(nint hWnd, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level.</param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: LRESULTThe return value specifies the result of the message processing; it depends on the message sent.When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the specified window was created by a different thread, the system switches to that thread and calls the appropriate window procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set. For more information on nonqueued messages, see Nonqueued Messages.An accessibility application can use SendMessage to send WM_APPCOMMAND messages to the shell to launch applications. This functionality is not guaranteed to work for other types of applications.For an example, see Displaying Keyboard Input.ConceptualInSendMessageMessages and Message QueuesPostMessagePostThreadMessageReferenceRegisterWindowMessageSendDlgItemMessageSendMessageCallbackSendMessageTimeoutSendNotifyMessage</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SendMessageA(nint hWnd, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Sends the specified message to a window or windows. It calls the window procedure for the specified window and returns immediately if the window belongs to another thread. After the window procedure processes the message, the system calls the specified callback function, passing the result of the message processing and an application-defined value to the callback function.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.</param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.</param>
        /// <param name="lpResultCallBack">Type: SENDASYNCPROCA pointer to a callback function that the system calls after the window procedure processes the message. For more information, see SendAsyncProc.If hWnd is HWND_BROADCAST ((HWND)0xffff), the system calls the SendAsyncProc callback function once for each top-level window.</param>
        /// <param name="dwData">Type: ULONG_PTRAn application-defined value to be sent to the callback function pointed to by the lpCallBack parameter.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the target window belongs to the same thread as the caller, then the window procedure is called synchronously, and the callback function is called immediately after the window procedure returns. If the target window belongs to a different thread from the caller, then the callback function is called only when the thread that called SendMessageCallback also calls GetMessage, PeekMessage, or WaitMessage.If you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.ConceptualMessages and Message QueuesPostMessageReferenceRegisterWindowMessageSendAsyncProcSendMessageCallbackSendNotifyMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SendMessageCallbackA(nint hWnd, uint Msg, nint wParam, nint lParam, SENDASYNCPROC lpResultCallBack, uint dwData);

        /// <summary>
        ///Sends the specified message to a window or windows. It calls the window procedure for the specified window and returns immediately if the window belongs to another thread. After the window procedure processes the message, the system calls the specified callback function, passing the result of the message processing and an application-defined value to the callback function.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.</param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.</param>
        /// <param name="lpResultCallBack">Type: SENDASYNCPROCA pointer to a callback function that the system calls after the window procedure processes the message. For more information, see SendAsyncProc.If hWnd is HWND_BROADCAST ((HWND)0xffff), the system calls the SendAsyncProc callback function once for each top-level window.</param>
        /// <param name="dwData">Type: ULONG_PTRAn application-defined value to be sent to the callback function pointed to by the lpCallBack parameter.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the target window belongs to the same thread as the caller, then the window procedure is called synchronously, and the callback function is called immediately after the window procedure returns. If the target window belongs to a different thread from the caller, then the callback function is called only when the thread that called SendMessageCallback also calls GetMessage, PeekMessage, or WaitMessage.If you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.ConceptualMessages and Message QueuesPostMessageReferenceRegisterWindowMessageSendAsyncProcSendMessageCallbackSendNotifyMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SendMessageCallbackW(nint hWnd, uint Msg, nint wParam, nint lParam, SENDASYNCPROC lpResultCallBack, uint dwData);

        /// <summary>
        ///Sends the specified message to one or more windows.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose window procedure will receive the message.If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows. The function does not return until each window has timed out. Therefore, the total wait time can be up to the value of uTimeout multiplied by the number of top-level windows.</param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAny additional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAny additional message-specific information.</param>
        /// <param name="fuFlags">Type: UINTThe behavior of this function. This parameter can be one or more of the following values.</param>
        /// <param name="uTimeout">Type: UINTThe duration of the time-out period, in milliseconds. If the message is a broadcast message, each window can use the full time-out period. For example, if you specify a five second time-out period and there are three top-level windows that fail to process the message, you could have up to a 15 second delay.</param>
        /// <param name="lpdwResult"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError. If GetLastError returns ERROR_TIMEOUT, then the function timed out.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SendMessageTimeoutA(nint hWnd, uint Msg, nint wParam, nint lParam, uint fuFlags, uint uTimeout, out uint lpdwResult);

        /// <summary>
        ///Sends the specified message to one or more windows.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose window procedure will receive the message.If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows. The function does not return until each window has timed out. Therefore, the total wait time can be up to the value of uTimeout multiplied by the number of top-level windows.</param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAny additional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAny additional message-specific information.</param>
        /// <param name="fuFlags">Type: UINTThe behavior of this function. This parameter can be one or more of the following values.</param>
        /// <param name="uTimeout">Type: UINTThe duration of the time-out period, in milliseconds. If the message is a broadcast message, each window can use the full time-out period. For example, if you specify a five second time-out period and there are three top-level windows that fail to process the message, you could have up to a 15 second delay.</param>
        /// <param name="lpdwResult"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError. If GetLastError returns ERROR_TIMEOUT, then the function timed out.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SendMessageTimeoutW(nint hWnd, uint Msg, nint wParam, nint lParam, uint fuFlags, uint uTimeout, out uint lpdwResult);

        /// <summary>
        ///Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level.</param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: LRESULTThe return value specifies the result of the message processing; it depends on the message sent.When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the specified window was created by a different thread, the system switches to that thread and calls the appropriate window procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set. For more information on nonqueued messages, see Nonqueued Messages.An accessibility application can use SendMessage to send WM_APPCOMMAND messages to the shell to launch applications. This functionality is not guaranteed to work for other types of applications.For an example, see Displaying Keyboard Input.ConceptualInSendMessageMessages and Message QueuesPostMessagePostThreadMessageReferenceRegisterWindowMessageSendDlgItemMessageSendMessageCallbackSendMessageTimeoutSendNotifyMessage</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SendMessageW(nint hWnd, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Sends the specified message to a window or windows. If the window was created by the calling thread, SendNotifyMessage calls the window procedure for the window and does not return until the window procedure has processed the message. If the window was created by a different thread, SendNotifyMessage passes the message to the window procedure and returns immediately; it does not wait for the window procedure to finish processing the message.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.</param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.If you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.ConceptualMessages and Message QueuesPostMessagePostThreadMessageReferenceRegisterWindowMessageSendMessageSendMessageCallbackSendNotifyMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SendNotifyMessageA(nint hWnd, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Sends the specified message to a window or windows. If the window was created by the calling thread, SendNotifyMessage calls the window procedure for the window and does not return until the window procedure has processed the message. If the window was created by a different thread, SendNotifyMessage passes the message to the window procedure and returns immediately; it does not wait for the window procedure to finish processing the message.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.</param>
        /// <param name="Msg">Type: UINTThe message to be sent.For lists of the system-provided messages, see System-Defined Messages.</param>
        /// <param name="wParam">Type: WPARAMAdditional message-specific information.</param>
        /// <param name="lParam">Type: LPARAMAdditional message-specific information.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.If you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.Applications that need to communicate using HWND_BROADCAST should use the RegisterWindowMessage function to obtain a unique message for inter-application communication.The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those >= WM_USER) to another process, you must do custom marshalling.ConceptualMessages and Message QueuesPostMessagePostThreadMessageReferenceRegisterWindowMessageSendMessageSendMessageCallbackSendNotifyMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SendNotifyMessageW(nint hWnd, uint Msg, nint wParam, nint lParam);

        /// <summary>
        ///Activates a window. The window must be attached to the calling thread's message queue.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the top-level window to be activated.Type: HWNDIf the function succeeds, the return value is the handle to the window that was previously active.If the function fails, the return value is NULL. To get extended error information, call GetLastError.The SetActiveWindow function activates a window, but not if the application is in the background. The window will be brought into the foreground (top of Z-Order) if its application is in the foreground when the system activates the window.If the window identified by the hWnd parameter was created by the calling thread, the active window status of the calling thread is set to hWnd. Otherwise, the active window status of the calling thread is set to NULL.ConceptualGetActiveWindowKeyboard InputReferenceSetForegroundWindowWM_ACTIVATE</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SetActiveWindow(nint hWnd);

        /// <summary>
        ///SetAdditionalForegroundBoostProcesses is a performance assist API to help applications with a multi-process application model where multiple processes contribute to a foreground experience, either as data or rendering. Examples include browsers (with the browser manager or frame, tabs, plugins, etc. hosted in different processes) and IDEs (which spawn processes for compilation and other tasks).
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetAdditionalForegroundBoostProcesses(uint processHandleCount, nint processHandleArray);

        /// <summary>
        ///Sets the mouse capture to the specified window belonging to the current thread. SetCapture captures mouse input either when the mouse is over the capturing window, or when the mouse button was pressed while the mouse was over the capturing window and the button is still down. Only one window at a time can capture the mouse.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window in the current thread that is to capture the mouse.Type: HWNDThe return value is a handle to the window that had previously captured the mouse. If there is no such window, the return value is NULL.Only the foreground window can capture the mouse. When a background window attempts to do so, the window receives messages only for mouse events that occur when the cursor hot spot is within the visible portion of the window. Also, even if the foreground window has captured the mouse, the user can still click another window, bringing it to the foreground.When the window no longer requires all mouse input, the thread that created the window should call the ReleaseCapture function to release the mouse.This function cannot be used to capture mouse input meant for another process.When the mouse is captured, menu hotkeys and other keyboard accelerators do not work.For an example, see Drawing Lines with the Mouse.ConceptualGetCaptureMouse InputReferenceReleaseCaptureWM_CAPTURECHANGED</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SetCapture(nint hWnd);

        /// <summary>
        ///Sets the caret blink time to the specified number of milliseconds. The blink time is the elapsed time, in milliseconds, required to invert the caret's pixels.
        /// </summary>
        /// <param name="uMSeconds">Type: UINTThe new blink time, in milliseconds.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The user can set the blink time using the Control Panel. Applications should respect the setting that the user has chosen. The SetCaretBlinkTime function should only be used by application that allow the user to set the blink time, such as a Control Panel applet.If you change the blink time, subsequently activated applications will use the modified blink time, even if you restore the previous blink time when you lose the keyboard focus or become inactive. This is due to the multithreaded environment, where deactivation of your application is not synchronized with the activation of another application. This feature allows the system to activate another application even if the current application is not responding.CaretsConceptualGetCaretBlinkTimeReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetCaretBlinkTime(uint uMSeconds);

        /// <summary>
        ///Moves the caret to the specified coordinates. If the window that owns the caret was created with the CS_OWNDC class style, then the specified coordinates are subject to the mapping mode of the device context associated with that window.
        /// </summary>
        /// <param name="X">Type: intThe new x-coordinate of the caret.</param>
        /// <param name="Y">Type: intThe new y-coordinate of the caret.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.SetCaretPos moves the caret whether the caret is hidden.The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The window should destroy the caret before losing the keyboard focus or becoming inactive. A window can set the caret position only if it owns the caret.For an example, see Creating and Displaying a Caret.CaretsConceptualGetCaretPosHideCaretReferenceShowCaret</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetCaretPos(int X, int Y);

        /// <summary>
        ///Replaces the specified 32-bit (long) value at the specified offset into the extra class memory or the WNDCLASSEX structure for the class to which the specified window belongs.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe value to be replaced. To set a 32-bit value in the extra class memory, specify the positive, zero-based byte offset of the value to be set. Valid values are in the range zero through the number of bytes of extra class memory, minus four; for example, if you specified 12 or more bytes of extra class memory, a value of 8 would be an index to the third 32-bit integer. To set any other value from the WNDCLASSEX structure, specify one of the following values.</param>
        /// <param name="dwNewLong">Type: LONGThe replacement value.Type: DWORDIf the function succeeds, the return value is the previous value of the specified 32-bit integer. If the value was not previously set, the return value is zero.If the function fails, the return value is zero. To get extended error information, call GetLastError.If you use the SetClassLong function and the GCL_WNDPROC index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the WindowProc callback function.Calling SetClassLong with the GCL_WNDPROC index creates a subclass of the window class that affects all windows subsequently created with the class. An application can subclass a system class, but should not subclass a window class created by another process.Reserve extra class memory by specifying a nonzero value in the cbClsExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.Use the SetClassLong function with care. For example, it is possible to change the background color for a class by using SetClassLong, but this change does not immediately repaint all windows belonging to the class.For an example, see Displaying an Icon.ConceptualGetClassLongReferenceRegisterClassExSetClassLongPtrSetWindowLongWNDCLASSEXWindow ClassesWindowProc</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint SetClassLongA(nint hWnd, int nIndex, int dwNewLong);

        /// <summary>
        ///Replaces the specified value at the specified offset in the extra class memory or the WNDCLASSEX structure for the class to which the specified window belongs.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe value to be replaced. To set a value in the extra class memory, specify the positive, zero-based byte offset of the value to be set. Valid values are in the range zero through the number of bytes of extra class memory, minus eight; for example, if you specified 24 or more bytes of extra class memory, a value of 16 would be an index to the third integer. To set a value other than the WNDCLASSEX structure, specify one of the following values.</param>
        /// <param name="dwNewLong">Type: LONG_PTRThe replacement value.Type: ULONG_PTRIf the function succeeds, the return value is the previous value of the specified offset. If this was not previously set, the return value is zero.If the function fails, the return value is zero. To get extended error information, call GetLastError.If you use the SetClassLongPtr function and the GCLP_WNDPROC index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the WindowProc callback function.Calling SetClassLongPtr with the GCLP_WNDPROC index creates a subclass of the window class that affects all windows subsequently created with the class. An application can subclass a system class, but should not subclass a window class created by another process.Reserve extra class memory by specifying a nonzero value in the cbClsExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.Use the SetClassLongPtr function with care. For example, it is possible to change the background color for a class by using SetClassLongPtr, but this change does not immediately repaint all windows belonging to the class.ConceptualGetClassLongPtrReferenceRegisterClassExSetWindowLongPtrWNDCLASSEXWindow ClassesWindowProc</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint SetClassLongPtrA(nint hWnd, int nIndex, int dwNewLong);

        /// <summary>
        ///Replaces the specified value at the specified offset in the extra class memory or the WNDCLASSEX structure for the class to which the specified window belongs.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe value to be replaced. To set a value in the extra class memory, specify the positive, zero-based byte offset of the value to be set. Valid values are in the range zero through the number of bytes of extra class memory, minus eight; for example, if you specified 24 or more bytes of extra class memory, a value of 16 would be an index to the third integer. To set a value other than the WNDCLASSEX structure, specify one of the following values.</param>
        /// <param name="dwNewLong">Type: LONG_PTRThe replacement value.Type: ULONG_PTRIf the function succeeds, the return value is the previous value of the specified offset. If this was not previously set, the return value is zero.If the function fails, the return value is zero. To get extended error information, call GetLastError.If you use the SetClassLongPtr function and the GCLP_WNDPROC index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the WindowProc callback function.Calling SetClassLongPtr with the GCLP_WNDPROC index creates a subclass of the window class that affects all windows subsequently created with the class. An application can subclass a system class, but should not subclass a window class created by another process.Reserve extra class memory by specifying a nonzero value in the cbClsExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.Use the SetClassLongPtr function with care. For example, it is possible to change the background color for a class by using SetClassLongPtr, but this change does not immediately repaint all windows belonging to the class.ConceptualGetClassLongPtrReferenceRegisterClassExSetWindowLongPtrWNDCLASSEXWindow ClassesWindowProc</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint SetClassLongPtrW(nint hWnd, int nIndex, int dwNewLong);

        /// <summary>
        ///Replaces the specified 32-bit (long) value at the specified offset into the extra class memory or the WNDCLASSEX structure for the class to which the specified window belongs.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe value to be replaced. To set a 32-bit value in the extra class memory, specify the positive, zero-based byte offset of the value to be set. Valid values are in the range zero through the number of bytes of extra class memory, minus four; for example, if you specified 12 or more bytes of extra class memory, a value of 8 would be an index to the third 32-bit integer. To set any other value from the WNDCLASSEX structure, specify one of the following values.</param>
        /// <param name="dwNewLong">Type: LONGThe replacement value.Type: DWORDIf the function succeeds, the return value is the previous value of the specified 32-bit integer. If the value was not previously set, the return value is zero.If the function fails, the return value is zero. To get extended error information, call GetLastError.If you use the SetClassLong function and the GCL_WNDPROC index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the WindowProc callback function.Calling SetClassLong with the GCL_WNDPROC index creates a subclass of the window class that affects all windows subsequently created with the class. An application can subclass a system class, but should not subclass a window class created by another process.Reserve extra class memory by specifying a nonzero value in the cbClsExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.Use the SetClassLong function with care. For example, it is possible to change the background color for a class by using SetClassLong, but this change does not immediately repaint all windows belonging to the class.For an example, see Displaying an Icon.ConceptualGetClassLongReferenceRegisterClassExSetClassLongPtrSetWindowLongWNDCLASSEXWindow ClassesWindowProc</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint SetClassLongW(nint hWnd, int nIndex, int dwNewLong);

        /// <summary>
        ///Replaces the 16-bit (WORD) value at the specified offset into the extra class memory for the window class to which the specified window belongs.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe zero-based byte offset of the value to be replaced. Valid values are in the range zero through the number of bytes of class memory minus two; for example, if you specified 10 or more bytes of extra class memory, a value of 8 would be an index to the fifth 16-bit integer.</param>
        /// <param name="wNewWord">Type: WORDThe replacement value.Type: WORDIf the function succeeds, the return value is the previous value of the specified 16-bit integer. If the value was not previously set, the return value is zero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Reserve extra class memory by specifying a nonzero value in the cbClsExtra member of the WNDCLASS structure used with the RegisterClass function.ConceptualGetClassWordReferenceRegisterClassSetClassLongWNDCLASSWindow Classes</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short SetClassWord(nint hWnd, int nIndex, short wNewWord);

        /// <summary>
        ///Places data on the clipboard in a specified clipboard format. The window must be the current clipboard owner, and the application must have called the OpenClipboard function. (When responding to the WM_RENDERFORMAT message, the clipboard owner must not call OpenClipboard before calling SetClipboardData.)
        /// </summary>
        /// <param name="uFormat">Type: UINTThe clipboard format. This parameter can be a registered format or any of the standard clipboard formats. For more information, see Standard Clipboard Formats and Registered Clipboard Formats.</param>
        /// <param name="hMem"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SetClipboardData(uint uFormat, nint hMem);

        /// <summary>
        ///Adds the specified window to the chain of clipboard viewers. Clipboard viewer windows receive a WM_DRAWCLIPBOARD message whenever the content of the clipboard changes. This function is used for backward compatibility with earlier versions of Windows.
        /// </summary>
        /// <param name="hWndNewViewer">Type: HWNDA handle to the window to be added to the clipboard chain.Type: HWNDIf the function succeeds, the return value identifies the next window in the clipboard viewer chain. If an error occurs or there are no other windows in the clipboard viewer chain, the return value is NULL. To get extended error information, call GetLastError.The windows that are part of the clipboard viewer chain, called clipboard viewer windows, must process the clipboard messages WM_CHANGECBCHAIN and WM_DRAWCLIPBOARD. Each clipboard viewer window calls the SendMessage function to pass these messages to the next window in the clipboard viewer chain.A clipboard viewer window must eventually remove itself from the clipboard viewer chain by calling the ChangeClipboardChain function — for example, in response to the WM_DESTROY message.The SetClipboardViewer function exists to provide backward compatibility with earlier versions of Windows. The clipboard viewer chain can be broken by an application that fails to handle the clipboard chain messages properly. New applications should use more robust techniques such as the clipboard sequence number or the registration of a clipboard format listener. For further details on these alternatives techniques, see Monitoring Clipboard Contents.For an example, see Adding a Window to the Clipboard Viewer Chain.ChangeClipboardChainClipboardConceptualGetClipboardViewerReferenceSendMessage</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SetClipboardViewer(nint hWndNewViewer);

        /// <summary>
        ///Creates a timer with the specified time-out value and coalescing tolerance delay.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="nIDEvent">Type: UINT_PTRA timer identifier. If the hWnd parameter is NULL, and the nIDEvent does not match an existing timer, then the nIDEvent is ignored and a new timer ID is generated. If the hWnd parameter is not NULL and the window specified by hWnd already has a timer with the value nIDEvent, then the existing timer is replaced by the new timer. When SetCoalescableTimer replaces a timer, the timer is reset. Therefore, a message will be sent after the current time-out value elapses, but the previously set time-out value is ignored. If the call is not intended to replace an existing timer, nIDEvent should be 0 if the hWnd is NULL.</param>
        /// <param name="uElapse">Type: UINTThe time-out value, in milliseconds.If uElapse is less than USER_TIMER_MINIMUM (0x0000000A), the timeout is set to USER_TIMER_MINIMUM. If uElapse is greater than USER_TIMER_MAXIMUM (0x7FFFFFFF), the timeout is set to USER_TIMER_MAXIMUM.If the sum of uElapse and uToleranceDelay exceeds USER_TIMER_MAXIMUM, an ERROR_INVALID_PARAMETER exception occurs.</param>
        /// <param name="lpTimerFunc"></param>
        /// <param name="uToleranceDelay">Type: ULONGIt can be one of the following values:Type: UINT_PTRIf the function succeeds and the hWnd parameter is NULL, the return value is an integer identifying the new timer. An application can pass this value to the KillTimer function to destroy the timer.If the function succeeds and the hWnd parameter is not NULL, then the return value is a nonzero integer. An application can pass the value of the nIDEvent parameter to the KillTimer function to destroy the timer.If the function fails to create a timer, the return value is zero. To get extended error information, call GetLastError.An application can process WM_TIMER messages by including a WM_TIMER case statement in the window procedure or by specifying a TimerProc callback function when creating the timer. When you specify a TimerProc callback function, the default window procedure calls the callback function when it processes WM_TIMER. Therefore, you need to dispatch messages in the calling thread, even when you use TimerProc instead of processing WM_TIMER.The wParam parameter of the WM_TIMER message contains the value of the nIDEvent parameter.The timer identifier, nIDEvent, is specific to the associated window. Another window can have its own timer which has the same identifier as a timer owned by another window. The timers are distinct.SetTimer can reuse timer IDs in the case where hWnd is NULL.When uToleranceDelay is set to 0, the system default timer coalescing is used and SetCoalescableTimer behaves the same as SetTimer.Before using SetCoalescableTimer or other timer-related functions, it is recommended to set the UOI_TIMERPROC_EXCEPTION_SUPPRESSION flag to false through the SetUserObjectInformationW function, otherwise the application could behave unpredictably and could be vulnerable to security exploits. For more info, see SetUserObjectInformationW.Coalescing timers sampleConceptualKeSetCoalescableTimerKeSetTimerKillTimerMSGReferenceSampleSetTimerTimerProcTimersUsing TimersWM_TIMER</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SetCoalescableTimer(nint hWnd, nint nIDEvent, uint uElapse, TIMERPROC lpTimerFunc, uint uToleranceDelay);

        /// <summary>
        ///Sets the cursor shape.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SetCursor(nint hCursor);

        /// <summary>
        ///Moves the cursor to the specified screen coordinates. If the new coordinates are not within the screen rectangle set by the most recent ClipCursor function call, the system automatically adjusts the coordinates so that the cursor stays within the rectangle.
        /// </summary>
        /// <param name="X">Type: intThe new x-coordinate of the cursor, in screen coordinates.</param>
        /// <param name="Y">Type: intThe new y-coordinate of the cursor, in screen coordinates.Type: BOOL</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetCursorPos(int X, int Y);

        /// <summary>
        ///Overrides the default per-monitor DPI scaling behavior of a child window in a dialog.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetDialogControlDpiChangeBehavior(nint hWnd, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values);

        /// <summary>
        ///Dialogs in Per-Monitor v2 contexts are automatically DPI scaled. This method lets you customize their DPI change behavior.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetDialogDpiChangeBehavior(nint hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values);

        /// <summary>
        ///Sets the screen auto-rotation preferences for the current process.
        /// </summary>
        /// <param name="orientation">Pointer to a location in memory with the screen orientation preferences to set for the calling process.TRUE if the method succeeds, otherwise FALSE.See GetDisplayAutoRotationPreferences for an example of using this function.</param>

        [DllImport("Kernel.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE orientation);

        /// <summary>
        ///The SetDisplayConfig function modifies the display topology, source, and target modes by exclusively enabling the specified paths in the current session.
        /// </summary>
        /// <param name="numPathArrayElements">Number of elements in pathArray.</param>
        /// <param name="pathArray"></param>
        /// <param name="numModeInfoArrayElements">Number of elements in modeInfoArray.</param>
        /// <param name="modeInfoArray"></param>
        /// <param name="flags">A bitwise OR of flag values that indicates the behavior of this function. This parameter can be one the following values, or a combination of the following values; 0 is not valid. See below for a description of valid flag combinations.The following list contains valid combinations of values for the Flags parameter:The function returns one of the following return codes.The SetDisplayConfig function takes the active display paths with any specified source and target mode information and uses best mode logic to generate any missing source and target mode information. This function then sets the complete display path.The ModeInfoIdx members in the DISPLAYCONFIG_PATH_SOURCE_INFO and DISPLAYCONFIG_PATH_TARGET_INFO structures are used to indicate whether source and target mode are supplied for a given active path. If the index value is DISPLAYCONFIG_PATH_MODE_IDX_INVALID for either, this indicates the mode information is not being specified. It is valid for the path plus source mode or the path plus source and target mode information to be specified for a given path. However, it is not valid for the path plus target mode to be specified without the source mode.The source and target modes for each source and target identifiers can only appear in the modeInfoArray array once. For example, a source mode for source identifier S1 can only appear in the table once; if multiple paths reference the same source, they have to use the same ModeInfoIdx.The expectation is that most callers use QueryDisplayConfig to get the current configuration along with other valid possibilities and then use SetDisplayConfig to test and set the configuration.The order in which the active paths appear in the PathArray array determines the path priority.By default, SetDisplayConfig never changes any supplied path, source mode, or target mode information. If best mode logic cannot find a solution without changing the specified display path information, SetDisplayConfig fails with ERROR_BAD_CONFIGURATION. In this case, the caller should specify the SDC_ALLOW_CHANGES flag to allow the function to tweak some of the specified source and mode details to allow the display path change to be successful.If the specified or calculated source and target modes have the same dimensions, SetDisplayConfig automatically sets the path scaling to DISPLAYCONFIG_PPR_IDENTITY before setting the display path and saving it in the database. For information about how SetDisplayConfig handles scaling, see Scaling the Desktop Image.When the caller specifies the SDC_USE_SUPPLIED_DISPLAY_CONFIG flag to set a clone path and if any source mode indexes are invalid in the path array, SetDisplayConfig determines that all of the source mode indexes from that source are invalid. SetDisplayConfig uses the best mode logic to determine the source mode information.Except for the SDC_TOPOLOGY_SUPPLIED flag (for more information about SDC_TOPOLOGY_SUPPLIED, see the following paragraph), the SDC_TOPOLOGY_XXX flags set last display path settings, including the source and target mode information for that topology type. For information about valid SDC_TOPOLOGY_XXX flag combinations, see the Flags parameter description. The pathArray and modeInfoArray parameters must be NULL, and their associated sizes must be zero. For example, if SDC_TOPOLOGY_CLONE and SDC_TOPOLOGY_EXTEND are set, this function uses the most recent clone or extend display path configuration. If a single topology type is requested, the last configuration of that type is used. If that topology had never been set before, SetDisplayConfig uses the best topology logic to find the best topology, and then best mode logic to find the best source and target mode to use. If a combination of the topology flags had been set and none of them had database entries, the following priority is used. For laptops: clone, extend, internal, and then external; for desktops the priority is extend and then clone.The caller can specify the SDC_TOPOLOGY_SUPPLIED flag to indicate that it sets just the path information (topology) and requests that SetDisplayConfig obtains and then uses the source and target mode information from the persistence database. If the active paths that the caller supplies do not have an entry in the persistence database, SetDisplayConfig fails. In this case, if the caller calls SetDisplayConfig again with the same path data but with the SDC_USE_SUPPLIED_DISPLAY_CONFIG flag set, SetDisplayConfig uses best mode logic to create the source and target mode information. When the caller specifies SDC_TOPOLOGY_SUPPLIED, the caller must set the numModeInfoArrayElements parameter to zero and the modeInfoArray parameter to NULL; however, the caller must set the pathArray and numPathArrayElements parameters for the path information that the caller requires. The caller must mark all the source and target mode indexes as invalid (DISPLAYCONFIG_PATH_MODE_IDX_INVALID) in this path data.The following table provides some common scenarios where SetDisplayConfig is called along with the flag combinations that the caller passes to the Flags parameter to achieve the scenarios.DISPLAYCONFIG_MODE_INFODISPLAYCONFIG_PATH_INFODISPLAYCONFIG_PATH_SOURCE_INFODISPLAYCONFIG_PATH_TARGET_INFOQueryDisplayConfig</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int SetDisplayConfig(int numPathArrayElements, DISPLAYCONFIG_PATH_INFO pathArray, int numModeInfoArrayElements, DISPLAYCONFIG_PATH_INFO modeInfoArray, int flags);

        /// <summary>
        ///Sets the text of a control in a dialog box to the string representation of a specified integer value.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the control.</param>
        /// <param name="nIDDlgItem">Type: intThe control to be changed.</param>
        /// <param name="uValue">Type: UINTThe integer value used to generate the item text.</param>
        /// <param name="bSigned">Type: BOOLIndicates whether the uValue parameter is signed or unsigned. If this parameter is TRUE, uValue is signed. If this parameter is TRUE and uValue is less than zero, a minus sign is placed before the first digit in the string. If this parameter is FALSE, uValue is unsigned.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.To set the new text, this function sends a WM_SETTEXT message to the specified control.ConceptualDialog BoxesGetDlgItemIntReferenceSetDlgItemTextWM_SETTEXT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetDlgItemInt(nint hDlg, int nIDDlgItem, uint uValue, bool bSigned);

        /// <summary>
        ///Sets the title or text of a control in a dialog box.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the control.</param>
        /// <param name="nIDDlgItem">Type: intThe control with a title or text to be set.</param>
        /// <param name="lpString">Type: LPCTSTRThe text to be copied to the control.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The SetDlgItemText function sends a WM_SETTEXT message to the specified control.For an example, see Using List Boxes.ConceptualDialog BoxesGetDlgItemIntGetDlgItemTextReferenceSetDlgItemIntWM_SETTEXT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetDlgItemTextA(nint hDlg, int nIDDlgItem, string lpString);

        /// <summary>
        ///Sets the title or text of a control in a dialog box.
        /// </summary>
        /// <param name="hDlg">Type: HWNDA handle to the dialog box that contains the control.</param>
        /// <param name="nIDDlgItem">Type: intThe control with a title or text to be set.</param>
        /// <param name="lpString">Type: LPCTSTRThe text to be copied to the control.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The SetDlgItemText function sends a WM_SETTEXT message to the specified control.For an example, see Using List Boxes.ConceptualDialog BoxesGetDlgItemIntGetDlgItemTextReferenceSetDlgItemIntWM_SETTEXT</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetDlgItemTextW(nint hDlg, int nIDDlgItem, string lpString);

        /// <summary>
        ///Sets the double-click time for the mouse. A double-click is a series of two clicks of a mouse button, the second occurring within a specified time after the first. The double-click time is the maximum number of milliseconds that may occur between the first and second clicks of a double-click.
        /// </summary>
        /// <param name="unnamedParam1">Type: UINTThe number of milliseconds that may occur between the first and second clicks of a double-click. If this parameter is set to 0, the system uses the default double-click time of 500 milliseconds. If this parameter value is greater than 5000 milliseconds, the system sets the value to 5000 milliseconds.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The SetDoubleClickTime function alters the double-click time for all windows in the system.ConceptualGetDoubleClickTimeMouse InputReference</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetDoubleClickTime(uint unnamedParam1);

        /// <summary>
        ///Sets the keyboard focus to the specified window. The window must be attached to the calling thread's message queue.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SetFocus(nint hWnd);

        /// <summary>
        ///Brings the thread that created the specified window into the foreground and activates the window. Keyboard input is directed to the window, and various visual cues are changed for the user. The system assigns a slightly higher priority to the thread that created the foreground window than it does to other threads.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window that should be activated and brought to the foreground.Type: BOOLIf the window was brought to the foreground, the return value is nonzero.If the window was not brought to the foreground, the return value is zero.The system restricts which processes can set the foreground window. A process can set the foreground window by calling SetForegroundWindow only if:It is possible for a process to be denied the right to set the foreground window even if it meets these conditions.An application cannot force a window to the foreground while the user is working with another window. Instead, Windows flashes the taskbar button of the window to notify the user.A process that can set the foreground window can enable another process to set the foreground window by calling the AllowSetForegroundWindow function. The process specified by the dwProcessId parameter to AllowSetForegroundWindow loses the ability to set the foreground window the next time that either the user generates input, unless the input is directed at that process, or the next time a process calls AllowSetForegroundWindow, unless the same process is specified as in the previous call to AllowSetForegroundWindow.The foreground process can disable calls to SetForegroundWindow by calling the LockSetForegroundWindow function.The following code example demonstrates the use of SetForegroundWindowAllowSetForegroundWindowConceptualFlashWindowExGetForegroundWindowLockSetForegroundWindowReferenceSetActiveWindowWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetForegroundWindow(nint hWnd);

        /// <summary>
        ///Configures the messages that are sent from a window for Windows Touch gestures.
        /// </summary>
        /// <param name="hwnd">A handle to the window to set the gesture configuration on.</param>
        /// <param name="dwReserved">This value is reserved and must be set to 0.</param>
        /// <param name="cIDs">A count of the gesture configuration structures that are being passed.</param>
        /// <param name="pGestureConfig">An array of gesture configuration structures that specify the gesture configuration.</param>
        /// <param name="cbSize">The size of the gesture configuration (GESTURECONFIG) structure.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.If you don't expect to change the gesture configuration, call SetGestureConfig at window creation time. If you want to dynamically change the gesture configuration, call SetGestureConfig in response to WM_GESTURENOTIFY messages.The following table shows the identifiers for gestures that are supported by the dwID member of the GESTURECONFIG structure. Note that setting dwID to 0 indicates that global gesture configuration flags are set.The following flags are used when dwID is set to zero.The following flags are used when dwID is set to GID_ZOOM.The following flags are used when dwID is set to GID_PAN.The following flags are used when dwID is set to GID_TWOFINGERTAP.The following flags are used when dwID is set to GID_PRESSANDTAP.The following example shows how you could receive horizontal and vertical single-finger panning with no gutter and no inertia. This is a typical configuration for a 2-D navigation application such as the Microsoft PixelSense Globe application.The following example shows how to receive single-finger pan gestures and disable gutter panning. This is a typical configuration for applications that scroll text such as Notepad.The following example shows how you can disable all gestures.The following example shows how you could enable all gestures.The following example shows how you could enable all Windows 7 gestures.The following example configuration would set the parent window to enable support for zoom, horizontal pan, and vertical pan while the child window would just support horizontal pan.FunctionsGESTURECONFIGGetGestureConfigProgramming Guide for GesturesWM_GESTURENOTIFY</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetGestureConfig(nint hwnd, uint dwReserved, uint cIDs, GESTURECONFIG pGestureConfig, uint cbSize);

        /// <summary>
        ///Copies an array of keyboard key states into the calling thread's keyboard input-state table. This is the same table accessed by the GetKeyboardState and GetKeyState functions. Changes made to this table do not affect keyboard input to any other thread.
        /// </summary>
        /// <param name="lpKeyState">Type: LPBYTEA pointer to a 256-byte array that contains keyboard key states.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Because the SetKeyboardState function alters the input state of the calling thread and not the global input state of the system, an application cannot use SetKeyboardState to set the NUM LOCK, CAPS LOCK, or SCROLL LOCK (or the Japanese KANA) indicator lights on the keyboard. These can be set or cleared using SendInput to simulate keystrokes.</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetKeyboardState(byte lpKeyState);

        /// <summary>
        ///Sets the last-error code.
        /// </summary>
        /// <param name="dwErrCode">The last-error code for the thread.</param>
        /// <param name="dwType">This parameter is ignored.NoneThe last-error code is kept in thread local storage so that multiple threads do not overwrite each other's values.Most functions call SetLastError or SetLastErrorEx only when they fail. However, some system functions call SetLastError or SetLastErrorEx under conditions of success; those cases are noted in each function's documentation.Applications can optionally retrieve the value set by this function by using the GetLastError function immediately after a function fails.Error codes are 32-bit values (bit 31 is the most significant bit). Bit 29 is reserved for application-defined error codes; no system error code has this bit set. If you are defining an error code for your application, set this bit to indicate that the error code has been defined by the application and to ensure that your error code does not conflict with any system-defined error codes.Error Handling FunctionsGetLastErrorLast-Error Code</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void SetLastErrorEx(uint dwErrCode, uint dwType);

        /// <summary>
        ///Sets the opacity and transparency color key of a layered window.
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the layered window. A layered window is created by specifying WS_EX_LAYERED when creating the window with the CreateWindowEx function or by setting WS_EX_LAYERED via SetWindowLong after the window has been created.Windows 8:  The WS_EX_LAYERED style is supported for top-level windows and child windows. Previous Windows versions support WS_EX_LAYERED only for top-level windows.</param>
        /// <param name="crKey">Type: COLORREFA COLORREF structure that specifies the transparency color key to be used when composing the layered window. All pixels painted by the window in this color will be transparent. To generate a COLORREF, use the RGB macro.</param>
        /// <param name="bAlpha">Type: BYTEAlpha value used to describe the opacity of the layered window. Similar to the SourceConstantAlpha member of the BLENDFUNCTION structure. When bAlpha is 0, the window is completely transparent. When bAlpha is 255, the window is opaque.</param>
        /// <param name="dwFlags">Type: DWORDAn action to be taken. This parameter can be one or more of the following values.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Note that once SetLayeredWindowAttributes has been called for a layered window, subsequent UpdateLayeredWindow calls will fail until the layering style bit is cleared and set again.For more information, see Using Layered Windows.AlphaBlendCOLORREFConceptualCreateWindowExOther ResourcesRGBReferenceSetWindowLongTransparentBltUpdateLayeredWindowUsing WindowsWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetLayeredWindowAttributes(nint hwnd, COORD crKey, byte bAlpha, uint dwFlags);

        /// <summary>
        ///Assigns a new menu to the specified window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window to which the menu is to be assigned.</param>
        /// <param name="hMenu"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetMenu(nint hWnd, nint hMenu);

        /// <summary>
        ///Associates a Help context identifier with a menu.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetMenuContextHelpId(nint unnamedParam1, uint unnamedParam2);

        /// <summary>
        ///Sets the default menu item for the specified menu.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu to set the default item for.</param>
        /// <param name="uItem">Type: UINTThe identifier or position of the new default menu item or -1 for no default item. The meaning of this parameter depends on the value of fByPos.</param>
        /// <param name="fByPos">Type: UINTThe meaning of uItem. If this parameter is FALSE, uItem is a menu item identifier. Otherwise, it is a menu item position. See About Menus for more information.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.ConceptualGetMenuDefaultItemMenusReference</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetMenuDefaultItem(nint hMenu, uint uItem, uint fByPos);

        /// <summary>
        ///Sets information for a specified menu.
        /// </summary>
        /// <param name="unnamedParam1">Type: HMENUA handle to a menu.</param>
        /// <param name="unnamedParam2">Type: LPCMENUINFOA pointer to a MENUINFO structure for the menu.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Menus</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetMenuInfo(nint unnamedParam1, MENUINFO unnamedParam2);

        /// <summary>
        ///Associates the specified bitmap with a menu item. Whether the menu item is selected or clear, the system displays the appropriate bitmap next to the menu item.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the menu containing the item to receive new check-mark bitmaps.</param>
        /// <param name="uPosition">Type: UINTThe menu item to be changed, as determined by the uFlags parameter.</param>
        /// <param name="uFlags">Type: UINTSpecifies how the uPosition parameter is to be interpreted. The uFlags parameter must be one of the following values.</param>
        /// <param name="hBitmapUnchecked"></param>
        /// <param name="hBitmapChecked"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetMenuItemBitmaps(nint hMenu, uint uPosition, uint uFlags, nint hBitmapUnchecked, nint hBitmapChecked);

        /// <summary>
        ///Changes information about a menu item.
        /// </summary>
        /// <param name="hmenu">Type: HMENUA handle to the menu that contains the menu item.</param>
        /// <param name="item">Type: UINTThe identifier or position of the menu item to change. The meaning of this parameter depends on the value of fByPosition.fByPositon</param>
        /// <param name="fByPositon"></param>
        /// <param name="lpmii">Type: LPMENUITEMINFOA pointer to a MENUITEMINFO structure that contains information about the menu item and specifies which menu item attributes to change.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the WM_MENUCHAR message. See Owner-Drawn Menus and the WM_MENUCHAR Message for more information.For an example, see Example of Owner-Drawn Menu Items.ConceptualDrawMenuBarGetMenuItemInfoMENUITEMINFOMenusReference</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetMenuItemInfoA(nint hmenu, uint item, bool fByPositon, MENUITEMINFOA lpmii);

        /// <summary>
        ///Changes information about a menu item.
        /// </summary>
        /// <param name="hmenu">Type: HMENUA handle to the menu that contains the menu item.</param>
        /// <param name="item">Type: UINTThe identifier or position of the menu item to change. The meaning of this parameter depends on the value of fByPosition.fByPositon</param>
        /// <param name="fByPositon"></param>
        /// <param name="lpmii">Type: LPMENUITEMINFOA pointer to a MENUITEMINFO structure that contains information about the menu item and specifies which menu item attributes to change.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the WM_MENUCHAR message. See Owner-Drawn Menus and the WM_MENUCHAR Message for more information.For an example, see Example of Owner-Drawn Menu Items.ConceptualDrawMenuBarGetMenuItemInfoMENUITEMINFOMenusReference</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetMenuItemInfoW(nint hmenu, uint item, bool fByPositon, MENUITEMINFOW lpmii);

        /// <summary>
        ///Sets the extra message information for the current thread. Extra message information is an application- or driver-defined value associated with the current thread's message queue. An application can use the GetMessageExtraInfo function to retrieve a thread's extra message information.
        /// </summary>
        /// <param name="lParam">Type: LPARAMThe value to be associated with the current thread.Type: LPARAMThe return value is the previous value associated with the current thread.ConceptualGetMessageExtraInfoMessages and Message QueuesReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SetMessageExtraInfo(nint lParam);

        /// <summary>
        ///Changes the parent window of the specified child window.
        /// </summary>
        /// <param name="hWndChild">Type: HWNDA handle to the child window.</param>
        /// <param name="hWndNewParent"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SetParent(nint hWndChild, nint hWndNewParent);

        /// <summary>
        ///Sets the position of the cursor in physical coordinates.
        /// </summary>
        /// <param name="X">Type: intThe new x-coordinate of the cursor, in physical coordinates.</param>
        /// <param name="Y">Type: intThe new y-coordinate of the cursor, in physical coordinates.Type: BOOLTRUE if successful; otherwise FALSE.For a description of the difference between logical coordinates and physical coordinates, see PhysicalToLogicalPoint.GetLastError can be called to get more information about any error that is generated.ClipCursorConceptualCursorsGetCursorPosGetPhysicalCursorPosReferenceSetCaretPosSetCursorSetCursorPosShowCursor</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetPhysicalCursorPos(int X, int Y);

        /// <summary>
        ///Changes the default layout when windows are created with no parent or owner only for the currently running process.
        /// </summary>
        /// <param name="dwDefaultLayout">Type: DWORDThe default process layout. This parameter can be 0 or the following value.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The layout specifies how text and graphics are laid out; the default is left to right. The SetProcessDefaultLayout function changes layout to be right to left, which is the standard in Arabic and Hebrew cultures.After the LAYOUT_RTL flag is selected, flags normally specifying right or left are reversed. To avoid confusion, consider defining alternate words for standard flags, such as those in the following table.If using this function with a mirrored window, note that the SetProcessDefaultLayout function does not mirror the whole process and all the device contexts (DCs) created in it. It mirrors only the mirrored window's DCs. To mirror any DC, use the SetLayout function.ConceptualGetProcessDefaultLayoutOther ResourcesReferenceSetLayoutWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetProcessDefaultLayout(uint dwDefaultLayout);

        /// <summary>
        ///Sets the process-default DPI awareness to system-DPI awareness. This is equivalent to calling SetProcessDpiAwarenessContext with a DPI_AWARENESS_CONTEXT value of DPI_AWARENESS_CONTEXT_SYSTEM_AWARE.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetProcessDPIAware();

        /// <summary>
        ///Sets the current process to a specified dots per inch (dpi) awareness context. The DPI awareness contexts are from the DPI_AWARENESS_CONTEXT value.
        /// </summary>
        /// <param name="value">A DPI_AWARENESS_CONTEXT handle to set.This function returns TRUE if the operation was successful, and FALSE otherwise. To get extended error information, call GetLastError.Possible errors are ERROR_INVALID_PARAMETER for an invalid input, and ERROR_ACCESS_DENIED if the default API awareness mode for the process has already been set (via a previous API call or within the application manifest).This API is a more advanced version of the previously existing SetProcessDpiAwareness API, allowing for the process default to be set to the finer-grained DPI_AWARENESS_CONTEXT values. Most importantly, this allows you to programmatically set Per Monitor v2 as the process default value, which is not possible with the previous API.This method sets the default DPI_AWARENESS_CONTEXT for all threads within an application. Individual threads can have their DPI awareness changed from the default with the SetThreadDpiAwarenessContext method.You must call this API before you call any APIs that depend on the DPI awareness (including before creating any UI in your process). Once API awareness is set for an app, any future calls to this API will fail. This is true regardless of whether you set the DPI awareness in the manifest or by using this API.If the DPI awareness level is not set, the default value is DPI_AWARENESS_CONTEXT_UNAWARE.DPI_AWARENESS_CONTEXTSetThreadDpiAwarenessContextSetting the default DPI awareness for a process</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetProcessDpiAwarenessContext(DPI_AWARENESS value);

        /// <summary>
        ///Exempts the calling process from restrictions preventing desktop processes from interacting with the Windows Store app environment. This function is used by development and debugging tools.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetProcessRestrictionExemption(bool fEnableExemption);

        /// <summary>
        ///Assigns the specified window station to the calling process. This enables the process to access objects in the window station such as desktops, the clipboard, and global atoms. All subsequent operations on the window station use the access rights granted to hWinSta.
        /// </summary>
        /// <param name="hWinSta">A handle to the window station. This can be a handle returned by the CreateWindowStation, OpenWindowStation, or GetProcessWindowStation function.This window station must be associated with the current session.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.CreateWindowStationGetProcessWindowStationOpenWindowStationSetThreadDesktopWindow Station and Desktop FunctionsWindow Stations</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetProcessWindowStation(int hWinSta);

        /// <summary>
        ///Adds a new entry or changes an existing entry in the property list of the specified window. The function adds a new entry to the list if the specified character string does not exist already in the list. The new entry contains the string and the handle. Otherwise, the function replaces the string's current handle with the specified handle.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose property list receives the new entry.</param>
        /// <param name="lpString">Type: LPCTSTRA null-terminated string or an atom that identifies a string. If this parameter is an atom, it must be a global atom created by a previous call to the GlobalAddAtom function. The atom must be placed in the low-order word of lpString; the high-order word must be zero.</param>
        /// <param name="hData"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetPropA(nint hWnd, string lpString, nint hData);

        /// <summary>
        ///Adds a new entry or changes an existing entry in the property list of the specified window. The function adds a new entry to the list if the specified character string does not exist already in the list. The new entry contains the string and the handle. Otherwise, the function replaces the string's current handle with the specified handle.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose property list receives the new entry.</param>
        /// <param name="lpString">Type: LPCTSTRA null-terminated string or an atom that identifies a string. If this parameter is an atom, it must be a global atom created by a previous call to the GlobalAddAtom function. The atom must be placed in the low-order word of lpString; the high-order word must be zero.</param>
        /// <param name="hData"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetPropW(nint hWnd, string lpString, nint hData);

        /// <summary>
        ///The SetRect function sets the coordinates of the specified rectangle. This is equivalent to assigning the left, top, right, and bottom arguments to the appropriate members of the RECT structure.
        /// </summary>
        /// <param name="lprc"></param>
        /// <param name="xLeft">Specifies the x-coordinate of the rectangle's upper-left corner.</param>
        /// <param name="yTop">Specifies the y-coordinate of the rectangle's upper-left corner.</param>
        /// <param name="xRight">Specifies the x-coordinate of the rectangle's lower-right corner.</param>
        /// <param name="yBottom">Specifies the y-coordinate of the rectangle's lower-right corner.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure.For an example, see Using Rectangles.CopyRectRECTRectangle FunctionsRectangles OverviewSetRectEmpty</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetRect(out RECT lprc, int xLeft, int yTop, int xRight, int yBottom);

        /// <summary>
        ///The SetRectEmpty function creates an empty rectangle in which all coordinates are set to zero.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetRectEmpty(out RECT lprc);

        /// <summary>
        ///The SetScrollInfo function sets the parameters of a scroll bar, including the minimum and maximum scrolling positions, the page size, and the position of the scroll box (thumb). The function also redraws the scroll bar, if requested.
        /// </summary>
        /// <param name="hwnd">Type: HWNDHandle to a scroll bar control or a window with a standard scroll bar, depending on the value of the fnBar parameter.</param>
        /// <param name="nBar">Type: intSpecifies the type of scroll bar for which to set parameters. This parameter can be one of the following values.</param>
        /// <param name="lpsi">Type: LPCSCROLLINFOPointer to a SCROLLINFO structure. Before calling SetScrollInfo, set the cbSize member of the structure to sizeof(SCROLLINFO), set the fMask member to indicate the parameters to set, and specify the new parameter values in the appropriate members.The fMask member can be one or more of the following values.</param>
        /// <param name="redraw">Type: BOOLSpecifies whether the scroll bar is redrawn to reflect the changes to the scroll bar. If this parameter is TRUE, the scroll bar is redrawn, otherwise, it is not redrawn.Type: intThe return value is the current position of the scroll box.The SetScrollInfo function performs range checking on the values specified by the nPage and nPos members of the SCROLLINFO structure. The nPage member must specify a value from 0 to nMax - nMin +1. The nPos member must specify a value between nMin and nMax - max( nPage– 1, 0). If either value is beyond its range, the function sets it to a value that is just within the range.If the fnBar parameter is SB_CTL and the window specified by the hwnd parameter is not a system scroll bar control, the system sends the SBM_SETSCROLLINFO message to the window to set scroll bar information (The system can optimize the message to SBM_SETPOS or SBM_SETRANGE if the request is solely for the position or range). This allows SetScrollInfo to operate on a custom control that mimics a scroll bar. If the window does not handle SBM_SETSCROLLINFO (or the optimized SBM_SETPOS message or SBM_SETRANGE message), then the SetScrollInfo function fails.For an example, see Scrolling Text with the WM_PAINT Message.GetScrollInfoReferenceSCROLLINFO</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int SetScrollInfo(nint hwnd, int nBar, SCROLLINFO lpsi, bool redraw);

        /// <summary>
        ///The SetScrollPos function sets the position of the scroll box (thumb) in the specified scroll bar and, if requested, redraws the scroll bar to reflect the new position of the scroll box.
        /// </summary>
        /// <param name="hWnd">Type: HWNDHandle to a scroll bar control or a window with a standard scroll bar, depending on the value of the nBar parameter.</param>
        /// <param name="nBar">Type: intSpecifies the scroll bar to be set. This parameter can be one of the following values.</param>
        /// <param name="nPos">Type: intSpecifies the new position of the scroll box. The position must be within the scrolling range. For more information about the scrolling range, see the SetScrollRange function.</param>
        /// <param name="bRedraw">Type: BOOLSpecifies whether the scroll bar is redrawn to reflect the new scroll box position. If this parameter is TRUE, the scroll bar is redrawn. If it is FALSE, the scroll bar is not redrawn.Type: intIf the function succeeds, the return value is the previous position of the scroll box.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the scroll bar is redrawn by a subsequent call to another function, setting the bRedraw parameter to FALSE is useful.Because the messages that indicate scroll bar position, WM_HSCROLL and WM_VSCROLL, are limited to 16 bits of position data, applications that rely solely on those messages for position data have a practical maximum value of 65,535 for the SetScrollPos function's nPos parameter.However, because the SetScrollInfo, SetScrollPos, SetScrollRange, GetScrollInfo, GetScrollPos, and GetScrollRange functions support 32-bit scroll bar position data, there is a way to circumvent the 16-bit barrier of the WM_HSCROLL and WM_VSCROLL messages. See GetScrollInfo for a description of the technique.If the nBar parameter is SB_CTL and the window specified by the hWnd parameter is not a system scroll bar control, the system sends the SBM_SETPOS message to the window to set scroll bar information. This allows SetScrollPos to operate on a custom control that mimics a scroll bar. If the window does not handle the SBM_SETPOS message, the SetScrollPos function fails.GetScrollInfoGetScrollPosGetScrollRangeReferenceSetScrollInfoSetScrollRange</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int SetScrollPos(nint hWnd, int nBar, int nPos, bool bRedraw);

        /// <summary>
        ///The SetScrollRange function sets the minimum and maximum scroll box positions for the specified scroll bar.
        /// </summary>
        /// <param name="hWnd">Type: HWNDHandle to a scroll bar control or a window with a standard scroll bar, depending on the value of the nBar parameter.</param>
        /// <param name="nBar">Type: intSpecifies the scroll bar to be set. This parameter can be one of the following values.</param>
        /// <param name="nMinPos">Type: intSpecifies the minimum scrolling position.</param>
        /// <param name="nMaxPos">Type: intSpecifies the maximum scrolling position.</param>
        /// <param name="bRedraw">Type: BOOLSpecifies whether the scroll bar should be redrawn to reflect the change. If this parameter is TRUE, the scroll bar is redrawn. If it is FALSE, the scroll bar is not redrawn.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.You can use SetScrollRange to hide the scroll bar by setting nMinPos and nMaxPos to the same value. An application should not call the SetScrollRange function to hide a scroll bar while processing a scroll bar message. New applications should use the ShowScrollBar function to hide the scroll bar.If the call to SetScrollRange immediately follows a call to the SetScrollPos function, the bRedraw parameter in SetScrollPos must be zero to prevent the scroll bar from being drawn twice.The default range for a standard scroll bar is 0 through 100. The default range for a scroll bar control is empty (both the nMinPos and nMaxPos parameter values are zero). The difference between the values specified by the nMinPos and nMaxPos parameters must not be greater than the value of MAXLONG.Because the messages that indicate scroll bar position, WM_HSCROLL and WM_VSCROLL, are limited to 16 bits of position data, applications that rely solely on those messages for position data have a practical maximum value of 65,535 for the SetScrollRange function's nMaxPos parameter.However, because the SetScrollInfo, SetScrollPos, SetScrollRange, GetScrollInfo, GetScrollPos, and GetScrollRange functions support 32-bit scroll bar position data, there is a way to circumvent the 16-bit barrier of the WM_HSCROLL and WM_VSCROLL messages. See GetScrollInfo for a description of the technique.If the nBar parameter is SB_CTL and the window specified by the hWnd parameter is not a system scroll bar control, the system sends the SBM_SETRANGE message to the window to set scroll bar information. This allows SetScrollRange to operate on a custom control that mimics a scroll bar. If the window does not handle the SBM_SETRANGE message, the SetScrollRange function fails.For an example, see Using the Owner-Display Clipboard Format.GetScrollInfoGetScrollPosGetScrollRangeReferenceSetScrollInfoSetScrollPosShowScrollBar</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetScrollRange(nint hWnd, int nBar, int nMinPos, int nMaxPos, bool bRedraw);

        /// <summary>
        ///Sets the colors for the specified display elements. Display elements are the various parts of a window and the display that appear on the system display screen.
        /// </summary>
        /// <param name="cElements">Type: intThe number of display elements in the lpaElements array.</param>
        /// <param name="lpaElements">Type: const INT*An array of integers that specify the display elements to be changed. For a list of display elements, see GetSysColor.</param>
        /// <param name="lpaRgbValues">Type: const COLORREF*An array of COLORREF values that contain the new red, green, blue (RGB) color values for the display elements in the array pointed to by the lpaElements parameter.To generate a COLORREF, use the RGB macro.Type: BOOLIf the function succeeds, the return value is a nonzero value.If the function fails, the return value is zero. To get extended error information, call GetLastError.The SetSysColors function sends a WM_SYSCOLORCHANGE message to all windows to inform them of the change in color. It also directs the system to repaint the affected portions of all currently visible windows.It is best to respect the color settings specified by the user. If you are writing an application to enable the user to change the colors, then it is appropriate to use this function. However, this function affects only the current session. The new colors are not saved when the system terminates.The following example demonstrates the use of the GetSysColor and SetSysColors functions. First, the example uses GetSysColor to retrieve the colors of the window background and active caption and displays the red, green, blue (RGB) values in hexadecimal notation. Next, example uses SetSysColors to change the color of the window background to light gray and the active title bars to dark purple. After a 10-second delay, the example restores the previous colors for these elements using SetSysColors.COLORREFGetSysColorRGB</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetSysColors(int cElements, int lpaElements, COORD lpaRgbValues);

        /// <summary>
        ///Enables an application to customize the system cursors. It replaces the contents of the system cursor specified by the id parameter with the contents of the cursor specified by the hcur parameter and then destroys hcur.
        /// </summary>
        /// <param name="hcur">Type: HCURSORA handle to the cursor. The function replaces the contents of the system cursor specified by id with the contents of the cursor handled by hcur.The system destroys hcur by calling the DestroyCursor function. Therefore, hcur cannot be a cursor loaded using the LoadCursor function. To specify a cursor loaded from a resource, copy the cursor using the CopyCursor function, then pass the copy to SetSystemCursor.</param>
        /// <param name="id">Type: DWORDThe system cursor to replace with the contents of hcur. This parameter can be one of the following values.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.For an application to use any of the OCR_ constants, the constant OEMRESOURCE must be defined before the Windows.h header file is included.ConceptualCursorsDestroyCursorLoadCursorLoadCursorFromFileReferenceSetCursor</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetSystemCursor(nint hcur, uint id);

        /// <summary>
        ///Assigns the specified desktop to the calling thread. All subsequent operations on the desktop use the access rights granted to the desktop.
        /// </summary>
        /// <param name="hDesktop">A handle to the desktop to be assigned to the calling thread. This handle is returned by the CreateDesktop, GetThreadDesktop, OpenDesktop, or OpenInputDesktop function.This desktop must be associated with the current window station for the process.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The SetThreadDesktop function will fail if the calling thread has any windows or hooks on its current desktop (unless the hDesktop parameter is a handle to the current desktop).CreateDesktopDesktopsGetThreadDesktopOpenDesktopSetProcessWindowStationWindow Station and Desktop Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetThreadDesktop(nint hDesktop);

        /// <summary>
        ///Set the DPI awareness for the current thread to the provided value.
        /// </summary>
        /// <param name="dpiContext">The new DPI_AWARENESS_CONTEXT for the current thread. This context includes the DPI_AWARENESS value.The old DPI_AWARENESS_CONTEXT for the thread. If the dpiContext is invalid, the thread will not be updated and the return value will be NULL. You can use this value to restore the old DPI_AWARENESS_CONTEXT after overriding it with a predefined value.Use this API to change the DPI_AWARENESS_CONTEXT for the thread from the default value for the app.DPI_AWARENESS</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern DPI_AWARENESS SetThreadDpiAwarenessContext(DPI_AWARENESS dpiContext);

        /// <summary>
        ///Sets the thread's DPI_HOSTING_BEHAVIOR. This behavior allows windows created in the thread to host child windows with a different DPI_AWARENESS_CONTEXT.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern DPI_HOSTING_BEHAVIOR SetThreadDpiHostingBehavior(DPI_HOSTING_BEHAVIOR value);

        /// <summary>
        ///Creates a timer with the specified time-out value.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="nIDEvent">Type: UINT_PTRA nonzero timer identifier. If the hWnd parameter is NULL, and the nIDEvent does not match an existing timer then it is ignored and a new timer ID is generated. If the hWnd parameter is not NULL and the window specified by hWnd already has a timer with the value nIDEvent, then the existing timer is replaced by the new timer. When SetTimer replaces a timer, the timer is reset. Therefore, a message will be sent after the current time-out value elapses, but the previously set time-out value is ignored. If the call is not intended to replace an existing timer, nIDEvent should be 0 if the hWnd is NULL.</param>
        /// <param name="uElapse">Type: UINTThe time-out value, in milliseconds.If uElapse is less than USER_TIMER_MINIMUM (0x0000000A), the timeout is set to USER_TIMER_MINIMUM. If uElapse is greater than USER_TIMER_MAXIMUM (0x7FFFFFFF), the timeout is set to USER_TIMER_MAXIMUM.</param>
        /// <param name="lpTimerFunc"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint SetTimer(nint hWnd, nint nIDEvent, uint uElapse, TIMERPROC lpTimerFunc);

        /// <summary>
        ///Sets information about the specified window station or desktop object.
        /// </summary>
        /// <param name="hObj">A handle to the window station, desktop object or a current process pseudo handle. This handle can be returned by the CreateWindowStation, OpenWindowStation, CreateDesktop, OpenDesktop or GetCurrentProcess function.</param>
        /// <param name="nIndex">The object information to be set. This parameter can be the following value.</param>
        /// <param name="pvInfo">A pointer to a buffer containing the object information, or a BOOL.</param>
        /// <param name="nLength">The size of the information contained in the buffer pointed to by pvInfo, in bytes.If the function succeeds, the return value is nonzero.If the function fails the return value is zero. To get extended error information, call GetLastError.CreateDesktopCreateWindowStationGetUserObjectInformationOpenDesktopOpenWindowStationUSEROBJECTFLAGSWindow Station and Desktop FunctionsWindow Stations</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetUserObjectInformationA(nint hObj, int nIndex, nint pvInfo, uint nLength);

        /// <summary>
        ///Sets information about the specified window station or desktop object.
        /// </summary>
        /// <param name="hObj">A handle to the window station, desktop object or a current process pseudo handle. This handle can be returned by the CreateWindowStation, OpenWindowStation, CreateDesktop, OpenDesktop or GetCurrentProcess function.</param>
        /// <param name="nIndex">The object information to be set. This parameter can be the following value.</param>
        /// <param name="pvInfo">A pointer to a buffer containing the object information, or a BOOL.</param>
        /// <param name="nLength">The size of the information contained in the buffer pointed to by pvInfo, in bytes.If the function succeeds, the return value is nonzero.If the function fails the return value is zero. To get extended error information, call GetLastError.CreateDesktopCreateWindowStationGetUserObjectInformationOpenDesktopOpenWindowStationUSEROBJECTFLAGSWindow Station and Desktop FunctionsWindow Stations</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetUserObjectInformationW(nint hObj, int nIndex, nint pvInfo, uint nLength);

        /// <summary>
        ///The SetUserObjectSecurity function sets the security of a user object. This can be, for example, a window or a DDE conversation.
        /// </summary>
        /// <param name="hObj">A handle to a user object for which security information is set.</param>
        /// <param name="pSIRequested">A pointer to a value that indicates the components of the security descriptor to set. This parameter can be a combination of the following values.</param>
        /// <param name="pSID">A pointer to a SECURITY_DESCRIPTOR structure that contains the new security information.This buffer must be aligned on a 4-byte boundary.If the function succeeds, the function returns nonzero.If the function fails, it returns zero. To get extended error information, call GetLastError.The SetUserObjectSecurity function applies changes specified in a security descriptor to the security descriptor assigned to a user object. The security descriptor of the object must be in self-relative form. If necessary, this function allocates additional memory to increase the size of the security descriptor.For an example that uses this function, see Starting an Interactive Client Process.GetUserObjectSecurityLow-level Access ControlLow-level Access Control FunctionsSECURITY_DESCRIPTORSECURITY_INFORMATIONSetFileSecuritySetKernelObjectSecuritySetPrivateObjectSecurity</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetUserObjectSecurity(nint hObj, ACL_SIZE_INFORMATION pSIRequested, SECURITY_DESCRIPTOR pSID);

        /// <summary>
        ///Associates a Help context identifier with the specified window.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetWindowContextHelpId(nint unnamedParam1, uint unnamedParam2);

        /// <summary>
        ///Specifies where the content of the window can be displayed.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the top-level window. The window must belong to the current process.</param>
        /// <param name="dwAffinity">Type: DWORDThe display affinity setting that specifies where the content of the window can be displayed.This parameter can be one of the following values.Type: BOOLIf the function succeeds, it returns TRUE; otherwise, it returns FALSE when, for example, the function call is made on a non top-level window. To get extended error information, call GetLastError.This function and GetWindowDisplayAffinity are designed to support the window content protection feature that is new to Windows 7. This feature enables applications to protect their own onscreen window content from being captured or copied through a specific set of public operating system features and APIs. However, it works only when the Desktop Window Manager(DWM) is composing the desktop.It is important to note that unlike a security feature or an implementation of Digital Rights Management (DRM), there is no guarantee that using SetWindowDisplayAffinity and GetWindowDisplayAffinity, and other necessary functions such as DwmIsCompositionEnabled, will strictly protect windowed content, for example where someone takes a photograph of the screen.Starting in Windows 10 Version 2004, WDA_EXCLUDEFROMCAPTURE is a supported value. Setting the display affinity to WDA_EXCLUDEFROMCAPTURE on previous version of Windows will behave as if WDA_MONITOR is applied.SetWindowDisplayAffinity, Windows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetWindowDisplayAffinity(nint hWnd, uint dwAffinity);

        /// <summary>
        ///Sets the feedback configuration for a window.
        /// </summary>
        /// <param name="hwnd">The window to configure feedback on.</param>
        /// <param name="feedback">One of the values from the FEEDBACK_TYPE enumeration.</param>
        /// <param name="dwFlags">Reserved. Must be 0.</param>
        /// <param name="size">The size, in bytes, of the configuration data. Must be sizeof(BOOL) or 0 if the feedback setting is being reset.</param>
        /// <param name="configuration"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetWindowFeedbackSetting(nint hwnd, FEEDBACK_TYPE feedback, uint dwFlags, int size, nint configuration);

        /// <summary>
        ///Changes an attribute of the specified window. The function also sets the 32-bit (long) value at the specified offset into the extra window memory.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe zero-based offset to the value to be set. Valid values are in the range zero through the number of bytes of extra window memory, minus the size of an integer. To set any other value, specify one of the following values.The following values are also available when the hWnd parameter identifies a dialog box.</param>
        /// <param name="dwNewLong">Type: LONGThe replacement value.Type: LONGIf the function succeeds, the return value is the previous value of the specified 32-bit integer.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the previous value of the specified 32-bit integer is zero, and the function succeeds, the return value is zero, but the function does not clear the last error information. This makes it difficult to determine success or failure. To deal with this, you should clear the last error information by calling SetLastError with 0 before calling SetWindowLong. Then, function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.Certain window data is cached, so changes you make using SetWindowLong will not take effect until you call the SetWindowPos function. Specifically, if you change any of the frame styles, you must call SetWindowPos with the SWP_FRAMECHANGED flag for the cache to be updated properly.If you use SetWindowLong with the GWL_WNDPROC index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the WindowProc callback function.If you use SetWindowLong with the DWL_MSGRESULT index to set the return value for a message processed by a dialog procedure, you should return TRUE directly afterward. Otherwise, if you call any function that results in your dialog procedure receiving a window message, the nested window message could overwrite the return value you set using DWL_MSGRESULT.Calling SetWindowLong with the GWL_WNDPROC index creates a subclass of the window class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process. The SetWindowLong function creates the window subclass by changing the window procedure associated with a particular window class, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling CallWindowProc. This allows the application to create a chain of window procedures.Reserve extra window memory by specifying a nonzero value in the cbWndExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.You must not call SetWindowLong with the GWL_HWNDPARENT index to change the parent of a child window. Instead, use the SetParent function.If the window has a class style of CS_CLASSDC or CS_OWNDC, do not set the extended window styles WS_EX_COMPOSITED or WS_EX_LAYERED.Calling SetWindowLong to set the style on a progressbar will reset its position.For an example, see Subclassing a Window.CallWindowProcConceptualGetWindowLongReferenceRegisterClassExSetParentSetWindowLongPtrWNDCLASSEXWindow ClassesWindowProc</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int SetWindowLongA(nint hWnd, int nIndex, int dwNewLong);

        /// <summary>
        ///Changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs. The SetWindowLongPtr function fails if the process that owns the window specified by the hWnd parameter is at a higher process privilege in the UIPI hierarchy than the process the calling thread resides in.Windows XP/2000:   The SetWindowLongPtr function fails if the window specified by the hWnd parameter does not belong to the same process as the calling thread.</param>
        /// <param name="nIndex">Type: intThe zero-based offset to the value to be set. Valid values are in the range zero through the number of bytes of extra window memory, minus the size of a LONG_PTR. To set any other value, specify one of the following values.The following values are also available when the hWnd parameter identifies a dialog box.</param>
        /// <param name="dwNewLong">Type: LONG_PTRThe replacement value.Type: LONG_PTRIf the function succeeds, the return value is the previous value of the specified offset.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the previous value is zero and the function succeeds, the return value is zero, but the function does not clear the last error information. To determine success or failure, clear the last error information by calling SetLastError with 0, then call SetWindowLongPtr. Function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.Certain window data is cached, so changes you make using SetWindowLongPtr will not take effect until you call the SetWindowPos function.If you use SetWindowLongPtr with the GWLP_WNDPROC index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the WindowProc callback function.If you use SetWindowLongPtr with the DWLP_MSGRESULT index to set the return value for a message processed by a dialog box procedure, the dialog box procedure should return TRUE directly afterward. Otherwise, if you call any function that results in your dialog box procedure receiving a window message, the nested window message could overwrite the return value you set by using DWLP_MSGRESULT.Calling SetWindowLongPtr with the GWLP_WNDPROC index creates a subclass of the window class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process. The SetWindowLongPtr function creates the window subclass by changing the window procedure associated with a particular window class, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling CallWindowProc. This allows the application to create a chain of window procedures.Reserve extra window memory by specifying a nonzero value in the cbWndExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.Do not call SetWindowLongPtr with the GWLP_HWNDPARENT index to change the parent of a child window. Instead, use the SetParent function.If the window has a class style of CS_CLASSDC or CS_PARENTDC, do not set the extended window styles WS_EX_COMPOSITED or WS_EX_LAYERED.Calling SetWindowLongPtr to set the style on a progressbar will reset its position.CallWindowProcConceptualGetWindowLongPtrReferenceRegisterClassExSetParentWNDCLASSEXWindow ClassesWindowProc</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int SetWindowLongPtrA(nint hWnd, int nIndex, int dwNewLong);

        /// <summary>
        ///Changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs. The SetWindowLongPtr function fails if the process that owns the window specified by the hWnd parameter is at a higher process privilege in the UIPI hierarchy than the process the calling thread resides in.Windows XP/2000:   The SetWindowLongPtr function fails if the window specified by the hWnd parameter does not belong to the same process as the calling thread.</param>
        /// <param name="nIndex">Type: intThe zero-based offset to the value to be set. Valid values are in the range zero through the number of bytes of extra window memory, minus the size of a LONG_PTR. To set any other value, specify one of the following values.The following values are also available when the hWnd parameter identifies a dialog box.</param>
        /// <param name="dwNewLong">Type: LONG_PTRThe replacement value.Type: LONG_PTRIf the function succeeds, the return value is the previous value of the specified offset.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the previous value is zero and the function succeeds, the return value is zero, but the function does not clear the last error information. To determine success or failure, clear the last error information by calling SetLastError with 0, then call SetWindowLongPtr. Function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.Certain window data is cached, so changes you make using SetWindowLongPtr will not take effect until you call the SetWindowPos function.If you use SetWindowLongPtr with the GWLP_WNDPROC index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the WindowProc callback function.If you use SetWindowLongPtr with the DWLP_MSGRESULT index to set the return value for a message processed by a dialog box procedure, the dialog box procedure should return TRUE directly afterward. Otherwise, if you call any function that results in your dialog box procedure receiving a window message, the nested window message could overwrite the return value you set by using DWLP_MSGRESULT.Calling SetWindowLongPtr with the GWLP_WNDPROC index creates a subclass of the window class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process. The SetWindowLongPtr function creates the window subclass by changing the window procedure associated with a particular window class, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling CallWindowProc. This allows the application to create a chain of window procedures.Reserve extra window memory by specifying a nonzero value in the cbWndExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.Do not call SetWindowLongPtr with the GWLP_HWNDPARENT index to change the parent of a child window. Instead, use the SetParent function.If the window has a class style of CS_CLASSDC or CS_PARENTDC, do not set the extended window styles WS_EX_COMPOSITED or WS_EX_LAYERED.Calling SetWindowLongPtr to set the style on a progressbar will reset its position.CallWindowProcConceptualGetWindowLongPtrReferenceRegisterClassExSetParentWNDCLASSEXWindow ClassesWindowProc</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int SetWindowLongPtrW(nint hWnd, int nIndex, int dwNewLong);

        /// <summary>
        ///Changes an attribute of the specified window. The function also sets the 32-bit (long) value at the specified offset into the extra window memory.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">Type: intThe zero-based offset to the value to be set. Valid values are in the range zero through the number of bytes of extra window memory, minus the size of an integer. To set any other value, specify one of the following values.The following values are also available when the hWnd parameter identifies a dialog box.</param>
        /// <param name="dwNewLong">Type: LONGThe replacement value.Type: LONGIf the function succeeds, the return value is the previous value of the specified 32-bit integer.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the previous value of the specified 32-bit integer is zero, and the function succeeds, the return value is zero, but the function does not clear the last error information. This makes it difficult to determine success or failure. To deal with this, you should clear the last error information by calling SetLastError with 0 before calling SetWindowLong. Then, function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.Certain window data is cached, so changes you make using SetWindowLong will not take effect until you call the SetWindowPos function. Specifically, if you change any of the frame styles, you must call SetWindowPos with the SWP_FRAMECHANGED flag for the cache to be updated properly.If you use SetWindowLong with the GWL_WNDPROC index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the WindowProc callback function.If you use SetWindowLong with the DWL_MSGRESULT index to set the return value for a message processed by a dialog procedure, you should return TRUE directly afterward. Otherwise, if you call any function that results in your dialog procedure receiving a window message, the nested window message could overwrite the return value you set using DWL_MSGRESULT.Calling SetWindowLong with the GWL_WNDPROC index creates a subclass of the window class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process. The SetWindowLong function creates the window subclass by changing the window procedure associated with a particular window class, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling CallWindowProc. This allows the application to create a chain of window procedures.Reserve extra window memory by specifying a nonzero value in the cbWndExtra member of the WNDCLASSEX structure used with the RegisterClassEx function.You must not call SetWindowLong with the GWL_HWNDPARENT index to change the parent of a child window. Instead, use the SetParent function.If the window has a class style of CS_CLASSDC or CS_OWNDC, do not set the extended window styles WS_EX_COMPOSITED or WS_EX_LAYERED.Calling SetWindowLong to set the style on a progressbar will reset its position.For an example, see Subclassing a Window.CallWindowProcConceptualGetWindowLongReferenceRegisterClassExSetParentSetWindowLongPtrWNDCLASSEXWindow ClassesWindowProc</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int SetWindowLongW(nint hWnd, int nIndex, int dwNewLong);

        /// <summary>
        ///Sets the show state and the restored, minimized, and maximized positions of the specified window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window.</param>
        /// <param name="lpwndpl">Type: const WINDOWPLACEMENT*A pointer to a WINDOWPLACEMENT structure that specifies the new show state and window positions.Before calling SetWindowPlacement, set the length member of the WINDOWPLACEMENT structure to sizeof(WINDOWPLACEMENT). SetWindowPlacement fails if the length member is not set correctly.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.If the information specified in WINDOWPLACEMENT would result in a window that is completely off the screen, the system will automatically adjust the coordinates so that the window is visible, taking into account changes in screen resolution and multiple monitor configuration.The length member of WINDOWPLACEMENT must be set to sizeof(WINDOWPLACEMENT). If this member is not set correctly, the function returns FALSE. For additional remarks on the proper use of window placement coordinates, see WINDOWPLACEMENT.ConceptualGetWindowPlacementReferenceWINDOWPLACEMENTWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetWindowPlacement(nint hWnd, WINDOWPLACEMENT lpwndpl);

        /// <summary>
        ///Changes the size, position, and Z order of a child, pop-up, or top-level window. These windows are ordered according to their appearance on the screen. The topmost window receives the highest rank and is the first window in the Z order.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window.</param>
        /// <param name="hWndInsertAfter"></param>
        /// <param name="X">Type: intThe new position of the left side of the window, in client coordinates.</param>
        /// <param name="Y">Type: intThe new position of the top of the window, in client coordinates.</param>
        /// <param name="cx">Type: intThe new width of the window, in pixels.</param>
        /// <param name="cy">Type: intThe new height of the window, in pixels.</param>
        /// <param name="uFlags">Type: UINTThe window sizing and positioning flags. This parameter can be a combination of the following values.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.As part of the Vista re-architecture, all services were moved off the interactive desktop into Session 0. hwnd and window manager operations are only effective inside a session and cross-session attempts to manipulate the hwnd will fail. For more information, see The Windows Vista Developer Story: Application Compatibility Cookbook.If you have changed certain window data using SetWindowLong, you must call SetWindowPos for the changes to take effect. Use the following combination for uFlags: SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED.A window can be made a topmost window either by setting the hWndInsertAfter parameter to HWND_TOPMOST and ensuring that the SWP_NOZORDER flag is not set, or by setting a window's position in the Z order so that it is above any existing topmost windows. When a non-topmost window is made topmost, its owned windows are also made topmost. Its owners, however, are not changed.If neither the SWP_NOACTIVATE nor SWP_NOZORDER flag is specified (that is, when the application requests that a window be simultaneously activated and its position in the Z order changed), the value specified in hWndInsertAfter is used only in the following circumstances.If a topmost window is repositioned to the bottom (HWND_BOTTOM) of the Z order or after any non-topmost window, it is no longer topmost. When a topmost window is made non-topmost, its owners and its owned windows are also made non-topmost windows.A non-topmost window can own a topmost window, but the reverse cannot occur. Any window (for example, a dialog box) owned by a topmost window is itself made a topmost window, to ensure that all owned windows stay above their owner.If an application is not in the foreground, and should be in the foreground, it must call the SetForegroundWindow function.To use SetWindowPos to bring a window to the top, the process that owns the window must have SetForegroundWindow permission.For an example, see Initializing a Dialog Box.ConceptualMoveWindowReferenceSetActiveWindowSetForegroundWindowWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetWindowPos(nint hWnd, nint hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);

        /// <summary>
        ///The SetWindowRgn function sets the window region of a window. The window region determines the area within the window where the system permits drawing. The system does not display any portion of a window that lies outside of the window region
        /// </summary>
        /// <param name="hWnd">A handle to the window whose window region is to be set.</param>
        /// <param name="hRgn">A handle to a region. The function sets the window region of the window to this region.If hRgn is NULL, the function sets the window region to NULL.</param>
        /// <param name="bRedraw">Specifies whether the system redraws the window after setting the window region. If bRedraw is TRUE, the system does so; otherwise, it does not.Typically, you set bRedraw to TRUE if the window is visible.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.When this function is called, the system sends the WM_WINDOWPOSCHANGING and WM_WINDOWPOSCHANGED messages to the window.The coordinates of a window's window region are relative to the upper-left corner of the window, not the client area of the window.To obtain the window region of a window, call the GetWindowRgn function.GetWindowRgnPainting and Drawing FunctionsPainting and Drawing OverviewWM_WINDOWPOSCHANGINGWM_WINDOWPOSCHANGED</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int SetWindowRgn(nint hWnd, nint hRgn, bool bRedraw);

        /// <summary>
        ///Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread.
        /// </summary>
        /// <param name="idHook">Type: intThe type of hook procedure to be installed. This parameter can be one of the following values.</param>
        /// <param name="lpfn">Type: HOOKPROCA pointer to the hook procedure. If the dwThreadId parameter is zero or specifies the identifier of a thread created by a different process, the lpfn parameter must point to a hook procedure in a DLL. Otherwise, lpfn can point to a hook procedure in the code associated with the current process.</param>
        /// <param name="hmod">Type: HINSTANCEA handle to the DLL containing the hook procedure pointed to by the lpfn parameter. The hMod parameter must be set to NULL if the dwThreadId parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.</param>
        /// <param name="dwThreadId">Type: DWORDThe identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread. For Windows Store apps, see the Remarks section.Type: HHOOKIf the function succeeds, the return value is the handle to the hook procedure.If the function fails, the return value is NULL. To get extended error information, call GetLastError.SetWindowsHookEx can be used to inject a DLL into another process. A 32-bit DLL cannot be injected into a 64-bit process, and a 64-bit DLL cannot be injected into a 32-bit process. If an application requires the use of hooks in other processes, it is required that a 32-bit application call SetWindowsHookEx to inject a 32-bit DLL into 32-bit processes, and a 64-bit application call SetWindowsHookEx to inject a 64-bit DLL into 64-bit processes. The 32-bit and 64-bit DLLs must have different names.Because hooks run in the context of an application, they must match the "bitness" of the application. If a 32-bit application installs a global hook on 64-bit Windows, the 32-bit hook is injected into each 32-bit process (the usual security boundaries apply). In a 64-bit process, the threads are still marked as "hooked." However, because a 32-bit application must run the hook code, the system executes the hook in the hooking app's context; specifically, on the thread that called SetWindowsHookEx. This means that the hooking application must continue to pump messages or it might block the normal functioning of the 64-bit processes.If a 64-bit application installs a global hook on 64-bit Windows, the 64-bit hook is injected into each 64-bit process, while all 32-bit processes use a callback to the hooking application.To hook all applications on the desktop of a 64-bit Windows installation, install a 32-bit global hook and a 64-bit global hook, each from appropriate processes, and be sure to keep pumping messages in the hooking application to avoid blocking normal functioning. If you already have a 32-bit global hooking application and it doesn't need to run in each application's context, you may not need to create a 64-bit version.An error may occur if the hMod parameter is NULL and the dwThreadId parameter is zero or specifies the identifier of a thread created by another process.Calling the CallNextHookEx function function to chain to the next hook procedure is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call CallNextHookEx unless you absolutely need to prevent the notification from being seen by other applications.Before terminating, an application must call the UnhookWindowsHookEx function function to free system resources associated with the hook.The scope of a hook depends on the hook type. Some hooks can be set only with global scope; others can also be set for only a specific thread, as shown in the following table.For a specified hook type, thread hooks are called first, then global hooks. Be aware that the WH_MOUSE, WH_KEYBOARD, WH_JOURNAL*, WH_SHELL, and low-level hooks can be called on the thread that installed the hook rather than the thread processing the hook. For these hooks, it is possible that both the 32-bit and 64-bit hooks will be called if a 32-bit hook is ahead of a 64-bit hook in the hook chain.The global hooks are a shared resource, and installing one affects all applications in the same desktop as the calling thread. All global hook functions must be in libraries. Global hooks should be restricted to special-purpose applications or to use as a development aid during application debugging. Libraries that no longer need a hook should remove its hook procedure.Windows Store app development If dwThreadId is zero, then window hook DLLs are not loaded in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed by either UIAccess processes (accessibility tools). The notification is delivered on the installer's thread for these hooks:For an example, see Installing and Releasing Hook Procedures.CallNextHookEx functionCallWindowProc functionUnhookWindowsHookEx functionCBTProcCallWndProcCallWndRetProcDebugProcForegroundIdleProcGetMsgProcJournalPlaybackProcJournalRecordProcKeyboardProcLowLevelKeyboardProcLowLevelMouseProcMessageProcMouseProcShellProcSysMsgProcConceptualHooks</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short SetWindowsHookExA(int idHook, HOOKPROC lpfn, nint hmod, uint dwThreadId);

        /// <summary>
        ///Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread.
        /// </summary>
        /// <param name="idHook">Type: intThe type of hook procedure to be installed. This parameter can be one of the following values.</param>
        /// <param name="lpfn">Type: HOOKPROCA pointer to the hook procedure. If the dwThreadId parameter is zero or specifies the identifier of a thread created by a different process, the lpfn parameter must point to a hook procedure in a DLL. Otherwise, lpfn can point to a hook procedure in the code associated with the current process.</param>
        /// <param name="hmod">Type: HINSTANCEA handle to the DLL containing the hook procedure pointed to by the lpfn parameter. The hMod parameter must be set to NULL if the dwThreadId parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.</param>
        /// <param name="dwThreadId">Type: DWORDThe identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread. For Windows Store apps, see the Remarks section.Type: HHOOKIf the function succeeds, the return value is the handle to the hook procedure.If the function fails, the return value is NULL. To get extended error information, call GetLastError.SetWindowsHookEx can be used to inject a DLL into another process. A 32-bit DLL cannot be injected into a 64-bit process, and a 64-bit DLL cannot be injected into a 32-bit process. If an application requires the use of hooks in other processes, it is required that a 32-bit application call SetWindowsHookEx to inject a 32-bit DLL into 32-bit processes, and a 64-bit application call SetWindowsHookEx to inject a 64-bit DLL into 64-bit processes. The 32-bit and 64-bit DLLs must have different names.Because hooks run in the context of an application, they must match the "bitness" of the application. If a 32-bit application installs a global hook on 64-bit Windows, the 32-bit hook is injected into each 32-bit process (the usual security boundaries apply). In a 64-bit process, the threads are still marked as "hooked." However, because a 32-bit application must run the hook code, the system executes the hook in the hooking app's context; specifically, on the thread that called SetWindowsHookEx. This means that the hooking application must continue to pump messages or it might block the normal functioning of the 64-bit processes.If a 64-bit application installs a global hook on 64-bit Windows, the 64-bit hook is injected into each 64-bit process, while all 32-bit processes use a callback to the hooking application.To hook all applications on the desktop of a 64-bit Windows installation, install a 32-bit global hook and a 64-bit global hook, each from appropriate processes, and be sure to keep pumping messages in the hooking application to avoid blocking normal functioning. If you already have a 32-bit global hooking application and it doesn't need to run in each application's context, you may not need to create a 64-bit version.An error may occur if the hMod parameter is NULL and the dwThreadId parameter is zero or specifies the identifier of a thread created by another process.Calling the CallNextHookEx function function to chain to the next hook procedure is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call CallNextHookEx unless you absolutely need to prevent the notification from being seen by other applications.Before terminating, an application must call the UnhookWindowsHookEx function function to free system resources associated with the hook.The scope of a hook depends on the hook type. Some hooks can be set only with global scope; others can also be set for only a specific thread, as shown in the following table.For a specified hook type, thread hooks are called first, then global hooks. Be aware that the WH_MOUSE, WH_KEYBOARD, WH_JOURNAL*, WH_SHELL, and low-level hooks can be called on the thread that installed the hook rather than the thread processing the hook. For these hooks, it is possible that both the 32-bit and 64-bit hooks will be called if a 32-bit hook is ahead of a 64-bit hook in the hook chain.The global hooks are a shared resource, and installing one affects all applications in the same desktop as the calling thread. All global hook functions must be in libraries. Global hooks should be restricted to special-purpose applications or to use as a development aid during application debugging. Libraries that no longer need a hook should remove its hook procedure.Windows Store apps: If dwThreadId is zero, then window hook DLLs are not loaded in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed by either UIAccess processes (accessibility tools). The notification is delivered on the installer's thread for these hooks:For an example, see Installing and Releasing Hook Procedures.CallNextHookEx functionCallWindowProc functionUnhookWindowsHookEx functionCBTProcCallWndProcCallWndRetProcDebugProcForegroundIdleProcGetMsgProcJournalPlaybackProcJournalRecordProcKeyboardProcLowLevelKeyboardProcLowLevelMouseProcMessageProcMouseProcShellProcSysMsgProcConceptualHooks</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short SetWindowsHookExW(int idHook, HOOKPROC lpfn, nint hmod, uint dwThreadId);

        /// <summary>
        ///Changes the text of the specified window's title bar (if it has one). If the specified window is a control, the text of the control is changed. However, SetWindowText cannot change the text of a control in another application.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window or control whose text is to be changed.</param>
        /// <param name="lpString"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetWindowTextA(nint hWnd, string lpString);

        /// <summary>
        ///Changes the text of the specified window's title bar (if it has one). If the specified window is a control, the text of the control is changed. However, SetWindowText cannot change the text of a control in another application.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window or control whose text is to be changed.</param>
        /// <param name="lpString"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SetWindowTextW(nint hWnd, string lpString);

        /// <summary>
        ///Sets an event hook function for a range of events.
        /// </summary>
        /// <param name="eventMin">Type: UINTSpecifies the event constant for the lowest event value in the range of events that are handled by the hook function. This parameter can be set to EVENT_MIN to indicate the lowest possible event value.</param>
        /// <param name="eventMax">Type: UINTSpecifies the event constant for the highest event value in the range of events that are handled by the hook function. This parameter can be set to EVENT_MAX to indicate the highest possible event value.</param>
        /// <param name="hmodWinEventProc">Type: HMODULEHandle to the DLL that contains the hook function at lpfnWinEventProc, if the WINEVENT_INCONTEXT flag is specified in the dwFlags parameter. If the hook function is not located in a DLL, or if the WINEVENT_OUTOFCONTEXT flag is specified, this parameter is NULL.</param>
        /// <param name="pfnWinEventProc">Type: WINEVENTPROCPointer to the event hook function. For more information about this function, see WinEventProc.</param>
        /// <param name="idProcess">Type: DWORDSpecifies the ID of the process from which the hook function receives events. Specify zero (0) to receive events from all processes on the current desktop.</param>
        /// <param name="idThread">Type: DWORDSpecifies the ID of the thread from which the hook function receives events. If this parameter is zero, the hook function is associated with all existing threads on the current desktop.</param>
        /// <param name="dwFlags">Type: UINTFlag values that specify the location of the hook function and of the events to be skipped. The following flags are valid:The following flag combinations are valid:See Remarks section for information on Windows Store app development.Type: HWINEVENTHOOKIf successful, returns an HWINEVENTHOOK value that identifies this event hook instance. Applications save this return value to use it with the UnhookWinEvent function.If unsuccessful, returns zero.This function allows clients to specify which processes and threads they are interested in.If the idProcess parameter is nonzero and idThread is zero, the hook function receives the specified events from all threads in that process. If the idProcess parameter is zero and idThread is nonzero, the hook function receives the specified events only from the thread specified by idThread. If both are zero, the hook function receives the specified events from all threads and processes.Clients can call SetWinEventHook multiple times if they want to register additional hook functions or listen for additional events.The client thread that calls SetWinEventHook must have a message loop in order to receive events.When you use SetWinEventHook to set a callback in managed code, you should use the GCHandle structure to avoid exceptions. This tells the garbage collector not to move the callback.For out-of-context events, the event is delivered on the same thread that called SetWinEventHook. In some situations, even if you request WINEVENT_INCONTEXT events, the events will still be delivered out-of-context. These scenarios include events from console windows and events from processes that have a different bit-depth (64 bit versus 32 bits) than the caller.While a hook function processes an event, additional events may be triggered, which may cause the hook function to reenter before the processing for the original event is finished. The problem with reentrancy in hook functions is that events are completed out of sequence unless the hook function handles this situation. For more information, see Guarding Against Reentrancy.Windows Store app development If dwFlags is WINEVENT_INCONTEXT AND (idProcess = 0 | idThread = 0), then window hook DLLs are not loaded in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed by UIAccess processes (accessibility tools). The notification is delivered on the installer's thread.This behavior is similar to what happens when there is an architecture mismatch between the hook DLL and the target application process, for example, when the hook DLL is 32-bit and the application process 64-bit.The following example code shows how a client application might listen for menu-start and menu-end events. For simplicity, the event handler just sends some information to the standard output.Registering a Hook FunctionUnhookWinEventWinEventProc</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern WINEVENTPROC SetWinEventHook(uint eventMin, uint eventMax, nint hmodWinEventProc, WINEVENTPROC pfnWinEventProc, uint idProcess, uint idThread, uint dwFlags);

        /// <summary>
        ///Makes the caret visible on the screen at the caret's current position. When the caret becomes visible, it begins flashing automatically.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ShowCaret(nint hWnd);

        /// <summary>
        ///Displays or hides the cursor.
        /// </summary>
        /// <param name="bShow">Type: BOOLIf bShow is TRUE, the display count is incremented by one. If bShow is FALSE, the display count is decremented by one.Type: intThe return value specifies the new display counter.Windows 8: Call GetCursorInfo to determine the cursor visibility.This function sets an internal display counter that determines whether the cursor should be displayed. The cursor is displayed only if the display count is greater than or equal to 0. If a mouse is installed, the initial display count is 0. If no mouse is installed, the display count is –1.ClipCursorConceptualCursorsGetCursorPosReferenceSetCursorSetCursorPos</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ShowCursor(bool bShow);

        /// <summary>
        ///Shows or hides all pop-up windows owned by the specified window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window that owns the pop-up windows to be shown or hidden.</param>
        /// <param name="fShow">Type: BOOLIf this parameter is TRUE, all hidden pop-up windows are shown. If this parameter is FALSE, all visible pop-up windows are hidden.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.ShowOwnedPopups shows only windows hidden by a previous call to ShowOwnedPopups. For example, if a pop-up window is hidden by using the ShowWindow function, subsequently calling ShowOwnedPopups with the fShow parameter set to TRUE does not cause the window to be shown.ConceptualIsWindowVisibleReferenceShowWindowWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ShowOwnedPopups(nint hWnd, bool fShow);

        /// <summary>
        ///The ShowScrollBar function shows or hides the specified scroll bar.
        /// </summary>
        /// <param name="hWnd">Type: HWNDHandle to a scroll bar control or a window with a standard scroll bar, depending on the value of the wBar parameter.</param>
        /// <param name="wBar">Type: intSpecifies the scroll bar(s) to be shown or hidden. This parameter can be one of the following values.</param>
        /// <param name="bShow">Type: BOOLSpecifies whether the scroll bar is shown or hidden. If this parameter is TRUE, the scroll bar is shown; otherwise, it is hidden.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.You should not call this function to hide a scroll bar while processing a scroll bar message.EnableScrollBar</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ShowScrollBar(nint hWnd, int wBar, bool bShow);

        /// <summary>
        ///Sets the specified window's show state.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window.</param>
        /// <param name="nCmdShow">Type: intControls how the window is to be shown. This parameter is ignored the first time an application calls ShowWindow, if the program that launched the application provides a STARTUPINFO structure. Otherwise, the first time ShowWindow is called, the value should be the value obtained by the WinMain function in its nCmdShow parameter. In subsequent calls, this parameter can be one of the following values.Type: BOOLIf the window was previously visible, the return value is nonzero.If the window was previously hidden, the return value is zero.To perform certain special effects when showing or hiding a window, use AnimateWindow.The first time an application calls ShowWindow, it should use the WinMain function's nCmdShow parameter as its nCmdShow parameter. Subsequent calls to ShowWindow must use one of the values in the given list, instead of the one specified by the WinMain function's nCmdShow parameter.As noted in the discussion of the nCmdShow parameter, the nCmdShow value is ignored in the first call to ShowWindow if the program that launched the application specifies startup information in the structure. In this case, ShowWindow uses the information specified in the STARTUPINFO structure to show the window. On subsequent calls, the application must call ShowWindow with nCmdShow set to SW_SHOWDEFAULT to use the startup information provided by the program that launched the application. This behavior is designed for the following situations:For an example, see Creating a Main Window.AnimateWindowConceptualCreateProcessCreateWindowOther ResourcesReferenceSTARTUPINFOShowOwnedPopupsShowWindowAsyncWinMainWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ShowWindow(nint hWnd, int nCmdShow);

        /// <summary>
        ///Sets the show state of a window without waiting for the operation to complete.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window.</param>
        /// <param name="nCmdShow">Type: intControls how the window is to be shown. For a list of possible values, see the description of the ShowWindow function.Type: BOOLIf the operation was successfully started, the return value is nonzero.This function posts a show-window event to the message queue of the given window. An application can use this function to avoid becoming nonresponsive while waiting for a nonresponsive application to finish processing a show-window event.ConceptualReferenceShowWindowWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ShowWindowAsync(nint hWnd, int nCmdShow);

        /// <summary>
        ///Indicates that the system cannot be shut down and sets a reason string to be displayed to the user if system shutdown is initiated.
        /// </summary>
        /// <param name="hWnd">A handle to the main window of the application.</param>
        /// <param name="pwszReason">The reason the application must block system shutdown. This string will be truncated for display purposes after MAX_STR_BLOCKREASON characters.If the call succeeds, the return value is nonzero.If the call fails, the return value is zero. To get extended error information, call GetLastError.This function can only be called from the thread that created the window specified by the hWnd parameter. Otherwise, the function fails and the last error code is ERROR_ACCESS_DENIED.Applications should call this function as they begin an operation that cannot be interrupted, such as burning a CD or DVD. When the operation has completed, call the ShutdownBlockReasonDestroy function to indicate that the system can be shut down.Because users are typically in a hurry when shutting down the system, they may spend only a few seconds looking at the shutdown reasons that are displayed by the system. Therefore, it is important that your reason strings are short and clear. For example "A CD burn is in progress." is better than "This application is blocking system shutdown because a CD burn is in progress. Do not shut down."ShutdownBlockReasonDestroyShutting Down</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ShutdownBlockReasonCreate(nint hWnd, string pwszReason);

        /// <summary>
        ///Indicates that the system can be shut down and frees the reason string.
        /// </summary>
        /// <param name="hWnd">A handle to the main window of the application.If the call succeeds, the return value is nonzero.If the call fails, the return value is zero. To get extended error information, call GetLastError.This function can only be called from the thread that created the window specified by the hWnd parameter. Otherwise, the function fails and the last error code is ERROR_ACCESS_DENIED.If system shutdown has been previously blocked by the ShutdownBlockReasonCreate function, this function frees the reason string. Otherwise, this function is a no-op.ShutdownBlockReasonCreateShutting Down</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ShutdownBlockReasonDestroy(nint hWnd);

        /// <summary>
        ///Retrieves the reason string set by the ShutdownBlockReasonCreate function.
        /// </summary>
        /// <param name="hWnd">A handle to the main window of the application.</param>
        /// <param name="pwszBuff"></param>
        /// <param name="pcchBuff">A pointer to a variable that specifies the size of the pwszBuff buffer, in characters. If the function succeeds, this variable receives the number of characters copied into the buffer, including the null-terminating character. If the buffer is too small, the variable receives the required buffer size, in characters, not including the null-terminating character.If the call succeeds, the return value is nonzero.If the call fails, the return value is zero. To get extended error information, call GetLastError.This function can only be called from the thread that created the window specified by the hWnd parameter. Otherwise, the function fails and the last error code is ERROR_ACCESS_DENIED.The following example retrieves the required buffer size, allocates memory for the reason string, retrieves the reason string, and displays the string as debug output.ShutdownBlockReasonCreateShutting Down</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ShutdownBlockReasonQuery(nint hWnd, out string pwszBuff, out uint pcchBuff);

        /// <summary>
        ///Determines which pointer input frame generated the most recently retrieved message for the specified pointer and discards any queued (unretrieved) pointer input messages generated from the same pointer input frame. If an application has retrieved information for an entire frame using the GetPointerFrameInfo function, the GetPointerFrameInfoHistory function or one of their type-specific variants, it can use this function to avoid retrieving and discarding remaining messages from that frame one by one.
        /// </summary>
        /// <param name="pointerId">Identifier of the pointer. Pending messages will be skipped for the frame that includes the most recently retrieved input for this pointer.If the function succeeds, the return value is non-zero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Parallel-mode devices may report pointer input in frames, that is, they may report the state and position of all pointers from that device in a single input report to the system. Ideally, applications should view the entire frame as a single input unless the application-specific requirements dictate otherwise.The SkipPointerFrameMessages function can be used in conjunction with the GetPointerFrameInfo function (or one of its type-specific variants) to consume entire frames as a single input.When an application sees a pointer message, it can use the GetPointerFrameInfo function to retrieve the entire pointer input frame to which the pointer message belongs, hence obtaining an updated view of all of the pointers currently owned by the window. Note that the returned frame contains only pointers that are currently owned by the same window as the specified pointer.Having retrieved the entire frame of information, the application can then call the SkipPointerFrameMessages function to skip remaining pointer messages associated with this frame that are pending retrieval. This saves the application the overhead of retrieving and processing the remaining messages one by one.If the pointer frame contains no additional pointers besides the specified pointer, this function succeeds with no action.If the calling thread does not own the window to which the pointer message has been delivered, this function fails with the last error set to ERROR_ACCESS_DENIED.Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SkipPointerFrameMessages(int pointerId);

        /// <summary>
        ///Triggers a visual signal to indicate that a sound is playing.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SoundSentry();

        /// <summary>
        ///The SubtractRect function determines the coordinates of a rectangle formed by subtracting one rectangle from another.
        /// </summary>
        /// <param name="lprcDst"></param>
        /// <param name="lprcSrc1">A pointer to a RECT structure from which the function subtracts the rectangle pointed to by lprcSrc2.</param>
        /// <param name="lprcSrc2">A pointer to a RECT structure that the function subtracts from the rectangle pointed to by lprcSrc1.If the resulting rectangle is empty, the return value is zero.If the resulting rectangle is not empty, the return value is nonzero.The function only subtracts the rectangle specified by lprcSrc2 from the rectangle specified by lprcSrc1 when the rectangles intersect completely in either the x- or y-direction. For example, if *lprcSrc1 has the coordinates (10,10,100,100) and *lprcSrc2 has the coordinates (50,50,150,150), the function sets the coordinates of the rectangle pointed to by lprcDst to (10,10,100,100). If *lprcSrc1 has the coordinates (10,10,100,100) and *lprcSrc2 has the coordinates (50,10,150,150), however, the function sets the coordinates of the rectangle pointed to by lprcDst to (10,10,50,100). In other words, the resulting rectangle is the bounding box of the geometric difference.Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure.IntersectRectRECTRectangle FunctionsRectangles OverviewUnionRect</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SubtractRect(out RECT lprcDst, RECT lprcSrc1, RECT lprcSrc2);

        /// <summary>
        ///Reverses or restores the meaning of the left and right mouse buttons.
        /// </summary>
        /// <param name="fSwap">Type: BOOLIf this parameter is TRUE, the left button generates right-button messages and the right button generates left-button messages. If this parameter is FALSE, the buttons are restored to their original meanings.Type: BOOLIf the meaning of the mouse buttons was reversed previously, before the function was called, the return value is nonzero.If the meaning of the mouse buttons was not reversed, the return value is zero.Button swapping is provided as a convenience to people who use the mouse with their left hands. The SwapMouseButton function is usually called by Control Panel only. Although an application is free to call the function, the mouse is a shared resource and reversing the meaning of its buttons affects all applications.ConceptualMouse InputReferenceSetDoubleClickTime</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SwapMouseButton(bool fSwap);

        /// <summary>
        ///Makes the specified desktop visible and activates it. This enables the desktop to receive input from the user. The calling process must have DESKTOP_SWITCHDESKTOP access to the desktop for the SwitchDesktop function to succeed.
        /// </summary>
        /// <param name="hDesktop">A handle to the desktop. This handle is returned by the CreateDesktop and OpenDesktop functions.This desktop must be associated with the current window station for the process.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError. However, SwitchDesktop only sets the last error for the following cases:The SwitchDesktop function fails if the desktop belongs to an invisible window station. SwitchDesktop also fails when called from a process that is associated with a secured desktop such as the WinLogon and ScreenSaver desktops. Processes that are associated with a secured desktop include custom UserInit processes. Such calls typically fail with an "access denied" error.CreateDesktopDesktopsOpenDesktopWindow Station and Desktop Functions</param>
        /// <remarks>
        /// To get extended error information, call GetLastError. However, SwitchDesktop only sets the last error for the following cases:
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SwitchDesktop(nint hDesktop);

        /// <summary>
        ///[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]
        /// </summary>
        /// <param name="hwnd">Type: HWNDA handle to the window.</param>
        /// <param name="fUnknown">Type: BOOLA TRUE for this parameter indicates that the window is being switched to using the Alt/Ctl+Tab key sequence. This parameter should be FALSE otherwise.NoneThis function is typically called to maintain window z-ordering.This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server 2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.ConceptualIsWindowVisibleReferenceShowWindowWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern void SwitchToThisWindow(nint hwnd, bool fUnknown);

        /// <summary>
        ///Retrieves or sets the value of one of the system-wide parameters. This function can also update the user profile while setting a parameter.
        /// </summary>
        /// <param name="uiAction">Type: UINTThe system-wide parameter to be retrieved or set. The possible values are organized in the following tables of related parameters:The following are the accessibility parameters.The following are the desktop parameters.The following are the icon parameters.The following are the input parameters. They include parameters related to the keyboard, mouse, pen, input language, and the warning beeper.The following are the menu parameters.The following are the power parameters.Beginning with Windows Server 2008 and Windows Vista, these power parameters are not supported. Instead, to determine the current display power state, an application should register for GUID_MONITOR_POWER_STATE notifications. To determine the current display power down time-out, an application should register for notification of changes to the GUID_VIDEO_POWERDOWN_TIMEOUT power setting. For more information, see Registering for Power Events.Windows Server 2003 and Windows XP/2000:  To determine the current display power state, use the following power parameters.The following are the screen saver parameters.The following are the time-out parameters for applications and services.The following are the UI effects. The SPI_SETUIEFFECTS value is used to enable or disable all UI effects at once. This table contains the complete list of UI effect values.The following are the window parameters.</param>
        /// <param name="uiParam">Type: UINTA parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see the uiAction parameter. If not otherwise indicated, you must specify zero for this parameter.</param>
        /// <param name="pvParam">Type: PVOIDA parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see the uiAction parameter. If not otherwise indicated, you must specify NULL for this parameter. For information on the PVOID datatype, see Windows Data Types.</param>
        /// <param name="fWinIni">Type: UINTIf a system parameter is being set, specifies whether the user profile is to be updated, and if so, whether the WM_SETTINGCHANGE message is to be broadcast to all top-level windows to notify them of the change.This parameter can be zero if you do not want to update the user profile or broadcast the WM_SETTINGCHANGE message, or it can be one or more of the following values.Type: BOOLIf the function succeeds, the return value is a nonzero value.If the function fails, the return value is zero. To get extended error information, call GetLastError.This function is intended for use with applications that allow the user to customize the environment.A keyboard layout name should be derived from the hexadecimal value of the language identifier corresponding to the layout. For example, U.S. English has a language identifier of 0x0409, so the primary U.S. English layout is named "00000409". Variants of U.S. English layout, such as the Dvorak layout, are named "00010409", "00020409" and so on. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the MAKELANGID macro.There is a difference between the High Contrast color scheme and the High Contrast Mode. The High Contrast color scheme changes the system colors to colors that have obvious contrast; you switch to this color scheme by using the Display Options in the control panel. The High Contrast Mode, which uses SPI_GETHIGHCONTRAST and SPI_SETHIGHCONTRAST, advises applications to modify their appearance for visually-impaired users. It involves such things as audible warning to users and customized color scheme (using the Accessibility Options in the control panel). For more information, see HIGHCONTRAST. For more information on general accessibility features, see Accessibility.During the time that the primary button is held down to activate the Mouse ClickLock feature, the user can move the mouse. After the primary button is locked down, releasing the primary button does not result in a WM_LBUTTONUP message. Thus, it will appear to an application that the primary button is still down. Any subsequent button message releases the primary button, sending a WM_LBUTTONUP message to the application, thus the button can be unlocked programmatically or through the user clicking any button.This API is not DPI aware, and should not be used if the calling thread is per-monitor DPI aware. For the DPI-aware version of this API, see SystemParametersInfoForDPI. For more information on DPI awareness, see the Windows High DPI documentation.The following example uses SystemParametersInfo to double the mouse speed.ACCESSTIMEOUTANIMATIONINFOAUDIODESCRIPTIONFILTERKEYSHIGHCONTRASTICONMETRICSLOGFONTMAKELANGIDMINIMIZEDMETRICSMOUSEKEYSNONCLIENTMETRICSRECTSERIALKEYSSOUNDSENTRYSTICKYKEYSSystemParametersInfoForDPITOGGLEKEYSWM_SETTINGCHANGEWindows Data Types</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SystemParametersInfoA(uint uiAction, uint uiParam, out nint pvParam, uint fWinIni);

        /// <summary>
        ///Retrieves the value of one of the system-wide parameters, taking into account the provided DPI value.
        /// </summary>
        /// <param name="uiAction">The system-wide parameter to be retrieved. This function is only intended for use with SPI_GETICONTITLELOGFONT, SPI_GETICONMETRICS, or SPI_GETNONCLIENTMETRICS. See SystemParametersInfo for more information on these values.</param>
        /// <param name="uiParam">A parameter whose usage and format depends on the system parameter being queried. For more information about system-wide parameters, see the uiAction parameter. If not otherwise indicated, you must specify zero for this parameter.</param>
        /// <param name="pvParam">A parameter whose usage and format depends on the system parameter being queried. For more information about system-wide parameters, see the uiAction parameter. If not otherwise indicated, you must specify NULL for this parameter. For information on the PVOID datatype, see Windows Data Types.</param>
        /// <param name="fWinIni">Has no effect for with this API. This parameter only has an effect if you're setting parameter.</param>
        /// <param name="dpi">The DPI to use for scaling the metric.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.This function returns a similar result as SystemParametersInfo, but scales it according to an arbitrary DPI you provide (if appropriate). It only scales with the following possible values for uiAction: SPI_GETICONTITLELOGFONT, SPI_GETICONMETRICS, SPI_GETNONCLIENTMETRICS. Other possible uiAction values do not provide ForDPI behavior, and therefore this function returns 0 if called with them.For uiAction values that contain strings within their associated structures, only Unicode (LOGFONTW) strings are supported in this function.</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SystemParametersInfoForDpi(uint uiAction, uint uiParam, out nint pvParam, uint fWinIni, uint dpi);

        /// <summary>
        ///Retrieves or sets the value of one of the system-wide parameters. This function can also update the user profile while setting a parameter.
        /// </summary>
        /// <param name="uiAction">Type: UINTThe system-wide parameter to be retrieved or set. The possible values are organized in the following tables of related parameters:The following are the accessibility parameters.The following are the desktop parameters.The following are the icon parameters.The following are the input parameters. They include parameters related to the keyboard, mouse, pen, input language, and the warning beeper.The following are the menu parameters.The following are the power parameters.Beginning with Windows Server 2008 and Windows Vista, these power parameters are not supported. Instead, to determine the current display power state, an application should register for GUID_MONITOR_POWER_STATE notifications. To determine the current display power down time-out, an application should register for notification of changes to the GUID_VIDEO_POWERDOWN_TIMEOUT power setting. For more information, see Registering for Power Events.Windows Server 2003 and Windows XP/2000:  To determine the current display power state, use the following power parameters.The following are the screen saver parameters.The following are the time-out parameters for applications and services.The following are the UI effects. The SPI_SETUIEFFECTS value is used to enable or disable all UI effects at once. This table contains the complete list of UI effect values.The following are the window parameters.</param>
        /// <param name="uiParam">Type: UINTA parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see the uiAction parameter. If not otherwise indicated, you must specify zero for this parameter.</param>
        /// <param name="pvParam">Type: PVOIDA parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see the uiAction parameter. If not otherwise indicated, you must specify NULL for this parameter. For information on the PVOID datatype, see Windows Data Types.</param>
        /// <param name="fWinIni">Type: UINTIf a system parameter is being set, specifies whether the user profile is to be updated, and if so, whether the WM_SETTINGCHANGE message is to be broadcast to all top-level windows to notify them of the change.This parameter can be zero if you do not want to update the user profile or broadcast the WM_SETTINGCHANGE message, or it can be one or more of the following values.Type: BOOLIf the function succeeds, the return value is a nonzero value.If the function fails, the return value is zero. To get extended error information, call GetLastError.This function is intended for use with applications that allow the user to customize the environment.A keyboard layout name should be derived from the hexadecimal value of the language identifier corresponding to the layout. For example, U.S. English has a language identifier of 0x0409, so the primary U.S. English layout is named "00000409". Variants of U.S. English layout, such as the Dvorak layout, are named "00010409", "00020409" and so on. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the MAKELANGID macro.There is a difference between the High Contrast color scheme and the High Contrast Mode. The High Contrast color scheme changes the system colors to colors that have obvious contrast; you switch to this color scheme by using the Display Options in the control panel. The High Contrast Mode, which uses SPI_GETHIGHCONTRAST and SPI_SETHIGHCONTRAST, advises applications to modify their appearance for visually-impaired users. It involves such things as audible warning to users and customized color scheme (using the Accessibility Options in the control panel). For more information, see HIGHCONTRAST. For more information on general accessibility features, see Accessibility.During the time that the primary button is held down to activate the Mouse ClickLock feature, the user can move the mouse. After the primary button is locked down, releasing the primary button does not result in a WM_LBUTTONUP message. Thus, it will appear to an application that the primary button is still down. Any subsequent button message releases the primary button, sending a WM_LBUTTONUP message to the application, thus the button can be unlocked programmatically or through the user clicking any button.This API is not DPI aware, and should not be used if the calling thread is per-monitor DPI aware. For the DPI-aware version of this API, see SystemParametersInfoForDPI. For more information on DPI awareness, see the Windows High DPI documentation.The following example uses SystemParametersInfo to double the mouse speed.ACCESSTIMEOUTANIMATIONINFOAUDIODESCRIPTIONFILTERKEYSHIGHCONTRASTICONMETRICSLOGFONTMAKELANGIDMINIMIZEDMETRICSMOUSEKEYSNONCLIENTMETRICSRECTSERIALKEYSSOUNDSENTRYSTICKYKEYSSystemParametersInfoForDPITOGGLEKEYSWM_SETTINGCHANGEWindows Data Types</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool SystemParametersInfoW(uint uiAction, uint uiParam, out nint pvParam, uint fWinIni);

        /// <summary>
        ///The TabbedTextOut function writes a character string at a specified location, expanding tabs to the values specified in an array of tab-stop positions. Text is written in the currently selected font, background color, and text color.
        /// </summary>
        /// <param name="hdc">A handle to the device context.</param>
        /// <param name="x">The x-coordinate of the starting point of the string, in logical units.</param>
        /// <param name="y">The y-coordinate of the starting point of the string, in logical units.</param>
        /// <param name="lpString">A pointer to the character string to draw. The string does not need to be zero-terminated, since nCount specifies the length of the string.</param>
        /// <param name="chCount">The length of the string pointed to by lpString.</param>
        /// <param name="nTabPositions">The number of values in the array of tab-stop positions.</param>
        /// <param name="lpnTabStopPositions">A pointer to an array containing the tab-stop positions, in logical units. The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array.</param>
        /// <param name="nTabOrigin">The x-coordinate of the starting position from which tabs are expanded, in logical units.If the function succeeds, the return value is the dimensions, in logical units, of the string. The height is in the high-order word and the width is in the low-order word.If the function fails, the return value is zero.If the nTabPositions parameter is zero and the lpnTabStopPositions parameter is NULL, tabs are expanded to eight times the average character width.If nTabPositions is 1, the tab stops are separated by the distance specified by the first value in the lpnTabStopPositions array.If the lpnTabStopPositions array contains more than one value, a tab stop is set for each value in the array, up to the number specified by nTabPositions.The nTabOrigin parameter allows an application to call the TabbedTextOut function several times for a single line. If the application calls TabbedTextOut more than once with the nTabOrigin set to the same value each time, the function expands all tabs relative to the position specified by nTabOrigin.By default, the current position is not used or updated by the TabbedTextOut function. If an application needs to update the current position when it calls TabbedTextOut, the application can call the SetTextAlign function with the wFlags parameter set to TA_UPDATECP. When this flag is set, the system ignores the X and Y parameters on subsequent calls to the TabbedTextOut function, using the current position instead.DrawTextFont and Text FunctionsFonts and Text OverviewGetTabbedTextExtentGrayStringSelectObjectSetBkColorSetTextAlignSetTextColorTextOut</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int TabbedTextOutA(nint hdc, int x, int y, string lpString, int chCount, int nTabPositions, int lpnTabStopPositions, int nTabOrigin);

        /// <summary>
        ///The TabbedTextOut function writes a character string at a specified location, expanding tabs to the values specified in an array of tab-stop positions. Text is written in the currently selected font, background color, and text color.
        /// </summary>
        /// <param name="hdc">A handle to the device context.</param>
        /// <param name="x">The x-coordinate of the starting point of the string, in logical units.</param>
        /// <param name="y">The y-coordinate of the starting point of the string, in logical units.</param>
        /// <param name="lpString">A pointer to the character string to draw. The string does not need to be zero-terminated, since nCount specifies the length of the string.</param>
        /// <param name="chCount">The length of the string pointed to by lpString.</param>
        /// <param name="nTabPositions">The number of values in the array of tab-stop positions.</param>
        /// <param name="lpnTabStopPositions">A pointer to an array containing the tab-stop positions, in logical units. The tab stops must be sorted in increasing order; the smallest x-value should be the first item in the array.</param>
        /// <param name="nTabOrigin">The x-coordinate of the starting position from which tabs are expanded, in logical units.If the function succeeds, the return value is the dimensions, in logical units, of the string. The height is in the high-order word and the width is in the low-order word.If the function fails, the return value is zero.If the nTabPositions parameter is zero and the lpnTabStopPositions parameter is NULL, tabs are expanded to eight times the average character width.If nTabPositions is 1, the tab stops are separated by the distance specified by the first value in the lpnTabStopPositions array.If the lpnTabStopPositions array contains more than one value, a tab stop is set for each value in the array, up to the number specified by nTabPositions.The nTabOrigin parameter allows an application to call the TabbedTextOut function several times for a single line. If the application calls TabbedTextOut more than once with the nTabOrigin set to the same value each time, the function expands all tabs relative to the position specified by nTabOrigin.By default, the current position is not used or updated by the TabbedTextOut function. If an application needs to update the current position when it calls TabbedTextOut, the application can call the SetTextAlign function with the wFlags parameter set to TA_UPDATECP. When this flag is set, the system ignores the X and Y parameters on subsequent calls to the TabbedTextOut function, using the current position instead.DrawTextFont and Text FunctionsFonts and Text OverviewGetTabbedTextExtentGrayStringSelectObjectSetBkColorSetTextAlignSetTextColorTextOut</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int TabbedTextOutW(nint hdc, int x, int y, string lpString, int chCount, int nTabPositions, int lpnTabStopPositions, int nTabOrigin);

        /// <summary>
        ///Tiles the specified child windows of the specified parent window.
        /// </summary>
        /// <param name="hwndParent"></param>
        /// <param name="wHow">Type: UINTThe tiling flags. This parameter can be one of the following values—optionally combined with MDITILE_SKIPDISABLED to prevent disabled MDI child windows from being tiled.</param>
        /// <param name="lpRect"></param>
        /// <param name="cKids">Type: UINTThe number of elements in the array specified by the lpKids parameter. This parameter is ignored if lpKids is NULL.</param>
        /// <param name="lpKids"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short TileWindows(nint hwndParent, uint wHow, RECT lpRect, uint cKids, nint lpKids);

        /// <summary>
        ///Translates the specified virtual-key code and keyboard state to the corresponding character or characters. The function translates the code using the input language and physical keyboard layout identified by the keyboard layout handle.
        /// </summary>
        /// <param name="uVirtKey">Type: UINTThe virtual-key code to be translated. See Virtual-Key Codes.</param>
        /// <param name="uScanCode">Type: UINTThe hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up (not pressed).</param>
        /// <param name="lpKeyState"></param>
        /// <param name="lpChar"></param>
        /// <param name="uFlags">Type: UINTThis parameter must be 1 if a menu is active, or 0 otherwise.Type: intThe return value is one of the following values.The parameters supplied to the ToAscii function might not be sufficient to translate the virtual-key code, because a previous dead key is stored in the keyboard layout.Typically, ToAscii performs the translation based on the virtual-key code. In some cases, however, bit 15 of the uScanCode parameter may be used to distinguish between a key press and a key release. The scan code is used for translating ALT+ number key combinations.Although NUM LOCK is a toggle key that affects keyboard behavior, ToAscii ignores the toggle setting (the low bit) of lpKeyState (VK_NUMLOCK) because the uVirtKey parameter alone is sufficient to distinguish the cursor movement keys (VK_HOME, VK_INSERT, and so on) from the numeric keys (VK_DECIMAL, VK_NUMPAD0 - VK_NUMPAD9).ConceptualKeyboard InputOemKeyScanReferenceToAsciiExToUnicodeVkKeyScan</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ToAscii(uint uVirtKey, uint uScanCode, byte lpKeyState, out uint lpChar, uint uFlags);

        /// <summary>
        ///Translates the specified virtual-key code and keyboard state to the corresponding character or characters. The function translates the code using the input language and physical keyboard layout identified by the input locale identifier.
        /// </summary>
        /// <param name="uVirtKey">Type: UINTThe virtual-key code to be translated. See Virtual-Key Codes.</param>
        /// <param name="uScanCode">Type: UINTThe hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up (not pressed).</param>
        /// <param name="lpKeyState"></param>
        /// <param name="lpChar"></param>
        /// <param name="uFlags">Type: UINTThis parameter must be 1 if a menu is active, zero otherwise.</param>
        /// <param name="dwhkl"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ToAsciiEx(uint uVirtKey, uint uScanCode, byte lpKeyState, out uint lpChar, uint uFlags, nint dwhkl);

        /// <summary>
        ///Translates the specified virtual-key code and keyboard state to the corresponding Unicode character or characters.
        /// </summary>
        /// <param name="wVirtKey">Type: UINTThe virtual-key code to be translated. See Virtual-Key Codes.</param>
        /// <param name="wScanCode">Type: UINTThe hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up.</param>
        /// <param name="lpKeyState"></param>
        /// <param name="pwszBuff"></param>
        /// <param name="cchBuff">Type: intThe size, in characters, of the buffer pointed to by the pwszBuff parameter.</param>
        /// <param name="wFlags">Type: UINTThe behavior of the function.If bit 0 is set, a menu is active. In this mode Alt+Numeric keypad key combinations are not handled.If bit 2 is set, keyboard state is not changed (Windows 10, version 1607 and newer)All other bits (through 31) are reserved.Type: intThe function returns one of the following values.To specify a handle to the keyboard layout to use to translate the specified code, use the ToUnicodeEx function.Some keyboard layouts may return several characters and/or supplementary characters as surrogate pairs in pwszBuff. If a dead key character (accent or diacritic) stored in the keyboard layout could not be combined with the specified virtual key to form a single character then the previous entered dead character can be combined with the current character.The parameters supplied to the ToUnicodeEx function might not be sufficient to translate the virtual-key code because a previous dead key is stored in the keyboard layout.Typically, ToUnicode performs the translation based on the virtual-key code. In some cases, however, bit 15 of the wScanCode parameter can be used to distinguish between a key press and a key release (for example for ALT+numpad key entry).As ToUnicode translates the virtual-key code, it also changes the state of the kernel-mode keyboard buffer. This state-change affects dead keys, ligatures, Alt+Numeric keypad key entry, and so on. It might also cause undesired side-effects if used in conjunction with TranslateMessage (which also changes the state of the kernel-mode keyboard buffer).ConceptualKeyboard InputReferenceToAsciiToUnicodeExVkKeyScan</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ToUnicode(uint wVirtKey, uint wScanCode, byte lpKeyState, out string pwszBuff, int cchBuff, uint wFlags);

        /// <summary>
        ///Translates the specified virtual-key code and keyboard state to the corresponding Unicode character or characters.
        /// </summary>
        /// <param name="wVirtKey">Type: UINTThe virtual-key code to be translated. See Virtual-Key Codes.</param>
        /// <param name="wScanCode">Type: UINTThe hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up.</param>
        /// <param name="lpKeyState">Type: const BYTE*A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key.If the high-order bit of a byte is set, the key is down. The low bit, if set, indicates that the key is toggled on. In this function, only the toggle bit of the CAPS LOCK key is relevant. The toggle state of the NUM LOCK and SCROLL LOCK keys is ignored. See GetKeyboardState for more info.</param>
        /// <param name="pwszBuff"></param>
        /// <param name="cchBuff">Type: intThe size, in characters, of the buffer pointed to by the pwszBuff parameter.</param>
        /// <param name="wFlags">Type: UINTThe behavior of the function.If bit 0 is set, a menu is active. In this mode Alt+Numeric keypad key combinations are not handled.If bit 1 is set, ToUnicodeEx will translate scancodes marked as key break events in addition to its usual treatment of key make events.If bit 2 is set, keyboard state is not changed (Windows 10, version 1607 and newer)All other bits (through 31) are reserved.</param>
        /// <param name="dwhkl"></param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int ToUnicodeEx(uint wVirtKey, uint wScanCode, byte lpKeyState, out string pwszBuff, int cchBuff, uint wFlags, nint dwhkl);

        /// <summary>
        ///Posts messages when the mouse pointer leaves a window or hovers over a window for a specified amount of time.
        /// </summary>
        /// <param name="lpEventTrack">Type: LPTRACKMOUSEEVENTA pointer to a TRACKMOUSEEVENT structure that contains tracking information.Type: BOOLIf the function succeeds, the return value is nonzero .If the function fails, return value is zero. To get extended error information, call GetLastError.The mouse pointer is considered to be hovering when it stays within a specified rectangle for a specified period of time. Call SystemParametersInfo. and use the values SPI_GETMOUSEHOVERWIDTH, SPI_GETMOUSEHOVERHEIGHT, and SPI_GETMOUSEHOVERTIME to retrieve the size of the rectangle and the time.The function can post the following messages.ConceptualMouse InputOther ResourcesReferenceSystemParametersInfoTRACKMOUSEEVENT_TrackMouseEvent</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool TrackMouseEvent(out TRACKMOUSEEVENT lpEventTrack);

        /// <summary>
        ///Displays a shortcut menu at the specified location and tracks the selection of items on the menu. The shortcut menu can appear anywhere on the screen.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the shortcut menu to be displayed. The handle can be obtained by calling CreatePopupMenu to create a new shortcut menu, or by calling GetSubMenu to retrieve a handle to a submenu associated with an existing menu item.</param>
        /// <param name="uFlags">Type: UINTUse zero of more of these flags to specify function options.Use one of the following flags to specify how the function positions the shortcut menu horizontally.Use one of the following flags to specify how the function positions the shortcut menu vertically.Use the following flags to control discovery of the user selection without having to set up a parent window for the menu.Use one of the following flags to specify which mouse button the shortcut menu tracks.Use any reasonable combination of the following flags to modify the animation of a menu. For example, by selecting a horizontal and a vertical flag, you can achieve diagonal animation.For any animation to occur, the SystemParametersInfo function must set SPI_SETMENUANIMATION. Also, all the TPM_*ANIMATION flags, except TPM_NOANIMATION, are ignored if menu fade animation is on. For more information, see the SPI_GETMENUFADE flag in SystemParametersInfo.Use the TPM_RECURSE flag to display a menu when another menu is already displayed. This is intended to support context menus within a menu.For right-to-left text layout, use TPM_LAYOUTRTL. By default, the text layout is left-to-right.</param>
        /// <param name="x">Type: intThe horizontal location of the shortcut menu, in screen coordinates.</param>
        /// <param name="y">Type: intThe vertical location of the shortcut menu, in screen coordinates.</param>
        /// <param name="nReserved">Type: intReserved; must be zero.</param>
        /// <param name="hWnd">Type: HWNDA handle to the window that owns the shortcut menu. This window receives all messages from the menu. The window does not receive a WM_COMMAND message from the menu until the function returns. If you specify TPM_NONOTIFY in the uFlags parameter, the function does not send messages to the window identified by hWnd. However, you must still pass a window handle in hWnd. It can be any window handle from your application.</param>
        /// <param name="prcRect"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool TrackPopupMenu(nint hMenu, uint uFlags, int x, int y, int nReserved, nint hWnd, RECT prcRect);

        /// <summary>
        ///Displays a shortcut menu at the specified location and tracks the selection of items on the shortcut menu. The shortcut menu can appear anywhere on the screen.
        /// </summary>
        /// <param name="hMenu">Type: HMENUA handle to the shortcut menu to be displayed. This handle can be obtained by calling the CreatePopupMenu function to create a new shortcut menu or by calling the GetSubMenu function to retrieve a handle to a submenu associated with an existing menu item.</param>
        /// <param name="uFlags">Type: UINTSpecifies function options.Use one of the following flags to specify how the function positions the shortcut menu horizontally.Use one of the following flags to specify how the function positions the shortcut menu vertically.Use the following flags to control discovery of the user selection without having to set up a parent window for the menu.Use one of the following flags to specify which mouse button the shortcut menu tracks.Use any reasonable combination of the following flags to modify the animation of a menu. For example, by selecting a horizontal and a vertical flag, you can achieve diagonal animation.For any animation to occur, the SystemParametersInfo function must set SPI_SETMENUANIMATION. Also, all the TPM_*ANIMATION flags, except TPM_NOANIMATION, are ignored if menu fade animation is on. For more information, see the SPI_GETMENUFADE flag in SystemParametersInfo.Use the TPM_RECURSE flag to display a menu when another menu is already displayed. This is intended to support context menus within a menu.Use one of the following flags to specify whether to accommodate horizontal or vertical alignment.The excluded rectangle is a portion of the screen that the menu should not overlap; it is specified by the lptpm parameter.For right-to-left text layout, use TPM_LAYOUTRTL. By default, the text layout is left-to-right.</param>
        /// <param name="x">Type: intThe horizontal location of the shortcut menu, in screen coordinates.</param>
        /// <param name="y">Type: intThe vertical location of the shortcut menu, in screen coordinates.</param>
        /// <param name="hwnd">Type: HWNDA handle to the window that owns the shortcut menu. This window receives all messages from the menu. The window does not receive a WM_COMMAND message from the menu until the function returns. If you specify TPM_NONOTIFY in the fuFlags parameter, the function does not send messages to the window identified by hwnd. However, you must still pass a window handle in hwnd. It can be any window handle from your application.</param>
        /// <param name="lptpm"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool TrackPopupMenuEx(nint hMenu, uint uFlags, int x, int y, nint hwnd, TPMPARAMS lptpm);

        /// <summary>
        ///Processes accelerator keys for menu commands. The function translates a WM_KEYDOWN or WM_SYSKEYDOWN message to a WM_COMMAND or WM_SYSCOMMAND message (if there is an entry for the key in the specified accelerator table) and then sends the WM_COMMAND or WM_SYSCOMMAND message directly to the specified window procedure. TranslateAccelerator does not return until the window procedure has processed the message.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose messages are to be translated.</param>
        /// <param name="hAccTable">Type: HACCELA handle to the accelerator table. The accelerator table must have been loaded by a call to the LoadAccelerators function or created by a call to the CreateAcceleratorTable function.</param>
        /// <param name="lpMsg">Type: LPMSGA pointer to an MSG structure that contains message information retrieved from the calling thread's message queue using the GetMessage or PeekMessage function.Type: intIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.To differentiate the message that this function sends from messages sent by menus or controls, the high-order word of the wParam parameter of the WM_COMMAND or WM_SYSCOMMAND message contains the value 1.Accelerator key combinations used to select items from the window menu are translated into WM_SYSCOMMAND messages; all other accelerator key combinations are translated into WM_COMMAND messages.When TranslateAccelerator returns a nonzero value and the message is translated, the application should not use the TranslateMessage function to process the message again.An accelerator need not correspond to a menu command.If the accelerator command corresponds to a menu item, the application is sent WM_INITMENU and WM_INITMENUPOPUP messages, as if the user were trying to display the menu. However, these messages are not sent if any of the following conditions exist:If an accelerator keystroke occurs that corresponds to a menu item when the window that owns the menu is minimized, TranslateAccelerator does not send a WM_COMMAND message. However, if an accelerator keystroke occurs that does not match any of the items in the window's menu or in the window menu, the function sends a WM_COMMAND message, even if the window is minimized.For an example, see Creating Accelerators for Font Attributes.ConceptualCreateAcceleratorTableGetMessageKeyboard AcceleratorsLoadAcceleratorsMSGPeekMessageReferenceSetCaptureTranslateMessageWM_COMMANDWM_INITMENUWM_INITMENUPOPUPWM_KEYDOWNWM_SYSCOMMANDWM_SYSKEYDOWN</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int TranslateAcceleratorA(nint hWnd, ACCEL hAccTable, MSG lpMsg);

        /// <summary>
        ///Processes accelerator keys for menu commands. The function translates a WM_KEYDOWN or WM_SYSKEYDOWN message to a WM_COMMAND or WM_SYSCOMMAND message (if there is an entry for the key in the specified accelerator table) and then sends the WM_COMMAND or WM_SYSCOMMAND message directly to the specified window procedure. TranslateAccelerator does not return until the window procedure has processed the message.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to the window whose messages are to be translated.</param>
        /// <param name="hAccTable">Type: HACCELA handle to the accelerator table. The accelerator table must have been loaded by a call to the LoadAccelerators function or created by a call to the CreateAcceleratorTable function.</param>
        /// <param name="lpMsg">Type: LPMSGA pointer to an MSG structure that contains message information retrieved from the calling thread's message queue using the GetMessage or PeekMessage function.Type: intIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.To differentiate the message that this function sends from messages sent by menus or controls, the high-order word of the wParam parameter of the WM_COMMAND or WM_SYSCOMMAND message contains the value 1.Accelerator key combinations used to select items from the window menu are translated into WM_SYSCOMMAND messages; all other accelerator key combinations are translated into WM_COMMAND messages.When TranslateAccelerator returns a nonzero value and the message is translated, the application should not use the TranslateMessage function to process the message again.An accelerator need not correspond to a menu command.If the accelerator command corresponds to a menu item, the application is sent WM_INITMENU and WM_INITMENUPOPUP messages, as if the user were trying to display the menu. However, these messages are not sent if any of the following conditions exist:If an accelerator keystroke occurs that corresponds to a menu item when the window that owns the menu is minimized, TranslateAccelerator does not send a WM_COMMAND message. However, if an accelerator keystroke occurs that does not match any of the items in the window's menu or in the window menu, the function sends a WM_COMMAND message, even if the window is minimized.For an example, see Creating Accelerators for Font Attributes.</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int TranslateAcceleratorW(nint hWnd, ACCEL hAccTable, MSG lpMsg);

        /// <summary>
        ///Processes accelerator keystrokes for window menu commands of the multiple-document interface (MDI) child windows associated with the specified MDI client window. The function translates WM_KEYUP and WM_KEYDOWN messages to WM_SYSCOMMAND messages and sends them to the appropriate MDI child windows.
        /// </summary>
        /// <param name="hWndClient">Type: HWNDA handle to the MDI client window.</param>
        /// <param name="lpMsg">Type: LPMSGA pointer to a message retrieved by using the GetMessage or PeekMessage function. The message must be an MSG structure and contain message information from the application's message queue.Type: BOOLIf the message is translated into a system command, the return value is nonzero.If the message is not translated into a system command, the return value is zero.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool TranslateMDISysAccel(nint hWndClient, MSG lpMsg);

        /// <summary>
        ///Translates virtual-key messages into character messages. The character messages are posted to the calling thread's message queue, to be read the next time the thread calls the GetMessage or PeekMessage function.
        /// </summary>
        /// <param name="lpMsg">Type: const MSG*A pointer to an MSG structure that contains message information retrieved from the calling thread's message queue by using the GetMessage or PeekMessage function.Type: BOOLIf the message is translated (that is, a character message is posted to the thread's message queue), the return value is nonzero.If the message is WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, or WM_SYSKEYUP, the return value is nonzero, regardless of the translation.If the message is not translated (that is, a character message is not posted to the thread's message queue), the return value is zero.The TranslateMessage function does not modify the message pointed to by the lpMsg parameter.WM_KEYDOWN and WM_KEYUP combinations produce a WM_CHAR or WM_DEADCHAR message. WM_SYSKEYDOWN and WM_SYSKEYUP combinations produce a WM_SYSCHAR or WM_SYSDEADCHAR message.TranslateMessage produces WM_CHAR messages only for keys that are mapped to ASCII characters by the keyboard driver.If applications process virtual-key messages for some other purpose, they should not call TranslateMessage. For instance, an application should not call TranslateMessage if the TranslateAccelerator function returns a nonzero value. Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call IsDialogMessage. For more information, see Dialog Box Keyboard Interface.For an example, see Creating a Message Loop.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool TranslateMessage(MSG lpMsg);

        /// <summary>
        ///Removes a hook procedure installed in a hook chain by the SetWindowsHookEx function.
        /// </summary>
        /// <param name="hhk">Type: HHOOKA handle to the hook to be removed. This parameter is a hook handle obtained by a previous call to SetWindowsHookEx.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The hook procedure can be in the state of being called by another thread even after UnhookWindowsHookEx returns. If the hook procedure is not being called concurrently, the hook procedure is removed immediately before UnhookWindowsHookEx returns.For an example, see Monitoring System Events.ConceptualHooksReferenceSetWindowsHookEx</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnhookWindowsHookEx(short hhk);

        /// <summary>
        ///Removes an event hook function created by a previous call to SetWinEventHook.
        /// </summary>
        /// <param name="hWinEventHook">Type: HWINEVENTHOOKHandle to the event hook returned in the previous call to SetWinEventHook.Type: BOOLIf successful, returns TRUE; otherwise, returns FALSE.Three common errors cause this function to fail:This function removes the event hook specified by hWinEventHook that prevents the corresponding callback function from receiving further event notifications. If the client's thread ends, the system automatically calls this function.Call this function from the same thread that installed the event hook. UnhookWinEvent fails if called from a thread different from the call that corresponds to SetWinEventHook.If WINEVENT_INCONTEXT was specified when this event hook was installed, the system attempts to unload the corresponding DLL from all processes that loaded it. Although unloading does not occur immediately, the hook function is not called after UnhookWinEvent returns. For more information on WINEVENT_INCONTEXT, see In-Context Hook Functions.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnhookWinEvent(WINEVENTPROC hWinEventHook);

        /// <summary>
        ///The UnionRect function creates the union of two rectangles. The union is the smallest rectangle that contains both source rectangles.
        /// </summary>
        /// <param name="lprcDst"></param>
        /// <param name="lprcSrc1">A pointer to the RECT structure that contains the first source rectangle.</param>
        /// <param name="lprcSrc2">A pointer to the RECT structure that contains the second source rectangle.If the specified structure contains a nonempty rectangle, the return value is nonzero.If the specified structure does not contain a nonempty rectangle, the return value is zero.The system ignores the dimensions of an empty rectangle that is, a rectangle in which all coordinates are set to zero, so that it has no height or no width.Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure.InflateRectIntersectRectOffsetRectRECTRectangle FunctionsRectangles Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnionRect(out RECT lprcDst, RECT lprcSrc1, RECT lprcSrc2);

        /// <summary>
        ///Unloads an input locale identifier (formerly called a keyboard layout).
        /// </summary>
        /// <param name="hkl">Type: HKLThe input locale identifier to be unloaded.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. The function can fail for the following reasons:The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input.UnloadKeyboardLayout cannot unload the system default input locale identifier if it is the only keyboard layout loaded. You must first load another input locale identifier before unloading the default input locale identifier.ActivateKeyboardLayoutConceptualGetKeyboardLayoutNameKeyboard InputLoadKeyboardLayoutReference</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnloadKeyboardLayout(nint hkl);

        /// <summary>
        ///Unregisters a window class, freeing the memory required for the class.
        /// </summary>
        /// <param name="lpClassName">Type: LPCTSTRA null-terminated string or a class atom. If lpClassName is a string, it specifies the window class name. This class name must have been registered by a previous call to the RegisterClass or RegisterClassEx function. System classes, such as dialog box controls, cannot be unregistered. If this parameter is an atom, it must be a class atom created by a previous call to the RegisterClass or RegisterClassEx function. The atom must be in the low-order word of lpClassName; the high-order word must be zero.</param>
        /// <param name="hInstance"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnregisterClassA(string lpClassName, nint hInstance);

        /// <summary>
        ///Unregisters a window class, freeing the memory required for the class.
        /// </summary>
        /// <param name="lpClassName">Type: LPCTSTRA null-terminated string or a class atom. If lpClassName is a string, it specifies the window class name. This class name must have been registered by a previous call to the RegisterClass or RegisterClassEx function. System classes, such as dialog box controls, cannot be unregistered. If this parameter is an atom, it must be a class atom created by a previous call to the RegisterClass or RegisterClassEx function. The atom must be in the low-order word of lpClassName; the high-order word must be zero.</param>
        /// <param name="hInstance"></param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnregisterClassW(string lpClassName, nint hInstance);

        /// <summary>
        ///Closes the specified device notification handle.
        /// </summary>
        /// <param name="Handle">Device notification handle returned by the RegisterDeviceNotification function.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Device Management FunctionsDevice NotificationsRegisterDeviceNotificationWM_DEVICECHANGE</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnregisterDeviceNotification(nint Handle);

        /// <summary>
        ///Frees a hot key previously registered by the calling thread.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="id">Type: intThe identifier of the hot key to be freed.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.ConceptualKeyboard InputReferenceRegisterHotKeyWM_HOTKEY</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnregisterHotKey(nint hWnd, int id);

        /// <summary>
        ///Allows the caller to unregister a target window to which all pointer input of the specified type is redirected.
        /// </summary>
        /// <param name="hwnd">Window to be un-registered as a global redirection target on its desktop.</param>
        /// <param name="pointerType">Type of pointer input to no longer be redirected to the specified window. This is any valid and supported value from the POINTER_INPUT_TYPE enumeration. Note that the generic PT_POINTER type and the PT_MOUSE type are not valid in this parameter.If the function succeeds, the return value is non-zero.If the function fails, the return value is zero. To get extended error information, call GetLastError.An application that has successfully called the RegisterPointerInputTarget function can call this function to un-register the window from the role of global redirected target for the specified pointer type.An application that has registered the same window as a global redirection target for multiple pointer input types can call the UnregisterPointerInputTarget to un-register the window for one of those types while leaving the window registered for the remaining types.If the calling thread does not have the UI Access privilege, this function fails with the last error set to ERROR_ACCESS_DENIED.If the specified pointer input type is not valid, this function fails with the last error set to ERROR_INVALID_PARAMETER.If the calling thread does not own the specified window, this function fails with the last error set to ERROR_ACCESS_DENIED.If the specified window is not the registered global redirection target for the specified pointer input type on its desktop, this function takes no action and returns success.</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnregisterPointerInputTarget(nint hwnd, POINTER_INPUT_TYPE pointerType);

        /// <summary>
        ///[UnregisterPointerInputTargetEx is not supported and may be altered or unavailable in the future. Instead, use UnregisterPointerInputTarget.]
        /// </summary>
        /// <param name="hwnd">Not supported.</param>
        /// <param name="pointerType">Not supported.Not supported.UnregisterPointerInputTarget</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnregisterPointerInputTargetEx(nint hwnd, POINTER_INPUT_TYPE pointerType);

        /// <summary>
        ///Unregisters the power setting notification.
        /// </summary>
        /// <param name="Handle">The handle returned from the RegisterPowerSettingNotification function.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.Power Management FunctionsRegisterPowerSettingNotification</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnregisterPowerSettingNotification(POWER_ACTION Handle);

        /// <summary>
        ///Cancels a registration to receive notification when the system is suspended or resumed. Similar to PowerUnregisterSuspendResumeNotification but operates in user mode.
        /// </summary>
        /// <param name="Handle">A handle to a registration obtained by calling the RegisterSuspendResumeNotification function.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.RegisterSuspendResumeNotification</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnregisterSuspendResumeNotification(out POWER_ACTION Handle);

        /// <summary>
        ///Registers a window as no longer being touch-capable.
        /// </summary>
        /// <param name="hwnd">The handle of the window. The function fails with ERROR_ACCESS_DENIED if the calling thread does not own the specified window.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, use the GetLastError function.The UnregisterTouchWindow function succeeds even if the specified window was not previously registered as being touch-capable.FunctionsRegisterTouchWindow</param>
        /// <remarks>
        /// To get extended error information, use the GetLastError function.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UnregisterTouchWindow(nint hwnd);

        /// <summary>
        ///Updates the position, size, shape, content, and translucency of a layered window.
        /// </summary>
        /// <param name="hWnd">Type: HWNDA handle to a layered window. A layered window is created by specifying WS_EX_LAYERED when creating the window with the CreateWindowEx function.Windows 8:  The WS_EX_LAYERED style is supported for top-level windows and child windows. Previous Windows versions support WS_EX_LAYERED only for top-level windows.</param>
        /// <param name="hdcDst"></param>
        /// <param name="pptDst"></param>
        /// <param name="psize"></param>
        /// <param name="hdcSrc"></param>
        /// <param name="pptSrc"></param>
        /// <param name="crKey">Type: COLORREFA structure that specifies the color key to be used when composing the layered window. To generate a COLORREF, use the RGB macro.</param>
        /// <param name="pblend"></param>
        /// <param name="dwFlags">Type: DWORDThis parameter can be one of the following values.If hdcSrc is NULL, dwFlags should be zero.Type: BOOLIf the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The source DC should contain the surface that defines the visible contents of the layered window. For example, you can select a bitmap into a device context obtained by calling the CreateCompatibleDC function.An application should call SetLayout on the hdcSrc device context to properly set the mirroring mode. SetLayout will properly mirror all drawing into an HDC while properly preserving text glyph and (optionally) bitmap direction order. It cannot modify drawing directly into the bits of a device-independent bitmap (DIB). For more information, see Window Layout and Mirroring.The UpdateLayeredWindow function maintains the window's appearance on the screen. The windows underneath a layered window do not need to be repainted when they are uncovered due to a call to UpdateLayeredWindow, because the system will automatically repaint them. This permits seamless animation of the layered window.UpdateLayeredWindow always updates the entire window. To update part of a window, use the traditional WM_PAINT and set the blend value using SetLayeredWindowAttributes.For best drawing performance by the layered window and any underlying windows, the layered window should be as small as possible. An application should also process the message and re-create its layered windows when the display's color depth changes.For more information, see Layered Windows.AlphaBlendConceptualCreateCompatibleBitmapOther ResourcesReferenceSetWindowLongSetWindowPosTransparentBltUpdateLayeredWindowIndirectWindows</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UpdateLayeredWindow(nint hWnd, nint hdcDst, POINT pptDst, SIZE psize, nint hdcSrc, POINT pptSrc, COORD crKey, BLENDFUNCTION pblend, uint dwFlags);

        /// <summary>
        ///The UpdateWindow function updates the client area of the specified window by sending a WM_PAINT message to the window if the window's update region is not empty. The function sends a WM_PAINT message directly to the window procedure of the specified window, bypassing the application queue. If the update region is empty, no message is sent.
        /// </summary>
        /// <param name="hWnd">Handle to the window to be updated.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.ExcludeUpdateRgnGetUpdateRectGetUpdateRgnInvalidateRectInvalidateRgnPainting and Drawing FunctionsPainting and Drawing OverviewWM_PAINT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UpdateWindow(nint hWnd);

        /// <summary>
        ///Grants or denies access to a handle to a User object to a job that has a user-interface restriction. When access is granted, all processes associated with the job can subsequently recognize and use the handle. When access is denied, the processes can no longer use the handle. For more information see User Objects.
        /// </summary>
        /// <param name="hUserHandle">A handle to the User object.</param>
        /// <param name="hJob">A handle to the job to be granted access to the User handle. The CreateJobObject or OpenJobObject function returns this handle.</param>
        /// <param name="bGrant">If this parameter is TRUE, all processes associated with the job can recognize and use the handle. If the parameter is FALSE, the processes cannot use the handle.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError.The UserHandleGrantAccess function can be called only from a process not associated with the job specified by the hJob parameter. The User handle must not be owned by a process or thread associated with the job.To create user-interface restrictions, call the SetInformationJobObject function with the JobObjectBasicUIRestrictions job information class.CreateJobObjectJob ObjectsOpenJobObjectProcess and Thread FunctionsSetInformationJobObject</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool UserHandleGrantAccess(nint hUserHandle, nint hJob, bool bGrant);

        /// <summary>
        ///The ValidateRect function validates the client area within a rectangle by removing the rectangle from the update region of the specified window.
        /// </summary>
        /// <param name="hWnd">Handle to the window whose update region is to be modified. If this parameter is NULL, the system invalidates and redraws all windows and sends the WM_ERASEBKGND and WM_NCPAINT messages to the window procedure before the function returns.</param>
        /// <param name="lpRect">Pointer to a RECT structure that contains the client coordinates of the rectangle to be removed from the update region. If this parameter is NULL, the entire client area is removed.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.The BeginPaint function automatically validates the entire client area. Neither the ValidateRect nor ValidateRgn function should be called if a portion of the update region must be validated before the next WM_PAINT message is generated.The system continues to generate WM_PAINT messages until the current update region is validated.BeginPaintInvalidateRectInvalidateRgnPainting and Drawing FunctionsPainting and Drawing OverviewRECTValidateRgnWM_PAINT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ValidateRect(nint hWnd, RECT lpRect);

        /// <summary>
        ///The ValidateRgn function validates the client area within a region by removing the region from the current update region of the specified window.
        /// </summary>
        /// <param name="hWnd">Handle to the window whose update region is to be modified.</param>
        /// <param name="hRgn">Handle to a region that defines the area to be removed from the update region. If this parameter is NULL, the entire client area is removed.If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.The specified region must have been created by a region function. The region coordinates are assumed to be client coordinates.The BeginPaint function automatically validates the entire client area. Neither the ValidateRect nor ValidateRgn function should be called if a portion of the update region must be validated before the next WM_PAINT message is generated.BeginPaintExcludeUpdateRgnInvalidateRectInvalidateRgnPainting and Drawing FunctionsPainting and Drawing OverviewValidateRectWM_PAINT</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool ValidateRgn(nint hWnd, nint hRgn);

        /// <summary>
        ///[This function has been superseded by the VkKeyScanEx function. You can still use VkKeyScan, however, if you do not need to specify a keyboard layout.]
        /// </summary>
        /// <param name="ch">Type: TCHARThe character to be translated into a virtual-key code.Type: SHORTIf the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains the shift state, which can be a combination of the following flag bits.If the function finds no key that translates to the passed character code, both the low-order and high-order bytes contain –1.For keyboard layouts that use the right-hand ALT key as a shift key (for example, the French keyboard layout), the shift state is represented by the value 6, because the right-hand ALT key is converted internally into CTRL+ALT.Translations for the numeric keypad (VK_NUMPAD0 through VK_DIVIDE) are ignored. This function is intended to translate characters into keystrokes from the main keyboard section only. For example, the character "7" is translated into VK_7, not VK_NUMPAD7.VkKeyScan is used by applications that send characters by using the WM_KEYUP and WM_KEYDOWN messages.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short VkKeyScanA(char ch);

        /// <summary>
        ///Translates a character to the corresponding virtual-key code and shift state. The function translates the character using the input language and physical keyboard layout identified by the input locale identifier.
        /// </summary>
        /// <param name="ch">Type: TCHARThe character to be translated into a virtual-key code.</param>
        /// <param name="dwhkl">Type: HKLInput locale identifier used to translate the character. This parameter can be any input locale identifier previously returned by the LoadKeyboardLayout function.Type: SHORTIf the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains the shift state, which can be a combination of the following flag bits.If the function finds no key that translates to the passed character code, both the low-order and high-order bytes contain –1.The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input.For keyboard layouts that use the right-hand ALT key as a shift key (for example, the French keyboard layout), the shift state is represented by the value 6, because the right-hand ALT key is converted internally into CTRL+ALT.Translations for the numeric keypad (VK_NUMPAD0 through VK_DIVIDE) are ignored. This function is intended to translate characters into keystrokes from the main keyboard section only. For example, the character "7" is translated into VK_7, not VK_NUMPAD7.VkKeyScanEx is used by applications that send characters by using the WM_KEYUP and WM_KEYDOWN messages.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short VkKeyScanExA(char ch, nint dwhkl);

        /// <summary>
        ///Translates a character to the corresponding virtual-key code and shift state. The function translates the character using the input language and physical keyboard layout identified by the input locale identifier.
        /// </summary>
        /// <param name="ch">Type: TCHARThe character to be translated into a virtual-key code.</param>
        /// <param name="dwhkl">Type: HKLInput locale identifier used to translate the character. This parameter can be any input locale identifier previously returned by the LoadKeyboardLayout function.Type: SHORTIf the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains the shift state, which can be a combination of the following flag bits.If the function finds no key that translates to the passed character code, both the low-order and high-order bytes contain –1.The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other form of input.For keyboard layouts that use the right-hand ALT key as a shift key (for example, the French keyboard layout), the shift state is represented by the value 6, because the right-hand ALT key is converted internally into CTRL+ALT.Translations for the numeric keypad (VK_NUMPAD0 through VK_DIVIDE) are ignored. This function is intended to translate characters into keystrokes from the main keyboard section only. For example, the character "7" is translated into VK_7, not VK_NUMPAD7.VkKeyScanEx is used by applications that send characters by using the WM_KEYUP and WM_KEYDOWN messages.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short VkKeyScanExW(StringBuilder ch, nint dwhkl);

        /// <summary>
        ///[This function has been superseded by the VkKeyScanEx function. You can still use VkKeyScan, however, if you do not need to specify a keyboard layout.]
        /// </summary>
        /// <param name="ch">Type: TCHARThe character to be translated into a virtual-key code.Type: SHORTIf the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains the shift state, which can be a combination of the following flag bits.If the function finds no key that translates to the passed character code, both the low-order and high-order bytes contain –1.For keyboard layouts that use the right-hand ALT key as a shift key (for example, the French keyboard layout), the shift state is represented by the value 6, because the right-hand ALT key is converted internally into CTRL+ALT.Translations for the numeric keypad (VK_NUMPAD0 through VK_DIVIDE) are ignored. This function is intended to translate characters into keystrokes from the main keyboard section only. For example, the character "7" is translated into VK_7, not VK_NUMPAD7.VkKeyScan is used by applications that send characters by using the WM_KEYUP and WM_KEYDOWN messages.</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern short VkKeyScanW(StringBuilder ch);

        /// <summary>
        ///Waits until the specified process has finished processing its initial input and is waiting for user input with no input pending, or until the time-out interval has elapsed.
        /// </summary>
        /// <param name="hProcess">A handle to the process. If this process is a console application or does not have a message queue, WaitForInputIdle returns immediately.</param>
        /// <param name="dwMilliseconds">The time-out interval, in milliseconds. If dwMilliseconds is INFINITE, the function does not return until the process is idle.The following table shows the possible return values for this function.The WaitForInputIdle function enables a thread to suspend its execution until the specified process has finished its initialization and is waiting for user input with no input pending. If the process has multiple threads, the WaitForInputIdle function returns as soon as any thread becomes idle.WaitForInputIdle can be used at any time, not just during application startup. However, WaitForInputIdle waits only once for a process to become idle; subsequent WaitForInputIdle calls return immediately, whether the process is idle or busy.WaitForInputIdle can be useful for synchronizing a parent process and a newly created child process. When a parent process creates a child process, the CreateProcess function returns without waiting for the child process to finish its initialization. Before trying to communicate with the child process, the parent process can use the WaitForInputIdle function to determine when the child's initialization has been completed. For example, the parent process should use the WaitForInputIdle function before trying to find a window associated with the child process.CreateProcessProcess and Thread FunctionsSynchronizing Execution of Multiple Threads</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern uint WaitForInputIdle(nint hProcess, uint dwMilliseconds);

        /// <summary>
        ///Yields control to other threads when a thread has no other messages in its message queue. The WaitMessage function suspends the thread and does not return until a new message is placed in the thread's message queue.
        /// </summary>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool WaitMessage();

        /// <summary>
        ///The WindowFromDC function returns a handle to the window associated with the specified display device context (DC). Output functions that use the specified device context draw into this window.
        /// </summary>
        /// <param name="hDC">Handle to the device context from which a handle to the associated window is to be retrieved.The return value is a handle to the window associated with the specified DC. If no window is associated with the specified DC, the return value is NULL.GetDCGetDCExGetWindowDCPainting and Drawing FunctionsPainting and Drawing Overview</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint WindowFromDC(nint hDC);

        /// <summary>
        ///Retrieves a handle to the window that contains the specified physical point.
        /// </summary>
        /// <param name="Point">Type: POINTThe physical coordinates of the point.Type: HWNDA handle to the window that contains the given physical point. If no window exists at the point, this value is NULL.The WindowFromPhysicalPoint function does not retrieve a handle to a hidden or disabled window, even if the point is within the window.ChildWindowFromPointConceptualOther ResourcesPOINTReferenceWindowFromDCWindowFromPointWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint WindowFromPhysicalPoint(POINT Point);

        /// <summary>
        ///Retrieves a handle to the window that contains the specified point.
        /// </summary>
        /// <param name="Point">Type: POINTThe point to be checked.Type: HWNDThe return value is a handle to the window that contains the point. If no window exists at the given point, the return value is NULL. If the point is over a static text control, the return value is a handle to the window under the static text control.The WindowFromPoint function does not retrieve a handle to a hidden or disabled window, even if the point is within the window. An application should use the ChildWindowFromPoint function for a nonrestrictive search.For an example, see "Interface from Running Object Table" in About Text Object Model.ChildWindowFromPointConceptualOther ResourcesPOINTReferenceWindowFromDCWindows</param>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern nint WindowFromPoint(POINT Point);

        /// <summary>
        ///Launches Windows Help (Winhelp.exe) and passes additional data that indicates the nature of the help requested by the application.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool WinHelpA(string lpszHelp, uint uCommand, uint dwData);

        /// <summary>
        ///Launches Windows Help (Winhelp.exe) and passes additional data that indicates the nature of the help requested by the application.
        /// </summary>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool WinHelpW(string lpszHelp, uint uCommand, uint dwData);

        /// <summary>
        ///Writes formatted data to the specified buffer. Any arguments are converted and copied to the output buffer according to the corresponding format specification in the format string. The function appends a terminating null character to the characters it writes, but the return value does not include the terminating null character in its character count.
        /// </summary>
        /// <param name="unnamedParam1"></param>
        /// <param name="unnamedParam2">Type: LPCTSTRThe format-control specifications. In addition to ordinary ASCII characters, a format specification for each argument appears in this string. For more information about the format specification, see the Remarks section....One or more optional arguments. The number and type of argument parameters depend on the corresponding format-control specifications in the lpFmt parameter.Type: intIf the function succeeds, the return value is the number of characters stored in the output buffer, not counting the terminating null character.If the function fails, the return value is less than the length of the expected output. To get extended error information, call GetLastError.The format-control string contains format specifications that determine the output format for the arguments following the lpFmt parameter. Format specifications, discussed below, always begin with a percent sign (%). If a percent sign is followed by a character that has no meaning as a format field, the character is not formatted (for example, %% produces a single percent-sign character).The format-control string is read from left to right. When the first format specification (if any) is encountered, it causes the value of the first argument after the format-control string to be converted and copied to the output buffer according to the format specification. The second format specification causes the second argument to be converted and copied, and so on. If there are more arguments than format specifications, the extra arguments are ignored. If there are not enough arguments for all of the format specifications, the results are undefined.A format specification has the following form:%[-][#][0][width][.precision]typeEach field is a single character or a number signifying a particular format option. The type characters that appear after the last optional format field determine whether the associated argument is interpreted as a character, a string, or a number. The simplest format specification contains only the percent sign and a type character (for example, %s). The optional fields control other aspects of the formatting. Following are the optional and required fields and their meanings.ConceptualReferenceStringCbPrintfStringCbPrintfExStringCbVPrintfStringCbVPrintfExStringCchPrintfStringCchPrintfExStringCchVPrintfStringCchVPrintfExStringswvsprintf</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int wsprintfA(out string unnamedParam1, string unnamedParam2);

        /// <summary>
        ///Writes formatted data to the specified buffer. Any arguments are converted and copied to the output buffer according to the corresponding format specification in the format string. The function appends a terminating null character to the characters it writes, but the return value does not include the terminating null character in its character count.
        /// </summary>
        /// <param name="unnamedParam1"></param>
        /// <param name="unnamedParam2">Type: LPCTSTRThe format-control specifications. In addition to ordinary ASCII characters, a format specification for each argument appears in this string. For more information about the format specification, see the Remarks section....One or more optional arguments. The number and type of argument parameters depend on the corresponding format-control specifications in the lpFmt parameter.Type: intIf the function succeeds, the return value is the number of characters stored in the output buffer, not counting the terminating null character.If the function fails, the return value is less than the length of the expected output. To get extended error information, call GetLastError.The format-control string contains format specifications that determine the output format for the arguments following the lpFmt parameter. Format specifications, discussed below, always begin with a percent sign (%). If a percent sign is followed by a character that has no meaning as a format field, the character is not formatted (for example, %% produces a single percent-sign character).The format-control string is read from left to right. When the first format specification (if any) is encountered, it causes the value of the first argument after the format-control string to be converted and copied to the output buffer according to the format specification. The second format specification causes the second argument to be converted and copied, and so on. If there are more arguments than format specifications, the extra arguments are ignored. If there are not enough arguments for all of the format specifications, the results are undefined.A format specification has the following form:%[-][#][0][width][.precision]typeEach field is a single character or a number signifying a particular format option. The type characters that appear after the last optional format field determine whether the associated argument is interpreted as a character, a string, or a number. The simplest format specification contains only the percent sign and a type character (for example, %s). The optional fields control other aspects of the formatting. Following are the optional and required fields and their meanings.ConceptualReferenceStringCbPrintfStringCbPrintfExStringCbVPrintfStringCbVPrintfExStringCchPrintfStringCchPrintfExStringCchVPrintfStringCchVPrintfExStringswvsprintf</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int wsprintfW(out string unnamedParam1, string unnamedParam2);

        /// <summary>
        ///Writes formatted data to the specified buffer using a pointer to a list of arguments. The items pointed to by the argument list are converted and copied to an output buffer according to the corresponding format specification in the format-control string. The function appends a terminating null character to the characters it writes, but the return value does not include the terminating null character in its character count.
        /// </summary>
        /// <param name="unnamedParam1"></param>
        /// <param name="unnamedParam2">Type: LPCTSTRThe format-control specifications. In addition to ordinary ASCII characters, a format specification for each argument appears in this string. For more information about the format specification, see the wsprintf function.</param>
        /// <param name="arglist">Type: va_listEach element of this list specifies an argument for the format-control string. The number, type, and interpretation of the arguments depend on the corresponding format-control specifications in the lpFmt parameter.Type: intIf the function succeeds, the return value is the number of characters stored in the buffer, not counting the terminating null character.If the function fails, the return value is less than the length of the expected output. To get extended error information, call GetLastError.The function copies the format-control string into the output buffer character by character, starting with the first character in the string. When it encounters a format specification in the string, the function retrieves the value of the next available argument (starting with the first argument in the list), converts that value into the specified format, and copies the result to the output buffer. The function continues to copy characters and expand format specifications in this way until it reaches the end of the format-control string. If there are more arguments than format specifications, the extra arguments are ignored. If there are not enough arguments for all of the format specifications, the results are undefined.ConceptualReferenceStringCbPrintfStringCbPrintfExStringCbVPrintfStringCbVPrintfExStringCchPrintfStringCchPrintfExStringCchVPrintfStringCchVPrintfExStringswsprintf</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int wvsprintfA(out string unnamedParam1, string unnamedParam2, object arglist);

        /// <summary>
        ///Writes formatted data to the specified buffer using a pointer to a list of arguments. The items pointed to by the argument list are converted and copied to an output buffer according to the corresponding format specification in the format-control string. The function appends a terminating null character to the characters it writes, but the return value does not include the terminating null character in its character count.
        /// </summary>
        /// <param name="unnamedParam1"></param>
        /// <param name="unnamedParam2">Type: LPCTSTRThe format-control specifications. In addition to ordinary ASCII characters, a format specification for each argument appears in this string. For more information about the format specification, see the wsprintf function.</param>
        /// <param name="arglist">Type: va_listEach element of this list specifies an argument for the format-control string. The number, type, and interpretation of the arguments depend on the corresponding format-control specifications in the lpFmt parameter.Type: intIf the function succeeds, the return value is the number of characters stored in the buffer, not counting the terminating null character.If the function fails, the return value is less than the length of the expected output. To get extended error information, call GetLastError.The function copies the format-control string into the output buffer character by character, starting with the first character in the string. When it encounters a format specification in the string, the function retrieves the value of the next available argument (starting with the first argument in the list), converts that value into the specified format, and copies the result to the output buffer. The function continues to copy characters and expand format specifications in this way until it reaches the end of the format-control string. If there are more arguments than format specifications, the extra arguments are ignored. If there are not enough arguments for all of the format specifications, the results are undefined.ConceptualReferenceStringCbPrintfStringCbPrintfExStringCbVPrintfStringCbVPrintfExStringCchPrintfStringCchPrintfExStringCchVPrintfStringCchVPrintfExStringswsprintf</param>
        /// <remarks>
        /// To get extended error information, call GetLastError.
        /// </remarks>

        [DllImport("User32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern int wvsprintfW(out string unnamedParam1, string unnamedParam2, object arglist);


    }
}